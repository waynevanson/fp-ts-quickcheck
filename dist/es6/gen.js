/**
 * @description
 * When researching how to create this library, there's definitely a lack of documentation on how the internals work.
 *
 * So a generator `Gen<A>` can functionally generate a value of `A`, given a `seed` and a `size`.
 * Some generators don't need these values, but `seed` is the most commonly used one.
 *
 * We use the `State` monad because it gives us a level of determinism that allows troubleshooting and shrinking of values.
 *
 * All values must be possibly generated by numbers, so we can use the seed or size parameters from the state.
 */
import * as lcg from "@no-day/fp-ts-lcg";
import { readonlyArray as A, state as S, ord as ORD, number as NUM, } from "fp-ts";
import { flow, pipe, } from "fp-ts/lib/function";
import * as lens from "monocle-ts/Lens";
export const URI = "Gen";
/**
 * @summary
 * State's `get` constructor but with `GenState` type applied.
 */
export const stated = S.get();
export function repeatable(kleisli) {
    return pipe(stated, S.map((state) => flow(kleisli, S.evaluate(state))), S.chainFirst(() => next));
}
/**
 * @summary
 * Change the seed to a specific value, useful for shrinking and other
 * deterministic operations.
 *
 * @category Constructors
 */
export function variant(seed) {
    return S.modify(pipe(lens.id(), lens.prop("seed"), lens.modify(() => lcg.mkSeed(seed))));
}
/**
 * @summary
 * Get the size of the current generator.
 */
export const sized = S.gets((state) => state.size);
export const seeded = S.gets((state) => lcg.unSeed(state.seed));
/**
 * @summary
 * Select a randomly uniform integer betwee `min` and `max`. Also takes a bounded instance.
 *
 * This were to be called "range", but range should be applied to the seed or size
 *
 * @todo **note**: Normalize the value to a 32 bit integer.
 */
export function chooseInt(min, max) {
    return pipe(uniform, S.map(ORD.clamp(NUM.Ord)(min, max)));
}
/**
 * @summary
 * From a `ReadonlyNonEmptyArray` of `Gen<A>`'s, randomly pick a generator.
 *
 * @category Combinators
 */
export function oneOf(gens) {
    return pipe(chooseInt(0, A.size(gens) - 1), 
    // index is always in range
    S.chain((index) => gens[index]));
}
/**
 * @summary
 *
 * **Please note** that this may loop forever if the predicate never returns true.
 *
 * @todo Implement as stack safe.
 */
export function suchThat(predicate) {
    return (gen) => {
        const self = pipe(gen, S.chain((a) => (predicate(a) ? S.of(a) : self)));
        return self;
    };
}
export const next = S.modify(pipe(lens.id(), lens.prop("seed"), lens.modify(lcg.lcgNext)));
export const uniform = pipe(next, S.chain(() => seeded));
/**
 * @summary
 * Modifies the seed using an LCG perturber
 */
export function perturb(perturber) {
    return S.modify(pipe(lens.id(), lens.prop("seed"), lens.modify(lcg.lcgPertub(perturber))));
}
