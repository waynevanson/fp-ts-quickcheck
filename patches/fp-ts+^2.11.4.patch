# generated by patch-package 6.4.10
#
# command:
#   npx patch-package fp-ts
#
# declared package:
#   fp-ts: ^2.11.4
#
diff --git a/node_modules/fp-ts/CHANGELOG.md b/node_modules/fp-ts/CHANGELOG.md
index 203e622..963d034 100644
--- a/node_modules/fp-ts/CHANGELOG.md
+++ b/node_modules/fp-ts/CHANGELOG.md
@@ -16,96 +16,6 @@
 **Note**: A feature tagged as Experimental is in a
 high state of flux, you're at risk of it changing without notice.
 
-# 2.12.0
-
-- **New Feature**
-  - add `IOOption` module (@gcanti)
-  - `Array`
-    - add `intercalate`, #1678 (@thewilkybarkid)
-  - `Bounded`
-    - add `clamp` (@gcanti)
-    - add `reverse` (@gcanti)
-  - `Either`
-    - add `apFirstW`, #1564 (@DenisFrezzato)
-    - add `apSecondW`, #1564 (@DenisFrezzato)
-  - `EitherT`
-    - add `chainNullableK`, #1619 (@cwstra)
-    - add `fromNullable`, #1619 (@cwstra)
-    - add `fromNullableK`, #1619 (@cwstra)
-  - `FromEither`
-    - add `chainFirstEitherK` (@gcanti)
-  - `IOEither`
-    - add `apFirstW`, #1564 (@DenisFrezzato)
-    - add `apSecondW`, #1564 (@DenisFrezzato)
-    - add `chainFirstEitherK` (@gcanti)
-    - add `chainFirstEitherKW` (@gcanti)
-    - add `orElseFirstIOK`, #1655 (@thewilkybarkid)
-    - add `bracketW`, #1627 (@thomasvargiu)
-  - `NonEmptyArray`
-    - add `intercalate`, #1678 (@thewilkybarkid)
-  - `Option`
-    - add `chainFirstEitherK` (@gcanti)
-  - `Ordering`
-    - add `matchW`, #1535 (@mlegenhausen)
-  - `Reader`
-    - add `apFirstW`, #1564 (@DenisFrezzato)
-    - add `apSecondW`, #1564 (@DenisFrezzato)
-  - `ReaderEither`
-    - add `apFirstW`, #1564 (@DenisFrezzato)
-    - add `apSecondW`, #1564 (@DenisFrezzato)
-    - add `chainFirstEitherK` (@gcanti)
-    - add `chainFirstEitherKW` (@gcanti)
-  - `ReaderTaskEither`
-    - add `apFirstW`, #1564 (@DenisFrezzato)
-    - add `apSecondW`, #1564 (@DenisFrezzato)
-    - add `chainFirstEitherK`, #1562 (@DenisFrezzato)
-    - add `chainFirstEitherKW`, #1562 (@DenisFrezzato)
-    - add `bracketW`, #1627 (@thomasvargiu)
-    - add `chainNullableK` (@gcanti)
-    - add `fromNullable` (@gcanti)
-    - add `fromNullableK` (@gcanti)
-  - `ReadonlyArray`
-    - add `intercalate`, #1678 (@thewilkybarkid)
-  - `ReadonlyNonEmptyArray`
-    - add `intercalate`, #1678 (@thewilkybarkid)
-  - `ReadonlyRecord`
-    - add `toEntries`, #1552 (@bravely)
-    - add `fromEntries`, #1552 (@bravely)
-  - `Record`
-    - add `toEntries`, #1552 (@bravely)
-    - add `fromEntries`, #1552 (@bravely)
-  - `StateReaderTaskEither`
-    - add `apFirstW`, #1564 (@DenisFrezzato)
-    - add `apSecondW`, #1564 (@DenisFrezzato)
-    - add `chainFirstEitherK` (@gcanti)
-    - add `chainFirstEitherKW` (@gcanti)
-  - `TaskEither`
-    - add `apFirstW`, #1564 (@DenisFrezzato)
-    - add `apSecondW`, #1564 (@DenisFrezzato)
-    - add `chainFirstEitherK`, #1659 (@vinassefranche)
-    - add `chainFirstEitherKW`, #1659 (@vinassefranche)
-    - add `orElseFirstIOK`, #1655 (@thewilkybarkid)
-    - add `orElseFirstTaskK`, #1655 (@thewilkybarkid)
-    - add `bracketW`, #1627 (@thomasvargiu)
-    - add `chainNullableK`, #1619 (@cwstra)
-    - add `fromNullable`, #1619 (@cwstra)
-    - add `fromNullableK`, #1619 (@cwstra)
-  - `TaskOption`
-    - add `fromEitherK` (@gcanti)
-    - add `chainEitherK` (@gcanti)
-    - add `chainFirstEitherK` (@gcanti)
-
-# 2.11.10
-
-- **Polish**
-  - `TaskEither` / `TaskOption`
-    - now `tryCatch` / `tryCatchK` will catch synchronous errors too, #1676 (@thewilkybarkid)
-
-# 2.11.9
-
-- **Polish**
-  - add `Refinement` overload to 'every' functions, #1681 (@mlegenhausen)
-
 # 2.11.8
 
 - **Polish**
diff --git a/node_modules/fp-ts/es6/Array.d.ts b/node_modules/fp-ts/es6/Array.d.ts
index 6cac9bf..993334c 100644
--- a/node_modules/fp-ts/es6/Array.d.ts
+++ b/node_modules/fp-ts/es6/Array.d.ts
@@ -2096,10 +2096,7 @@ export declare const unsafeDeleteAt: <A>(i: number, as: A[]) => A[]
  *
  * @since 2.9.0
  */
-export declare const every: {
-  <A, B extends A>(refinement: Refinement<A, B>): Refinement<Array<A>, Array<B>>
-  <A>(predicate: Predicate<A>): Predicate<Array<A>>
-}
+export declare const every: <A>(predicate: Predicate<A>) => (as: Array<A>) => boolean
 /**
  * `some` tells if the provided predicate holds true at least for one element in the `Array`.
  *
@@ -2118,18 +2115,6 @@ export declare const some: <A>(predicate: Predicate<A>) => (as: A[]) => as is NE
  * @since 2.11.0
  */
 export declare const exists: <A>(predicate: Predicate<A>) => (as: A[]) => as is NEA.NonEmptyArray<A>
-/**
- * Places an element in between members of an `Array`, then folds the results using the provided `Monoid`.
- *
- * @example
- * import * as S from 'fp-ts/string'
- * import { intercalate } from 'fp-ts/Array'
- *
- * assert.deepStrictEqual(intercalate(S.Monoid)('-')(['a', 'b', 'c']), 'a-b-c')
- *
- * @since 2.12.0
- */
-export declare const intercalate: <A>(M: Monoid<A>) => (middle: A) => (as: Array<A>) => A
 /**
  * @since 2.9.0
  */
diff --git a/node_modules/fp-ts/es6/Array.js b/node_modules/fp-ts/es6/Array.js
index 82e6730..32df6f6 100644
--- a/node_modules/fp-ts/es6/Array.js
+++ b/node_modules/fp-ts/es6/Array.js
@@ -2365,18 +2365,6 @@ export var some = function (predicate) { return function (as) { return as.some(p
  * @since 2.11.0
  */
 export var exists = some;
-/**
- * Places an element in between members of an `Array`, then folds the results using the provided `Monoid`.
- *
- * @example
- * import * as S from 'fp-ts/string'
- * import { intercalate } from 'fp-ts/Array'
- *
- * assert.deepStrictEqual(intercalate(S.Monoid)('-')(['a', 'b', 'c']), 'a-b-c')
- *
- * @since 2.12.0
- */
-export var intercalate = RA.intercalate;
 // -------------------------------------------------------------------------------------
 // do notation
 // -------------------------------------------------------------------------------------
diff --git a/node_modules/fp-ts/es6/Bounded.d.ts b/node_modules/fp-ts/es6/Bounded.d.ts
index 19916bf..5b13290 100644
--- a/node_modules/fp-ts/es6/Bounded.d.ts
+++ b/node_modules/fp-ts/es6/Bounded.d.ts
@@ -7,8 +7,7 @@
  *
  * @since 2.0.0
  */
-import * as O from './Ord'
-import Ord = O.Ord
+import { Ord } from './Ord'
 /**
  * @category type classes
  * @since 2.0.0
@@ -17,20 +16,6 @@ export interface Bounded<A> extends Ord<A> {
   readonly top: A
   readonly bottom: A
 }
-/**
- * Clamp a value between bottom and top values.
- *
- * @category utils
- * @since 2.12.0
- */
-export declare const clamp: <T>(B: Bounded<T>) => (a: T) => T
-/**
- * Reverses the Ord of a bound and swaps top and bottom values.
- *
- * @category utils
- * @since 2.12.0
- */
-export declare const reverse: <T>(B: Bounded<T>) => Bounded<T>
 /**
  * Use [`Bounded`](./number.ts.html#bounded) instead.
  *
diff --git a/node_modules/fp-ts/es6/Bounded.js b/node_modules/fp-ts/es6/Bounded.js
index 743b0ff..74c53fe 100644
--- a/node_modules/fp-ts/es6/Bounded.js
+++ b/node_modules/fp-ts/es6/Bounded.js
@@ -7,32 +7,7 @@
  *
  * @since 2.0.0
  */
-import * as O from './Ord';
-// -------------------------------------------------------------------------------------
-// utils
-// -------------------------------------------------------------------------------------
-/**
- * Clamp a value between bottom and top values.
- *
- * @category utils
- * @since 2.12.0
- */
-export var clamp = function (B) { return O.clamp(B)(B.bottom, B.top); };
-/**
- * Reverses the Ord of a bound and swaps top and bottom values.
- *
- * @category utils
- * @since 2.12.0
- */
-export var reverse = function (B) {
-    var R = O.reverse(B);
-    return {
-        equals: R.equals,
-        compare: R.compare,
-        top: B.bottom,
-        bottom: B.top
-    };
-};
+import { ordNumber } from './Ord';
 // -------------------------------------------------------------------------------------
 // deprecated
 // -------------------------------------------------------------------------------------
@@ -45,8 +20,8 @@ export var reverse = function (B) {
  * @deprecated
  */
 export var boundedNumber = {
-    equals: O.ordNumber.equals,
-    compare: O.ordNumber.compare,
+    equals: ordNumber.equals,
+    compare: ordNumber.compare,
     top: Infinity,
     bottom: -Infinity
 };
diff --git a/node_modules/fp-ts/es6/Either.d.ts b/node_modules/fp-ts/es6/Either.d.ts
index 9b3ec39..a783413 100644
--- a/node_modules/fp-ts/es6/Either.d.ts
+++ b/node_modules/fp-ts/es6/Either.d.ts
@@ -593,13 +593,6 @@ export declare const flap: <A>(a: A) => <E, B>(fab: Either<E, (a: A) => B>) => E
  * @since 2.0.0
  */
 export declare const apFirst: <E, B>(second: Either<E, B>) => <A>(first: Either<E, A>) => Either<E, A>
-/**
- * Less strict version of [`apFirst`](#apfirst)
- *
- * @category combinators
- * @since 2.12.0
- */
-export declare const apFirstW: <E2, A, B>(second: Either<E2, B>) => <E1>(first: Either<E1, A>) => Either<E1 | E2, A>
 /**
  * Combine two effectful actions, keeping only the result of the second.
  *
@@ -609,13 +602,6 @@ export declare const apFirstW: <E2, A, B>(second: Either<E2, B>) => <E1>(first:
  * @since 2.0.0
  */
 export declare const apSecond: <E, B>(second: Either<E, B>) => <A>(first: Either<E, A>) => Either<E, B>
-/**
- * Less strict version of [`apSecond`](#apsecond)
- *
- * @category combinators
- * @since 2.12.0
- */
-export declare const apSecondW: <E2, A, B>(second: Either<E2, B>) => <E1>(first: Either<E1, A>) => Either<E1 | E2, B>
 /**
  * Composes computations in sequence, using the return value of one computation to determine the next computation and
  * keeping only the result of the first.
diff --git a/node_modules/fp-ts/es6/Either.js b/node_modules/fp-ts/es6/Either.js
index 62e8d54..0cd8d3b 100644
--- a/node_modules/fp-ts/es6/Either.js
+++ b/node_modules/fp-ts/es6/Either.js
@@ -774,13 +774,6 @@ flap_(Functor);
 export var apFirst = 
 /*#__PURE__*/
 apFirst_(Apply);
-/**
- * Less strict version of [`apFirst`](#apfirst)
- *
- * @category combinators
- * @since 2.12.0
- */
-export var apFirstW = apFirst;
 /**
  * Combine two effectful actions, keeping only the result of the second.
  *
@@ -792,13 +785,6 @@ export var apFirstW = apFirst;
 export var apSecond = 
 /*#__PURE__*/
 apSecond_(Apply);
-/**
- * Less strict version of [`apSecond`](#apsecond)
- *
- * @category combinators
- * @since 2.12.0
- */
-export var apSecondW = apSecond;
 /**
  * Composes computations in sequence, using the return value of one computation to determine the next computation and
  * keeping only the result of the first.
diff --git a/node_modules/fp-ts/es6/EitherT.d.ts b/node_modules/fp-ts/es6/EitherT.d.ts
index 27eb1a9..1e9fa0b 100644
--- a/node_modules/fp-ts/es6/EitherT.d.ts
+++ b/node_modules/fp-ts/es6/EitherT.d.ts
@@ -76,111 +76,6 @@ export declare function leftF<F extends URIS2, FE>(
 ): <E, A = never>(fe: Kind2<F, FE, E>) => Kind2<F, FE, Either<E, A>>
 export declare function leftF<F extends URIS>(F: Functor1<F>): <E, A = never>(fe: Kind<F, E>) => Kind<F, Either<E, A>>
 export declare function leftF<F>(F: Functor<F>): <E, A = never>(fe: HKT<F, E>) => HKT<F, Either<E, A>>
-/**
- * @since 2.12.0
- */
-export declare function fromNullable<F extends URIS3>(
-  F: Pointed3<F>
-): <E>(e: E) => <A, S, R>(a: A) => Kind3<F, S, R, Either<E, NonNullable<A>>>
-export declare function fromNullable<F extends URIS3, R>(
-  F: Pointed3C<F, R>
-): <E>(e: E) => <A, S>(a: A) => Kind3<F, S, R, Either<E, NonNullable<A>>>
-export declare function fromNullable<F extends URIS2>(
-  F: Pointed2<F>
-): <E>(e: E) => <A, R>(a: A) => Kind2<F, R, Either<E, NonNullable<A>>>
-export declare function fromNullable<F extends URIS2, R>(
-  F: Pointed2C<F, R>
-): <E>(e: E) => <A>(a: A) => Kind2<F, R, Either<E, NonNullable<A>>>
-export declare function fromNullable<F extends URIS>(
-  F: Pointed1<F>
-): <E>(e: E) => <A>(a: A) => Kind<F, Either<E, NonNullable<A>>>
-export declare function fromNullable<F>(F: Pointed<F>): <E>(e: E) => <A>(a: A) => HKT<F, Either<E, NonNullable<A>>>
-/**
- * @since 2.12.0
- */
-export declare function fromNullableK<F extends URIS3>(
-  F: Pointed3<F>
-): <E>(
-  e: E
-) => <A extends ReadonlyArray<unknown>, B>(
-  f: (...a: A) => B | null | undefined
-) => <S, R>(...a: A) => Kind3<F, S, R, Either<E, NonNullable<B>>>
-export declare function fromNullableK<F extends URIS3, R>(
-  F: Pointed3C<F, R>
-): <E>(
-  e: E
-) => <A extends ReadonlyArray<unknown>, B>(
-  f: (...a: A) => B | null | undefined
-) => <S>(...a: A) => Kind3<F, S, R, Either<E, NonNullable<B>>>
-export declare function fromNullableK<F extends URIS2>(
-  F: Pointed2<F>
-): <E>(
-  e: E
-) => <A extends ReadonlyArray<unknown>, B>(
-  f: (...a: A) => B | null | undefined
-) => <R>(...a: A) => Kind2<F, R, Either<E, NonNullable<B>>>
-export declare function fromNullableK<F extends URIS2, R>(
-  F: Pointed2C<F, R>
-): <E>(
-  e: E
-) => <A extends ReadonlyArray<unknown>, B>(
-  f: (...a: A) => B | null | undefined
-) => (...a: A) => Kind2<F, R, Either<E, NonNullable<B>>>
-export declare function fromNullableK<F extends URIS>(
-  F: Pointed1<F>
-): <E>(
-  e: E
-) => <A extends ReadonlyArray<unknown>, B>(
-  f: (...a: A) => B | null | undefined
-) => (...a: A) => Kind<F, Either<E, NonNullable<B>>>
-export declare function fromNullableK<F>(
-  F: Pointed<F>
-): <E>(
-  e: E
-) => <A extends ReadonlyArray<unknown>, B>(
-  f: (...a: A) => B | null | undefined
-) => (...a: A) => HKT<F, Either<E, NonNullable<B>>>
-/**
- * @since 2.12.0
- */
-export declare function chainNullableK<M extends URIS3>(
-  M: Monad3<M>
-): <E>(
-  e: E
-) => <A, B>(
-  f: (a: A) => B | null | undefined
-) => <S, R>(ma: Kind3<M, S, R, Either<E, A>>) => Kind3<M, S, R, Either<E, NonNullable<B>>>
-export declare function chainNullableK<M extends URIS3, R>(
-  M: Monad3C<M, R>
-): <E>(
-  e: E
-) => <A, B>(
-  f: (a: A) => B | null | undefined
-) => <S>(ma: Kind3<M, S, R, Either<E, A>>) => Kind3<M, S, R, Either<E, NonNullable<B>>>
-export declare function chainNullableK<M extends URIS2>(
-  M: Monad2<M>
-): <E>(
-  e: E
-) => <A, B>(
-  f: (a: A) => B | null | undefined
-) => <R>(ma: Kind2<M, R, Either<E, A>>) => Kind2<M, R, Either<E, NonNullable<B>>>
-export declare function chainNullableK<M extends URIS2, T>(
-  M: Monad2C<M, T>
-): <E>(
-  e: E
-) => <A, B>(
-  f: (a: A) => B | null | undefined
-) => (ma: Kind2<M, T, Either<E, A>>) => Kind2<M, T, Either<E, NonNullable<B>>>
-export declare function chainNullableK<M extends URIS>(
-  M: Monad1<M>
-): <E>(
-  e: E
-) => <A, B>(f: (a: A) => B | null | undefined) => (ma: Kind<M, Either<E, A>>) => Kind<M, Either<E, NonNullable<B>>>
-export declare function chainNullableK<M>(
-  M: Monad<M>
-): <E>(
-  e: E
-) => <A, B>(f: (a: A) => B | null | undefined) => (ma: HKT<M, Either<E, A>>) => HKT<M, Either<E, NonNullable<B>>>
 /**
  * @since 2.10.0
  */
diff --git a/node_modules/fp-ts/es6/EitherT.js b/node_modules/fp-ts/es6/EitherT.js
index 1ee6556..925e913 100644
--- a/node_modules/fp-ts/es6/EitherT.js
+++ b/node_modules/fp-ts/es6/EitherT.js
@@ -14,24 +14,6 @@ export function rightF(F) {
 export function leftF(F) {
     return function (fe) { return F.map(fe, E.left); };
 }
-export function fromNullable(F) {
-    return function (e) { return flow(E.fromNullable(e), F.of); };
-}
-export function fromNullableK(F) {
-    var fromNullableF = fromNullable(F);
-    return function (e) {
-        var fromNullableFE = fromNullableF(e);
-        return function (f) { return flow(f, fromNullableFE); };
-    };
-}
-export function chainNullableK(M) {
-    var chainM = chain(M);
-    var fromNullableKM = fromNullableK(M);
-    return function (e) {
-        var fromNullableKMe = fromNullableKM(e);
-        return function (f) { return chainM(fromNullableKMe(f)); };
-    };
-}
 export function map(F) {
     return map_(F, E.Functor);
 }
diff --git a/node_modules/fp-ts/es6/Foldable.d.ts b/node_modules/fp-ts/es6/Foldable.d.ts
index 152429a..19fdcfe 100644
--- a/node_modules/fp-ts/es6/Foldable.d.ts
+++ b/node_modules/fp-ts/es6/Foldable.d.ts
@@ -175,17 +175,17 @@ export declare function reduceM<M, F>(
 export declare function intercalate<M, F extends URIS3>(
   M: Monoid<M>,
   F: Foldable3<F>
-): <R, E>(middle: M, fm: Kind3<F, R, E, M>) => M
+): <R, E>(sep: M, fm: Kind3<F, R, E, M>) => M
 export declare function intercalate<M, F extends URIS2>(
   M: Monoid<M>,
   F: Foldable2<F>
-): <E>(middle: M, fm: Kind2<F, E, M>) => M
+): <E>(sep: M, fm: Kind2<F, E, M>) => M
 export declare function intercalate<M, F extends URIS2, E>(
   M: Monoid<M>,
   F: Foldable2C<F, E>
-): (middle: M, fm: Kind2<F, E, M>) => M
-export declare function intercalate<M, F extends URIS>(M: Monoid<M>, F: Foldable1<F>): (middle: M, fm: Kind<F, M>) => M
-export declare function intercalate<M, F>(M: Monoid<M>, F: Foldable<F>): (middle: M, fm: HKT<F, M>) => M
+): (sep: M, fm: Kind2<F, E, M>) => M
+export declare function intercalate<M, F extends URIS>(M: Monoid<M>, F: Foldable1<F>): (sep: M, fm: Kind<F, M>) => M
+export declare function intercalate<M, F>(M: Monoid<M>, F: Foldable<F>): (sep: M, fm: HKT<F, M>) => M
 /**
  * Transforms a `Foldable` into a `toReadonlyArray`.
  *
diff --git a/node_modules/fp-ts/es6/Foldable.js b/node_modules/fp-ts/es6/Foldable.js
index e44d538..f0bac00 100644
--- a/node_modules/fp-ts/es6/Foldable.js
+++ b/node_modules/fp-ts/es6/Foldable.js
@@ -16,10 +16,10 @@ export function reduceM(M, F) {
     return function (b, f) { return function (fa) { return F.reduce(fa, M.of(b), function (mb, a) { return M.chain(mb, function (b) { return f(b, a); }); }); }; };
 }
 export function intercalate(M, F) {
-    return function (middle, fm) {
+    return function (sep, fm) {
         var go = function (_a, x) {
             var init = _a.init, acc = _a.acc;
-            return init ? { init: false, acc: x } : { init: false, acc: M.concat(M.concat(acc, middle), x) };
+            return init ? { init: false, acc: x } : { init: false, acc: M.concat(M.concat(acc, sep), x) };
         };
         return F.reduce(fm, { init: true, acc: M.empty }, go).acc;
     };
diff --git a/node_modules/fp-ts/es6/FromEither.d.ts b/node_modules/fp-ts/es6/FromEither.d.ts
index 5bf4394..64ee53f 100644
--- a/node_modules/fp-ts/es6/FromEither.d.ts
+++ b/node_modules/fp-ts/es6/FromEither.d.ts
@@ -262,38 +262,6 @@ export declare function chainEitherK<M>(
   F: FromEither<M>,
   M: Chain<M>
 ): <A, E, B>(f: (a: A) => Either<E, B>) => (ma: HKT2<M, E, A>) => HKT2<M, E, B>
-/**
- * @category combinators
- * @since 2.12.0
- */
-export declare function chainFirstEitherK<M extends URIS4>(
-  F: FromEither4<M>,
-  M: Chain4<M>
-): <A, E, B>(f: (a: A) => Either<E, B>) => <S, R>(ma: Kind4<M, S, R, E, A>) => Kind4<M, S, R, E, A>
-export declare function chainFirstEitherK<M extends URIS3>(
-  F: FromEither3<M>,
-  M: Chain3<M>
-): <A, E, B>(f: (a: A) => Either<E, B>) => <R>(ma: Kind3<M, R, E, A>) => Kind3<M, R, E, A>
-export declare function chainFirstEitherK<M extends URIS3, E>(
-  F: FromEither3C<M, E>,
-  M: Chain3C<M, E>
-): <A, B>(f: (a: A) => Either<E, B>) => <R>(ma: Kind3<M, R, E, A>) => Kind3<M, R, E, A>
-export declare function chainFirstEitherK<M extends URIS2>(
-  F: FromEither2<M>,
-  M: Chain2<M>
-): <A, E, B>(f: (a: A) => Either<E, B>) => (ma: Kind2<M, E, A>) => Kind2<M, E, A>
-export declare function chainFirstEitherK<M extends URIS2, E>(
-  F: FromEither2C<M, E>,
-  M: Chain2C<M, E>
-): <A, B>(f: (a: A) => Either<E, B>) => (ma: Kind2<M, E, A>) => Kind2<M, E, A>
-export declare function chainFirstEitherK<M extends URIS>(
-  F: FromEither1<M>,
-  M: Chain1<M>
-): <E, A, B>(f: (a: A) => Either<E, B>) => (ma: Kind<M, A>) => Kind<M, A>
-export declare function chainFirstEitherK<M>(
-  F: FromEither<M>,
-  M: Chain<M>
-): <A, E, B>(f: (a: A) => Either<E, B>) => (ma: HKT2<M, E, A>) => HKT2<M, E, A>
 /**
  * @category combinators
  * @since 2.10.0
diff --git a/node_modules/fp-ts/es6/FromEither.js b/node_modules/fp-ts/es6/FromEither.js
index daac0fc..96d363e 100644
--- a/node_modules/fp-ts/es6/FromEither.js
+++ b/node_modules/fp-ts/es6/FromEither.js
@@ -3,7 +3,6 @@
  *
  * @since 2.10.0
  */
-import { chainFirst } from './Chain';
 import { flow } from './function';
 import * as _ from './internal';
 export function fromOption(F) {
@@ -35,9 +34,6 @@ export function chainEitherK(F, M) {
     var fromEitherKF = fromEitherK(F);
     return function (f) { return function (ma) { return M.chain(ma, fromEitherKF(f)); }; };
 }
-export function chainFirstEitherK(F, M) {
-    return flow(fromEitherK(F), chainFirst(M));
-}
 export function filterOrElse(F, M) {
     return function (predicate, onFalse) { return function (ma) {
         return M.chain(ma, function (a) { return F.fromEither(predicate(a) ? _.right(a) : _.left(onFalse(a))); });
diff --git a/node_modules/fp-ts/es6/IOEither.d.ts b/node_modules/fp-ts/es6/IOEither.d.ts
index 8621fec..536715b 100644
--- a/node_modules/fp-ts/es6/IOEither.d.ts
+++ b/node_modules/fp-ts/es6/IOEither.d.ts
@@ -178,11 +178,6 @@ export declare const orElseFirst: <E, B>(onLeft: (e: E) => IOEither<E, B>) => <A
 export declare const orElseFirstW: <E1, E2, B>(
   onLeft: (e: E1) => IOEither<E2, B>
 ) => <A>(ma: IOEither<E1, A>) => IOEither<E1 | E2, A>
-/**
- * @category combinators
- * @since 2.12.0
- */
-export declare const orElseFirstIOK: <E, B>(onLeft: (e: E) => IO<B>) => <A>(ma: IOEither<E, A>) => IOEither<E, A>
 /**
  * @category combinators
  * @since 2.11.0
@@ -357,15 +352,6 @@ export declare const ApplyPar: Apply2<URI>
  * @since 2.0.0
  */
 export declare const apFirst: <E, B>(second: IOEither<E, B>) => <A>(first: IOEither<E, A>) => IOEither<E, A>
-/**
- * Less strict version of [`apFirst`](#apfirst).
- *
- * @category combinators
- * @since 2.12.0
- */
-export declare const apFirstW: <E2, A, B>(
-  second: IOEither<E2, B>
-) => <E1>(first: IOEither<E1, A>) => IOEither<E1 | E2, A>
 /**
  * Combine two effectful actions, keeping only the result of the second.
  *
@@ -375,15 +361,6 @@ export declare const apFirstW: <E2, A, B>(
  * @since 2.0.0
  */
 export declare const apSecond: <E, B>(second: IOEither<E, B>) => <A>(first: IOEither<E, A>) => IOEither<E, B>
-/**
- * Less strict version of [`apSecond`](#apsecond).
- *
- * @category combinators
- * @since 2.12.0
- */
-export declare const apSecondW: <E2, A, B>(
-  second: IOEither<E2, B>
-) => <E1>(first: IOEither<E1, A>) => IOEither<E1 | E2, B>
 /**
  * @category instances
  * @since 2.8.4
@@ -502,18 +479,6 @@ export declare const chainEitherK: <E, A, B>(f: (a: A) => E.Either<E, B>) => (ma
 export declare const chainEitherKW: <E2, A, B>(
   f: (a: A) => Either<E2, B>
 ) => <E1>(ma: IOEither<E1, A>) => IOEither<E1 | E2, B>
-/**
- * @category combinators
- * @since 2.12.0
- */
-export declare const chainFirstEitherK: <A, E, B>(f: (a: A) => E.Either<E, B>) => (ma: IOEither<E, A>) => IOEither<E, A>
-/**
- * @category combinators
- * @since 2.12.0
- */
-export declare const chainFirstEitherKW: <A, E2, B>(
-  f: (a: A) => E.Either<E2, B>
-) => <E1>(ma: IOEither<E1, A>) => IOEither<E1 | E2, A>
 /**
  * @category constructors
  * @since 2.0.0
@@ -567,16 +532,6 @@ export declare const bracket: <E, A, B>(
   use: (a: A) => IOEither<E, B>,
   release: (a: A, e: E.Either<E, B>) => IOEither<E, void>
 ) => IOEither<E, B>
-/**
- * Less strict version of [`bracket`](#bracket).
- *
- * @since 2.12.0
- */
-export declare const bracketW: <E1, A, E2, B, E3>(
-  acquire: IOEither<E1, A>,
-  use: (a: A) => IOEither<E2, B>,
-  release: (a: A, e: E.Either<E2, B>) => IOEither<E3, void>
-) => IOEither<E1 | E2 | E3, B>
 /**
  * @since 2.9.0
  */
diff --git a/node_modules/fp-ts/es6/IOEither.js b/node_modules/fp-ts/es6/IOEither.js
index ce45234..bf15cfd 100644
--- a/node_modules/fp-ts/es6/IOEither.js
+++ b/node_modules/fp-ts/es6/IOEither.js
@@ -5,7 +5,7 @@ import { compact as compact_, separate as separate_ } from './Compactable';
 import * as E from './Either';
 import * as ET from './EitherT';
 import { filter as filter_, filterMap as filterMap_, partition as partition_, partitionMap as partitionMap_ } from './Filterable';
-import { chainEitherK as chainEitherK_, chainOptionK as chainOptionK_, filterOrElse as filterOrElse_, fromEitherK as fromEitherK_, fromOption as fromOption_, fromOptionK as fromOptionK_, fromPredicate as fromPredicate_, chainFirstEitherK as chainFirstEitherK_ } from './FromEither';
+import { chainEitherK as chainEitherK_, chainOptionK as chainOptionK_, filterOrElse as filterOrElse_, fromEitherK as fromEitherK_, fromOption as fromOption_, fromOptionK as fromOptionK_, fromPredicate as fromPredicate_ } from './FromEither';
 import { chainFirstIOK as chainFirstIOK_, chainIOK as chainIOK_, fromIOK as fromIOK_ } from './FromIO';
 import { flow, identity, pipe, SK } from './function';
 import { bindTo as bindTo_, flap as flap_ } from './Functor';
@@ -177,13 +177,6 @@ ET.orElseFirst(I.Monad);
  * @since 2.11.0
  */
 export var orElseFirstW = orElseFirst;
-/**
- * @category combinators
- * @since 2.12.0
- */
-export var orElseFirstIOK = function (onLeft) {
-    return orElseFirst(fromIOK(onLeft));
-};
 /**
  * @category combinators
  * @since 2.11.0
@@ -447,13 +440,6 @@ export var ApplyPar = {
 export var apFirst = 
 /*#__PURE__*/
 apFirst_(ApplyPar);
-/**
- * Less strict version of [`apFirst`](#apfirst).
- *
- * @category combinators
- * @since 2.12.0
- */
-export var apFirstW = apFirst;
 /**
  * Combine two effectful actions, keeping only the result of the second.
  *
@@ -465,13 +451,6 @@ export var apFirstW = apFirst;
 export var apSecond = 
 /*#__PURE__*/
 apSecond_(ApplyPar);
-/**
- * Less strict version of [`apSecond`](#apsecond).
- *
- * @category combinators
- * @since 2.12.0
- */
-export var apSecondW = apSecond;
 /**
  * @category instances
  * @since 2.8.4
@@ -639,18 +618,6 @@ chainEitherK_(FromEither, Chain);
  * @since 2.6.1
  */
 export var chainEitherKW = chainEitherK;
-/**
- * @category combinators
- * @since 2.12.0
- */
-export var chainFirstEitherK = 
-/*#__PURE__*/
-chainFirstEitherK_(FromEither, Chain);
-/**
- * @category combinators
- * @since 2.12.0
- */
-export var chainFirstEitherKW = chainFirstEitherK;
 /**
  * @category constructors
  * @since 2.0.0
@@ -690,16 +657,10 @@ fromEitherK_(FromEither);
  *
  * @since 2.0.0
  */
-export var bracket = function (acquire, use, release) { return bracketW(acquire, use, release); };
-/**
- * Less strict version of [`bracket`](#bracket).
- *
- * @since 2.12.0
- */
-export var bracketW = function (acquire, use, release) {
-    return pipe(acquire, chainW(function (a) {
+export var bracket = function (acquire, use, release) {
+    return pipe(acquire, chain(function (a) {
         return pipe(use(a), I.chain(function (e) {
-            return pipe(release(a, e), chainW(function () { return I.of(e); }));
+            return pipe(release(a, e), chain(function () { return I.of(e); }));
         }));
     }));
 };
diff --git a/node_modules/fp-ts/es6/IOOption.d.ts b/node_modules/fp-ts/es6/IOOption.d.ts
deleted file mode 100644
index ef83ca5..0000000
--- a/node_modules/fp-ts/es6/IOOption.d.ts
+++ /dev/null
@@ -1,440 +0,0 @@
-/**
- * @since 2.12.0
- */
-import { Alt1 } from './Alt'
-import { Alternative1 } from './Alternative'
-import { Applicative1 } from './Applicative'
-import { Apply1 } from './Apply'
-import { Chain1 } from './Chain'
-import { Compactable1 } from './Compactable'
-import { Either } from './Either'
-import { Filterable1 } from './Filterable'
-import { FromEither1 } from './FromEither'
-import { FromIO1 } from './FromIO'
-import { Lazy } from './function'
-import { Functor1 } from './Functor'
-import { Monad1 } from './Monad'
-import { MonadIO1 } from './MonadIO'
-import { NaturalTransformation11, NaturalTransformation21 } from './NaturalTransformation'
-import * as O from './Option'
-import { Pointed1 } from './Pointed'
-import { Predicate } from './Predicate'
-import { ReadonlyNonEmptyArray } from './ReadonlyNonEmptyArray'
-import { Refinement } from './Refinement'
-import { Separated } from './Separated'
-import * as I from './IO'
-import { URI as IEURI } from './IOEither'
-import { Zero1 } from './Zero'
-import IO = I.IO
-import Option = O.Option
-/**
- * @category model
- * @since 2.12.0
- */
-export interface IOOption<A> extends IO<Option<A>> {}
-/**
- * @category constructors
- * @since 2.12.0
- */
-export declare const some: <A>(a: A) => IOOption<A>
-/**
- * @category constructors
- * @since 2.12.0
- */
-export declare const fromPredicate: {
-  <A, B extends A>(refinement: Refinement<A, B>): (a: A) => IOOption<B>
-  <A>(predicate: Predicate<A>): <B extends A>(b: B) => IOOption<B>
-  <A>(predicate: Predicate<A>): (a: A) => IOOption<A>
-}
-/**
- * @category natural transformations
- * @since 2.12.0
- */
-export declare const fromOption: NaturalTransformation11<O.URI, URI>
-/**
- * @category natural transformations
- * @since 2.12.0
- */
-export declare const fromEither: FromEither1<URI>['fromEither']
-/**
- * @category natural transformations
- * @since 2.12.0
- */
-export declare const fromIO: FromIO1<URI>['fromIO']
-/**
- * @category natural transformations
- * @since 2.12.0
- */
-export declare const fromIOEither: NaturalTransformation21<IEURI, URI>
-/**
- * @category destructors
- * @since 2.12.0
- */
-export declare const match: <B, A>(onNone: () => B, onSome: (a: A) => B) => (ma: IOOption<A>) => IO<B>
-/**
- * Less strict version of [`match`](#match).
- *
- * @category destructors
- * @since 2.12.0
- */
-export declare const matchW: <B, A, C>(onNone: () => B, onSome: (a: A) => C) => (ma: IOOption<A>) => IO<B | C>
-/**
- * @category destructors
- * @since 2.12.0
- */
-export declare const matchE: <B, A>(onNone: () => IO<B>, onSome: (a: A) => IO<B>) => (ma: IOOption<A>) => IO<B>
-/**
- * Alias of [`matchE`](#matche).
- *
- * @category destructors
- * @since 2.12.0
- */
-export declare const fold: <B, A>(onNone: () => I.IO<B>, onSome: (a: A) => I.IO<B>) => (ma: IOOption<A>) => I.IO<B>
-/**
- * Less strict version of [`matchE`](#matche).
- *
- * @category destructors
- * @since 2.12.0
- */
-export declare const matchEW: <B, C, A>(onNone: () => IO<B>, onSome: (a: A) => IO<C>) => (ma: IOOption<A>) => IO<B | C>
-/**
- * @category destructors
- * @since 2.12.0
- */
-export declare const getOrElse: <A>(onNone: Lazy<IO<A>>) => (fa: IOOption<A>) => IO<A>
-/**
- * Less strict version of [`getOrElse`](#getorelse).
- *
- * @category destructors
- * @since 2.12.0
- */
-export declare const getOrElseW: <B>(onNone: Lazy<IO<B>>) => <A>(ma: IOOption<A>) => IO<A | B>
-/**
- * @category destructors
- * @since 2.12.0
- */
-export declare const toUndefined: <A>(ma: IOOption<A>) => IO<A | undefined>
-/**
- * @category destructors
- * @since 2.12.0
- */
-export declare const toNullable: <A>(ma: IOOption<A>) => IO<A | null>
-/**
- * @category interop
- * @since 2.12.0
- */
-export declare const fromNullable: <A>(a: A) => IOOption<NonNullable<A>>
-/**
- * @category interop
- * @since 2.12.0
- */
-export declare const fromNullableK: <A extends ReadonlyArray<unknown>, B>(
-  f: (...a: A) => B | null | undefined
-) => (...a: A) => IOOption<NonNullable<B>>
-/**
- * @category interop
- * @since 2.12.0
- */
-export declare const chainNullableK: <A, B>(
-  f: (a: A) => B | null | undefined
-) => (ma: IOOption<A>) => IOOption<NonNullable<B>>
-/**
- * @category combinators
- * @since 2.12.0
- */
-export declare const fromOptionK: <A extends ReadonlyArray<unknown>, B>(
-  f: (...a: A) => Option<B>
-) => (...a: A) => IOOption<B>
-/**
- * @category combinators
- * @since 2.12.0
- */
-export declare const chainOptionK: <A, B>(f: (a: A) => Option<B>) => (ma: IOOption<A>) => IOOption<B>
-/**
- * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types
- * use the type constructor `F` to represent some computational context.
- *
- * @category Functor
- * @since 2.12.0
- */
-export declare const map: <A, B>(f: (a: A) => B) => (fa: IOOption<A>) => IOOption<B>
-/**
- * @category Apply
- * @since 2.12.0
- */
-export declare const ap: <A>(fa: IOOption<A>) => <B>(fab: IOOption<(a: A) => B>) => IOOption<B>
-/**
- * @category Pointed
- * @since 2.12.0
- */
-export declare const of: Pointed1<URI>['of']
-/**
- * @category Monad
- * @since 2.12.0
- */
-export declare const chain: <A, B>(f: (a: A) => IOOption<B>) => (ma: IOOption<A>) => IOOption<B>
-/**
- * Derivable from `Chain`.
- *
- * @category combinators
- * @since 2.12.0
- */
-export declare const flatten: <A>(mma: IOOption<IOOption<A>>) => IOOption<A>
-/**
- * @category Alt
- * @since 2.12.0
- */
-export declare const alt: <A>(second: Lazy<IOOption<A>>) => (first: IOOption<A>) => IOOption<A>
-/**
- * Less strict version of [`alt`](#alt).
- *
- * @category Alt
- * @since 2.12.0
- */
-export declare const altW: <B>(second: Lazy<IOOption<B>>) => <A>(first: IOOption<A>) => IOOption<A | B>
-/**
- * @category Zero
- * @since 2.12.0
- */
-export declare const zero: Zero1<URI>['zero']
-/**
- * @category constructors
- * @since 2.12.0
- */
-export declare const none: IOOption<never>
-/**
- * @category Compactable
- * @since 2.12.0
- */
-export declare const compact: Compactable1<URI>['compact']
-/**
- * @category Compactable
- * @since 2.12.0
- */
-export declare const separate: Compactable1<URI>['separate']
-/**
- * @category Filterable
- * @since 2.12.0
- */
-export declare const filter: {
-  <A, B extends A>(refinement: Refinement<A, B>): (fb: IOOption<A>) => IOOption<B>
-  <A>(predicate: Predicate<A>): <B extends A>(fb: IOOption<B>) => IOOption<B>
-  <A>(predicate: Predicate<A>): (fa: IOOption<A>) => IOOption<A>
-}
-/**
- * @category Filterable
- * @since 2.12.0
- */
-export declare const filterMap: <A, B>(f: (a: A) => Option<B>) => (fga: IOOption<A>) => IOOption<B>
-/**
- * @category Filterable
- * @since 2.12.0
- */
-export declare const partition: {
-  <A, B extends A>(refinement: Refinement<A, B>): (fb: IOOption<A>) => Separated<IOOption<A>, IOOption<B>>
-  <A>(predicate: Predicate<A>): <B extends A>(fb: IOOption<B>) => Separated<IOOption<B>, IOOption<B>>
-  <A>(predicate: Predicate<A>): (fa: IOOption<A>) => Separated<IOOption<A>, IOOption<A>>
-}
-/**
- * @category Filterable
- * @since 2.12.0
- */
-export declare const partitionMap: <A, B, C>(
-  f: (a: A) => Either<B, C>
-) => (fa: IOOption<A>) => Separated<IOOption<B>, IOOption<C>>
-/**
- * @category instances
- * @since 2.12.0
- */
-declare const URI = 'IOOption'
-/**
- * @category instances
- * @since 2.12.0
- */
-export declare type URI = typeof URI
-declare module './HKT' {
-  interface URItoKind<A> {
-    readonly [URI]: IOOption<A>
-  }
-}
-/**
- * @category instances
- * @since 2.12.0
- */
-export declare const Functor: Functor1<URI>
-/**
- * Derivable from `Functor`.
- *
- * @category combinators
- * @since 2.12.0
- */
-export declare const flap: <A>(a: A) => <B>(fab: IOOption<(a: A) => B>) => IOOption<B>
-/**
- * @category instances
- * @since 2.12.0
- */
-export declare const Pointed: Pointed1<URI>
-/**
- * @category instances
- * @since 2.12.0
- */
-export declare const Apply: Apply1<URI>
-/**
- * Combine two effectful actions, keeping only the result of the first.
- *
- * Derivable from `Apply`.
- *
- * @category combinators
- * @since 2.12.0
- */
-export declare const apFirst: <B>(second: IOOption<B>) => <A>(first: IOOption<A>) => IOOption<A>
-/**
- * Combine two effectful actions, keeping only the result of the second.
- *
- * Derivable from `Apply`.
- *
- * @category combinators
- * @since 2.12.0
- */
-export declare const apSecond: <B>(second: IOOption<B>) => <A>(first: IOOption<A>) => IOOption<B>
-/**
- * @category instances
- * @since 2.12.0
- */
-export declare const Applicative: Applicative1<URI>
-/**
- * @category instances
- * @since 2.12.0
- */
-export declare const Chain: Chain1<URI>
-/**
- * Composes computations in sequence, using the return value of one computation to determine the next computation and
- * keeping only the result of the first.
- *
- * Derivable from `Chain`.
- *
- * @category combinators
- * @since 2.12.0
- */
-export declare const chainFirst: <A, B>(f: (a: A) => IOOption<B>) => (first: IOOption<A>) => IOOption<A>
-/**
- * @category instances
- * @since 2.12.0
- */
-export declare const Alt: Alt1<URI>
-/**
- * @category instances
- * @since 2.12.0
- */
-export declare const Zero: Zero1<URI>
-/**
- * @category constructors
- * @since 2.12.0
- */
-export declare const guard: (b: boolean) => IOOption<void>
-/**
- * @category instances
- * @since 2.12.0
- */
-export declare const Alternative: Alternative1<URI>
-/**
- * @category instances
- * @since 2.12.0
- */
-export declare const Monad: Monad1<URI>
-/**
- * @category instances
- * @since 2.12.0
- */
-export declare const MonadIO: MonadIO1<URI>
-/**
- * @category instances
- * @since 2.12.0
- */
-export declare const Compactable: Compactable1<URI>
-/**
- * @category instances
- * @since 2.12.0
- */
-export declare const Filterable: Filterable1<URI>
-/**
- * @category instances
- * @since 2.12.0
- */
-export declare const FromIO: FromIO1<URI>
-/**
- * @category combinators
- * @since 2.12.0
- */
-export declare const fromIOK: <A extends readonly unknown[], B>(f: (...a: A) => I.IO<B>) => (...a: A) => IOOption<B>
-/**
- * @category combinators
- * @since 2.12.0
- */
-export declare const chainIOK: <A, B>(f: (a: A) => I.IO<B>) => (first: IOOption<A>) => IOOption<B>
-/**
- * @category combinators
- * @since 2.12.0
- */
-export declare const chainFirstIOK: <A, B>(f: (a: A) => I.IO<B>) => (first: IOOption<A>) => IOOption<A>
-/**
- * @category instances
- * @since 2.12.0
- */
-export declare const FromEither: FromEither1<URI>
-/**
- * @category combinators
- * @since 2.12.0
- */
-export declare const fromEitherK: <E, A extends readonly unknown[], B>(
-  f: (...a: A) => Either<E, B>
-) => (...a: A) => IOOption<B>
-/**
- * @category combinators
- * @since 2.12.0
- */
-export declare const chainEitherK: <E, A, B>(f: (a: A) => Either<E, B>) => (ma: IOOption<A>) => IOOption<B>
-/**
- * @category combinators
- * @since 2.12.0
- */
-export declare const chainFirstEitherK: <E, A, B>(f: (a: A) => Either<E, B>) => (ma: IOOption<A>) => IOOption<A>
-/**
- * @since 2.12.0
- */
-export declare const Do: IOOption<{}>
-/**
- * @since 2.12.0
- */
-export declare const bindTo: <N extends string>(name: N) => <A>(fa: IOOption<A>) => IOOption<{ readonly [K in N]: A }>
-/**
- * @since 2.12.0
- */
-export declare const bind: <N extends string, A, B>(
-  name: Exclude<N, keyof A>,
-  f: (a: A) => IOOption<B>
-) => (ma: IOOption<A>) => IOOption<{ readonly [K in N | keyof A]: K extends keyof A ? A[K] : B }>
-/**
- * @since 2.12.0
- */
-export declare const apS: <N extends string, A, B>(
-  name: Exclude<N, keyof A>,
-  fb: IOOption<B>
-) => (fa: IOOption<A>) => IOOption<{ readonly [K in N | keyof A]: K extends keyof A ? A[K] : B }>
-/**
- * @since 2.12.0
- */
-export declare const ApT: IOOption<readonly []>
-/**
- * @since 2.12.0
- */
-export declare const traverseReadonlyNonEmptyArrayWithIndex: <A, B>(
-  f: (index: number, a: A) => IOOption<B>
-) => (as: ReadonlyNonEmptyArray<A>) => IOOption<ReadonlyNonEmptyArray<B>>
-/**
- * @since 2.12.0
- */
-export declare const traverseReadonlyArrayWithIndex: <A, B>(
-  f: (index: number, a: A) => IOOption<B>
-) => (as: readonly A[]) => IOOption<readonly B[]>
-export {}
diff --git a/node_modules/fp-ts/es6/IOOption.js b/node_modules/fp-ts/es6/IOOption.js
deleted file mode 100644
index 0500fde..0000000
--- a/node_modules/fp-ts/es6/IOOption.js
+++ /dev/null
@@ -1,581 +0,0 @@
-import { apFirst as apFirst_, apS as apS_, apSecond as apSecond_ } from './Apply';
-import { bind as bind_, chainFirst as chainFirst_ } from './Chain';
-import { compact as compact_, separate as separate_ } from './Compactable';
-import { filter as filter_, filterMap as filterMap_, partition as partition_, partitionMap as partitionMap_ } from './Filterable';
-import { chainEitherK as chainEitherK_, chainFirstEitherK as chainFirstEitherK_, fromEitherK as fromEitherK_ } from './FromEither';
-import { chainFirstIOK as chainFirstIOK_, chainIOK as chainIOK_, fromIOK as fromIOK_ } from './FromIO';
-import { flow, identity, pipe, SK } from './function';
-import { bindTo as bindTo_, flap as flap_ } from './Functor';
-import * as _ from './internal';
-import * as O from './Option';
-import * as OT from './OptionT';
-import * as I from './IO';
-import { guard as guard_ } from './Zero';
-// -------------------------------------------------------------------------------------
-// constructors
-// -------------------------------------------------------------------------------------
-/**
- * @category constructors
- * @since 2.12.0
- */
-export var some = 
-/*#__PURE__*/
-OT.some(I.Pointed);
-/**
- * @category constructors
- * @since 2.12.0
- */
-export var fromPredicate = 
-/*#__PURE__*/
-OT.fromPredicate(I.Pointed);
-// -------------------------------------------------------------------------------------
-// natural transformations
-// -------------------------------------------------------------------------------------
-/**
- * @category natural transformations
- * @since 2.12.0
- */
-export var fromOption = I.of;
-/**
- * @category natural transformations
- * @since 2.12.0
- */
-export var fromEither = 
-/*#__PURE__*/
-OT.fromEither(I.Pointed);
-/**
- * @category natural transformations
- * @since 2.12.0
- */
-export var fromIO = 
-/*#__PURE__*/
-OT.fromF(I.Functor);
-/**
- * @category natural transformations
- * @since 2.12.0
- */
-export var fromIOEither = 
-/*#__PURE__*/
-I.map(O.fromEither);
-// -------------------------------------------------------------------------------------
-// destructors
-// -------------------------------------------------------------------------------------
-/**
- * @category destructors
- * @since 2.12.0
- */
-export var match = 
-/*#__PURE__*/
-OT.match(I.Functor);
-/**
- * Less strict version of [`match`](#match).
- *
- * @category destructors
- * @since 2.12.0
- */
-export var matchW = match;
-/**
- * @category destructors
- * @since 2.12.0
- */
-export var matchE = 
-/*#__PURE__*/
-OT.matchE(I.Chain);
-/**
- * Alias of [`matchE`](#matche).
- *
- * @category destructors
- * @since 2.12.0
- */
-export var fold = matchE;
-/**
- * Less strict version of [`matchE`](#matche).
- *
- * @category destructors
- * @since 2.12.0
- */
-export var matchEW = matchE;
-/**
- * @category destructors
- * @since 2.12.0
- */
-export var getOrElse = 
-/*#__PURE__*/
-OT.getOrElse(I.Monad);
-/**
- * Less strict version of [`getOrElse`](#getorelse).
- *
- * @category destructors
- * @since 2.12.0
- */
-export var getOrElseW = getOrElse;
-/**
- * @category destructors
- * @since 2.12.0
- */
-export var toUndefined = I.map(O.toUndefined);
-/**
- * @category destructors
- * @since 2.12.0
- */
-export var toNullable = I.map(O.toNullable);
-// -------------------------------------------------------------------------------------
-// interop
-// -------------------------------------------------------------------------------------
-/**
- * @category interop
- * @since 2.12.0
- */
-export var fromNullable = 
-/*#__PURE__*/
-OT.fromNullable(I.Pointed);
-/**
- * @category interop
- * @since 2.12.0
- */
-export var fromNullableK = 
-/*#__PURE__*/
-OT.fromNullableK(I.Pointed);
-/**
- * @category interop
- * @since 2.12.0
- */
-export var chainNullableK = 
-/*#__PURE__*/
-OT.chainNullableK(I.Monad);
-// -------------------------------------------------------------------------------------
-// combinators
-// -------------------------------------------------------------------------------------
-/**
- * @category combinators
- * @since 2.12.0
- */
-export var fromOptionK = 
-/*#__PURE__*/
-OT.fromOptionK(I.Pointed);
-/**
- * @category combinators
- * @since 2.12.0
- */
-export var chainOptionK = 
-/*#__PURE__*/
-OT.chainOptionK(I.Monad);
-// -------------------------------------------------------------------------------------
-// type class members
-// -------------------------------------------------------------------------------------
-/**
- * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types
- * use the type constructor `F` to represent some computational context.
- *
- * @category Functor
- * @since 2.12.0
- */
-export var map = 
-/*#__PURE__*/
-OT.map(I.Functor);
-/**
- * @category Apply
- * @since 2.12.0
- */
-export var ap = 
-/*#__PURE__*/
-OT.ap(I.Apply);
-/**
- * @category Pointed
- * @since 2.12.0
- */
-export var of = some;
-/**
- * @category Monad
- * @since 2.12.0
- */
-export var chain = 
-/*#__PURE__*/
-OT.chain(I.Monad);
-/**
- * Derivable from `Chain`.
- *
- * @category combinators
- * @since 2.12.0
- */
-export var flatten = 
-/*#__PURE__*/
-chain(identity);
-/**
- * @category Alt
- * @since 2.12.0
- */
-export var alt = 
-/*#__PURE__*/
-OT.alt(I.Monad);
-/**
- * Less strict version of [`alt`](#alt).
- *
- * @category Alt
- * @since 2.12.0
- */
-export var altW = alt;
-/**
- * @category Zero
- * @since 2.12.0
- */
-export var zero = 
-/*#__PURE__*/
-OT.zero(I.Pointed);
-/**
- * @category constructors
- * @since 2.12.0
- */
-export var none = 
-/*#__PURE__*/
-zero();
-/**
- * @category Compactable
- * @since 2.12.0
- */
-export var compact = 
-/*#__PURE__*/
-compact_(I.Functor, O.Compactable);
-/**
- * @category Compactable
- * @since 2.12.0
- */
-export var separate = 
-/*#__PURE__*/
-separate_(I.Functor, O.Compactable, O.Functor);
-/**
- * @category Filterable
- * @since 2.12.0
- */
-export var filter = 
-/*#__PURE__*/
-filter_(I.Functor, O.Filterable);
-/**
- * @category Filterable
- * @since 2.12.0
- */
-export var filterMap = 
-/*#__PURE__*/
-filterMap_(I.Functor, O.Filterable);
-/**
- * @category Filterable
- * @since 2.12.0
- */
-export var partition = 
-/*#__PURE__*/
-partition_(I.Functor, O.Filterable);
-/**
- * @category Filterable
- * @since 2.12.0
- */
-export var partitionMap = 
-/*#__PURE__*/
-partitionMap_(I.Functor, O.Filterable);
-// -------------------------------------------------------------------------------------
-// instances
-// -------------------------------------------------------------------------------------
-var _map = function (fa, f) { return pipe(fa, map(f)); };
-/* istanbul ignore next */
-var _ap = function (fab, fa) { return pipe(fab, ap(fa)); };
-/* istanbul ignore next */
-var _chain = function (ma, f) { return pipe(ma, chain(f)); };
-/* istanbul ignore next */
-var _alt = function (fa, that) { return pipe(fa, alt(that)); };
-/* istanbul ignore next */
-var _filter = function (fa, predicate) { return pipe(fa, filter(predicate)); };
-/* istanbul ignore next */
-var _filterMap = function (fa, f) { return pipe(fa, filterMap(f)); };
-/* istanbul ignore next */
-var _partition = function (fa, predicate) {
-    return pipe(fa, partition(predicate));
-};
-/* istanbul ignore next */
-var _partitionMap = function (fa, f) { return pipe(fa, partitionMap(f)); };
-/**
- * @category instances
- * @since 2.12.0
- */
-var URI = 'IOOption';
-/**
- * @category instances
- * @since 2.12.0
- */
-export var Functor = {
-    URI: URI,
-    map: _map
-};
-/**
- * Derivable from `Functor`.
- *
- * @category combinators
- * @since 2.12.0
- */
-export var flap = 
-/*#__PURE__*/
-flap_(Functor);
-/**
- * @category instances
- * @since 2.12.0
- */
-export var Pointed = {
-    URI: URI,
-    of: of
-};
-/**
- * @category instances
- * @since 2.12.0
- */
-export var Apply = {
-    URI: URI,
-    map: _map,
-    ap: _ap
-};
-/**
- * Combine two effectful actions, keeping only the result of the first.
- *
- * Derivable from `Apply`.
- *
- * @category combinators
- * @since 2.12.0
- */
-export var apFirst = 
-/*#__PURE__*/
-apFirst_(Apply);
-/**
- * Combine two effectful actions, keeping only the result of the second.
- *
- * Derivable from `Apply`.
- *
- * @category combinators
- * @since 2.12.0
- */
-export var apSecond = 
-/*#__PURE__*/
-apSecond_(Apply);
-/**
- * @category instances
- * @since 2.12.0
- */
-export var Applicative = {
-    URI: URI,
-    map: _map,
-    ap: _ap,
-    of: of
-};
-/**
- * @category instances
- * @since 2.12.0
- */
-export var Chain = {
-    URI: URI,
-    map: _map,
-    ap: _ap,
-    chain: _chain
-};
-/**
- * Composes computations in sequence, using the return value of one computation to determine the next computation and
- * keeping only the result of the first.
- *
- * Derivable from `Chain`.
- *
- * @category combinators
- * @since 2.12.0
- */
-export var chainFirst = 
-/*#__PURE__*/
-chainFirst_(Chain);
-/**
- * @category instances
- * @since 2.12.0
- */
-export var Alt = {
-    URI: URI,
-    map: _map,
-    alt: _alt
-};
-/**
- * @category instances
- * @since 2.12.0
- */
-export var Zero = {
-    URI: URI,
-    zero: zero
-};
-/**
- * @category constructors
- * @since 2.12.0
- */
-export var guard = 
-/*#__PURE__*/
-guard_(Zero, Pointed);
-/**
- * @category instances
- * @since 2.12.0
- */
-export var Alternative = {
-    URI: URI,
-    map: _map,
-    ap: _ap,
-    of: of,
-    alt: _alt,
-    zero: zero
-};
-/**
- * @category instances
- * @since 2.12.0
- */
-export var Monad = {
-    URI: URI,
-    map: _map,
-    ap: _ap,
-    of: of,
-    chain: _chain
-};
-/**
- * @category instances
- * @since 2.12.0
- */
-export var MonadIO = {
-    URI: URI,
-    map: _map,
-    ap: _ap,
-    of: of,
-    chain: _chain,
-    fromIO: fromIO
-};
-/**
- * @category instances
- * @since 2.12.0
- */
-export var Compactable = {
-    URI: URI,
-    compact: compact,
-    separate: separate
-};
-/**
- * @category instances
- * @since 2.12.0
- */
-export var Filterable = {
-    URI: URI,
-    map: _map,
-    compact: compact,
-    separate: separate,
-    filter: _filter,
-    filterMap: _filterMap,
-    partition: _partition,
-    partitionMap: _partitionMap
-};
-/**
- * @category instances
- * @since 2.12.0
- */
-export var FromIO = {
-    URI: URI,
-    fromIO: fromIO
-};
-/**
- * @category combinators
- * @since 2.12.0
- */
-export var fromIOK = 
-/*#__PURE__*/
-fromIOK_(FromIO);
-/**
- * @category combinators
- * @since 2.12.0
- */
-export var chainIOK = 
-/*#__PURE__*/
-chainIOK_(FromIO, Chain);
-/**
- * @category combinators
- * @since 2.12.0
- */
-export var chainFirstIOK = 
-/*#__PURE__*/
-chainFirstIOK_(FromIO, Chain);
-/**
- * @category instances
- * @since 2.12.0
- */
-export var FromEither = {
-    URI: URI,
-    fromEither: fromEither
-};
-/**
- * @category combinators
- * @since 2.12.0
- */
-export var fromEitherK = 
-/*#__PURE__*/
-fromEitherK_(FromEither);
-/**
- * @category combinators
- * @since 2.12.0
- */
-export var chainEitherK = 
-/*#__PURE__*/
-chainEitherK_(FromEither, Chain);
-/**
- * @category combinators
- * @since 2.12.0
- */
-export var chainFirstEitherK = 
-/*#__PURE__*/
-chainFirstEitherK_(FromEither, Chain);
-// -------------------------------------------------------------------------------------
-// do notation
-// -------------------------------------------------------------------------------------
-/**
- * @since 2.12.0
- */
-export var Do = 
-/*#__PURE__*/
-of(_.emptyRecord);
-/**
- * @since 2.12.0
- */
-export var bindTo = 
-/*#__PURE__*/
-bindTo_(Functor);
-/**
- * @since 2.12.0
- */
-export var bind = 
-/*#__PURE__*/
-bind_(Chain);
-// -------------------------------------------------------------------------------------
-// sequence S
-// -------------------------------------------------------------------------------------
-/**
- * @since 2.12.0
- */
-export var apS = 
-/*#__PURE__*/
-apS_(Apply);
-// -------------------------------------------------------------------------------------
-// sequence T
-// -------------------------------------------------------------------------------------
-/**
- * @since 2.12.0
- */
-export var ApT = 
-/*#__PURE__*/
-of(_.emptyReadonlyArray);
-// -------------------------------------------------------------------------------------
-// array utils
-// -------------------------------------------------------------------------------------
-/**
- * @since 2.12.0
- */
-export var traverseReadonlyNonEmptyArrayWithIndex = function (f) {
-    return flow(I.traverseReadonlyNonEmptyArrayWithIndex(f), I.map(O.traverseReadonlyNonEmptyArrayWithIndex(SK)));
-};
-/**
- * @since 2.12.0
- */
-export var traverseReadonlyArrayWithIndex = function (f) {
-    var g = traverseReadonlyNonEmptyArrayWithIndex(f);
-    return function (as) { return (_.isNonEmpty(as) ? g(as) : ApT); };
-};
diff --git a/node_modules/fp-ts/es6/NonEmptyArray.d.ts b/node_modules/fp-ts/es6/NonEmptyArray.d.ts
index 5a63574..b1ce2b0 100644
--- a/node_modules/fp-ts/es6/NonEmptyArray.d.ts
+++ b/node_modules/fp-ts/es6/NonEmptyArray.d.ts
@@ -705,18 +705,6 @@ export declare const modifyLast: <A>(f: Endomorphism<A>) => (as: NonEmptyArray<A
  * @since 2.11.0
  */
 export declare const updateLast: <A>(a: A) => (as: NonEmptyArray<A>) => NonEmptyArray<A>
-/**
- * Places an element in between members of a `NonEmptyArray`, then folds the results using the provided `Semigroup`.
- *
- * @example
- * import * as S from 'fp-ts/string'
- * import { intercalate } from 'fp-ts/NonEmptyArray'
- *
- * assert.deepStrictEqual(intercalate(S.Semigroup)('-')(['a', 'b', 'c']), 'a-b-c')
- *
- * @since 2.12.0
- */
-export declare const intercalate: <A>(S: Semigroup<A>) => (middle: A) => (as: NonEmptyArray<A>) => A
 /**
  * This is just `sort` followed by `group`.
  *
diff --git a/node_modules/fp-ts/es6/NonEmptyArray.js b/node_modules/fp-ts/es6/NonEmptyArray.js
index e71f626..287c0bb 100644
--- a/node_modules/fp-ts/es6/NonEmptyArray.js
+++ b/node_modules/fp-ts/es6/NonEmptyArray.js
@@ -997,18 +997,6 @@ export var modifyLast = function (f) { return function (as) {
  * @since 2.11.0
  */
 export var updateLast = function (a) { return modifyLast(function () { return a; }); };
-/**
- * Places an element in between members of a `NonEmptyArray`, then folds the results using the provided `Semigroup`.
- *
- * @example
- * import * as S from 'fp-ts/string'
- * import { intercalate } from 'fp-ts/NonEmptyArray'
- *
- * assert.deepStrictEqual(intercalate(S.Semigroup)('-')(['a', 'b', 'c']), 'a-b-c')
- *
- * @since 2.12.0
- */
-export var intercalate = RNEA.intercalate;
 export function groupSort(O) {
     var sortO = sort(O);
     var groupO = group(O);
diff --git a/node_modules/fp-ts/es6/Option.d.ts b/node_modules/fp-ts/es6/Option.d.ts
index 54f65e5..6ffb617 100644
--- a/node_modules/fp-ts/es6/Option.d.ts
+++ b/node_modules/fp-ts/es6/Option.d.ts
@@ -619,11 +619,6 @@ export declare const fromEitherK: <E, A extends readonly unknown[], B>(
  * @since 2.11.0
  */
 export declare const chainEitherK: <E, A, B>(f: (a: A) => Either<E, B>) => (ma: Option<A>) => Option<B>
-/**
- * @category combinators
- * @since 2.12.0
- */
-export declare const chainFirstEitherK: <E, A, B>(f: (a: A) => Either<E, B>) => (ma: Option<A>) => Option<A>
 /**
  * Constructs a new `Option` from a nullable type. If the value is `null` or `undefined`, returns `None`, otherwise
  * returns the value wrapped in a `Some`.
diff --git a/node_modules/fp-ts/es6/Option.js b/node_modules/fp-ts/es6/Option.js
index bb1531e..22b890e 100644
--- a/node_modules/fp-ts/es6/Option.js
+++ b/node_modules/fp-ts/es6/Option.js
@@ -1,7 +1,7 @@
 import { getApplicativeMonoid } from './Applicative';
 import { apFirst as apFirst_, apS as apS_, apSecond as apSecond_, getApplySemigroup as getApplySemigroup_ } from './Apply';
 import { bind as bind_, chainFirst as chainFirst_ } from './Chain';
-import { chainEitherK as chainEitherK_, fromEitherK as fromEitherK_, chainFirstEitherK as chainFirstEitherK_ } from './FromEither';
+import { chainEitherK as chainEitherK_, fromEitherK as fromEitherK_ } from './FromEither';
 import { constNull, constUndefined, flow, identity, pipe } from './function';
 import { bindTo as bindTo_, flap as flap_ } from './Functor';
 import * as _ from './internal';
@@ -738,13 +738,6 @@ fromEitherK_(FromEither);
 export var chainEitherK = 
 /*#__PURE__*/
 chainEitherK_(FromEither, Chain);
-/**
- * @category combinators
- * @since 2.12.0
- */
-export var chainFirstEitherK = 
-/*#__PURE__*/
-chainFirstEitherK_(FromEither, Chain);
 // -------------------------------------------------------------------------------------
 // interop
 // -------------------------------------------------------------------------------------
diff --git a/node_modules/fp-ts/es6/Ordering.d.ts b/node_modules/fp-ts/es6/Ordering.d.ts
index 34dc579..fdd6c30 100644
--- a/node_modules/fp-ts/es6/Ordering.d.ts
+++ b/node_modules/fp-ts/es6/Ordering.d.ts
@@ -9,17 +9,6 @@ import * as S from './Semigroup'
  * @since 2.0.0
  */
 export declare type Ordering = -1 | 0 | 1
-/**
- * Less strict version of [`match`](#match).
- *
- * @category destructors
- * @since 2.12.0
- */
-export declare const matchW: <A, B, C>(
-  onLessThan: () => A,
-  onEqual: () => B,
-  onGreaterThan: () => C
-) => (o: Ordering) => A | B | C
 /**
  * @category destructors
  * @since 2.10.0
diff --git a/node_modules/fp-ts/es6/Ordering.js b/node_modules/fp-ts/es6/Ordering.js
index 79bfe5b..cf8f59f 100644
--- a/node_modules/fp-ts/es6/Ordering.js
+++ b/node_modules/fp-ts/es6/Ordering.js
@@ -1,18 +1,13 @@
 // -------------------------------------------------------------------------------------
 // destructors
 // -------------------------------------------------------------------------------------
-/**
- * Less strict version of [`match`](#match).
- *
- * @category destructors
- * @since 2.12.0
- */
-export var matchW = function (onLessThan, onEqual, onGreaterThan) { return function (o) { return (o === -1 ? onLessThan() : o === 0 ? onEqual() : onGreaterThan()); }; };
 /**
  * @category destructors
  * @since 2.10.0
  */
-export var match = matchW;
+export var match = function (onLessThan, onEqual, onGreaterThan) { return function (o) {
+    return o === -1 ? onLessThan() : o === 0 ? onEqual() : onGreaterThan();
+}; };
 // -------------------------------------------------------------------------------------
 // combinators
 // -------------------------------------------------------------------------------------
diff --git a/node_modules/fp-ts/es6/Reader.d.ts b/node_modules/fp-ts/es6/Reader.d.ts
index 1500da7..94ce94c 100644
--- a/node_modules/fp-ts/es6/Reader.d.ts
+++ b/node_modules/fp-ts/es6/Reader.d.ts
@@ -193,13 +193,6 @@ export declare const Apply: Apply2<URI>
  * @since 2.0.0
  */
 export declare const apFirst: <E, B>(second: Reader<E, B>) => <A>(first: Reader<E, A>) => Reader<E, A>
-/**
- * Less strict version of [`apFirst`](#apfirst).
- *
- * @category combinators
- * @since 2.12.0
- */
-export declare const apFirstW: <R2, A, B>(second: Reader<R2, B>) => <R1>(first: Reader<R1, A>) => Reader<R1 & R2, A>
 /**
  * Combine two effectful actions, keeping only the result of the second.
  *
@@ -209,13 +202,6 @@ export declare const apFirstW: <R2, A, B>(second: Reader<R2, B>) => <R1>(first:
  * @since 2.0.0
  */
 export declare const apSecond: <E, B>(second: Reader<E, B>) => <A>(first: Reader<E, A>) => Reader<E, B>
-/**
- * Less strict version of [`apSecond`](#apsecond).
- *
- * @category combinators
- * @since 2.12.0
- */
-export declare const apSecondW: <R2, A, B>(second: Reader<R2, B>) => <R1>(first: Reader<R1, A>) => Reader<R1 & R2, B>
 /**
  * @category instances
  * @since 2.7.0
diff --git a/node_modules/fp-ts/es6/Reader.js b/node_modules/fp-ts/es6/Reader.js
index 075c6cd..b02c2a6 100644
--- a/node_modules/fp-ts/es6/Reader.js
+++ b/node_modules/fp-ts/es6/Reader.js
@@ -217,13 +217,6 @@ export var Apply = {
 export var apFirst = 
 /*#__PURE__*/
 apFirst_(Apply);
-/**
- * Less strict version of [`apFirst`](#apfirst).
- *
- * @category combinators
- * @since 2.12.0
- */
-export var apFirstW = apFirst;
 /**
  * Combine two effectful actions, keeping only the result of the second.
  *
@@ -235,13 +228,6 @@ export var apFirstW = apFirst;
 export var apSecond = 
 /*#__PURE__*/
 apSecond_(Apply);
-/**
- * Less strict version of [`apSecond`](#apsecond).
- *
- * @category combinators
- * @since 2.12.0
- */
-export var apSecondW = apSecond;
 /**
  * @category instances
  * @since 2.7.0
diff --git a/node_modules/fp-ts/es6/ReaderEither.d.ts b/node_modules/fp-ts/es6/ReaderEither.d.ts
index 63ff3e8..018eb5b 100644
--- a/node_modules/fp-ts/es6/ReaderEither.d.ts
+++ b/node_modules/fp-ts/es6/ReaderEither.d.ts
@@ -376,15 +376,6 @@ export declare const Apply: Apply3<URI>
 export declare const apFirst: <R, E, B>(
   second: ReaderEither<R, E, B>
 ) => <A>(first: ReaderEither<R, E, A>) => ReaderEither<R, E, A>
-/**
- * Less strict version of [`apFirst`](#apfirst)
- *
- * @category combinators
- * @since 2.12.0
- */
-export declare const apFirstW: <R2, E2, A, B>(
-  second: ReaderEither<R2, E2, B>
-) => <R1, E1>(first: ReaderEither<R1, E1, A>) => ReaderEither<R1 & R2, E1 | E2, A>
 /**
  * Combine two effectful actions, keeping only the result of the second.
  *
@@ -396,15 +387,6 @@ export declare const apFirstW: <R2, E2, A, B>(
 export declare const apSecond: <R, E, B>(
   second: ReaderEither<R, E, B>
 ) => <A>(first: ReaderEither<R, E, A>) => ReaderEither<R, E, B>
-/**
- * Less strict version of [`apSecond`](#apsecond)
- *
- * @category combinators
- * @since 2.12.0
- */
-export declare const apSecondW: <R2, E2, A, B>(
-  second: ReaderEither<R2, E2, B>
-) => <R1, E1>(first: ReaderEither<R1, E1, A>) => ReaderEither<R1 & R2, E1 | E2, B>
 /**
  * @category instances
  * @since 2.7.0
@@ -558,22 +540,6 @@ export declare const chainEitherK: <E, A, B>(
 export declare const chainEitherKW: <E2, A, B>(
   f: (a: A) => Either<E2, B>
 ) => <R, E1>(ma: ReaderEither<R, E1, A>) => ReaderEither<R, E1 | E2, B>
-/**
- * @category combinators
- * @since 2.12.0
- */
-export declare const chainFirstEitherK: <A, E, B>(
-  f: (a: A) => E.Either<E, B>
-) => <R>(ma: ReaderEither<R, E, A>) => ReaderEither<R, E, A>
-/**
- * Less strict version of [`chainFirstEitherK`](#chainfirsteitherk).
- *
- * @category combinators
- * @since 2.12.0
- */
-export declare const chainFirstEitherKW: <A, E2, B>(
-  f: (a: A) => Either<E2, B>
-) => <R, E1>(ma: ReaderEither<R, E1, A>) => ReaderEither<R, E1 | E2, A>
 /**
  * @category constructors
  * @since 2.0.0
diff --git a/node_modules/fp-ts/es6/ReaderEither.js b/node_modules/fp-ts/es6/ReaderEither.js
index e44d02d..c6dd76a 100644
--- a/node_modules/fp-ts/es6/ReaderEither.js
+++ b/node_modules/fp-ts/es6/ReaderEither.js
@@ -5,7 +5,7 @@ import { compact as compact_, separate as separate_ } from './Compactable';
 import * as E from './Either';
 import * as ET from './EitherT';
 import { filter as filter_, filterMap as filterMap_, partition as partition_, partitionMap as partitionMap_ } from './Filterable';
-import { chainEitherK as chainEitherK_, chainOptionK as chainOptionK_, filterOrElse as filterOrElse_, fromEitherK as fromEitherK_, fromOption as fromOption_, fromOptionK as fromOptionK_, fromPredicate as fromPredicate_, chainFirstEitherK as chainFirstEitherK_ } from './FromEither';
+import { chainEitherK as chainEitherK_, chainOptionK as chainOptionK_, filterOrElse as filterOrElse_, fromEitherK as fromEitherK_, fromOption as fromOption_, fromOptionK as fromOptionK_, fromPredicate as fromPredicate_ } from './FromEither';
 import { ask as ask_, asks as asks_, chainFirstReaderK as chainFirstReaderK_, chainReaderK as chainReaderK_, fromReaderK as fromReaderK_ } from './FromReader';
 import { flow, identity, pipe, SK } from './function';
 import { bindTo as bindTo_, flap as flap_ } from './Functor';
@@ -426,13 +426,6 @@ export var Apply = {
 export var apFirst = 
 /*#__PURE__*/
 apFirst_(Apply);
-/**
- * Less strict version of [`apFirst`](#apfirst)
- *
- * @category combinators
- * @since 2.12.0
- */
-export var apFirstW = apFirst;
 /**
  * Combine two effectful actions, keeping only the result of the second.
  *
@@ -444,13 +437,6 @@ export var apFirstW = apFirst;
 export var apSecond = 
 /*#__PURE__*/
 apSecond_(Apply);
-/**
- * Less strict version of [`apSecond`](#apsecond)
- *
- * @category combinators
- * @since 2.12.0
- */
-export var apSecondW = apSecond;
 /**
  * @category instances
  * @since 2.7.0
@@ -637,20 +623,6 @@ chainEitherK_(FromEither, Chain);
  * @since 2.6.1
  */
 export var chainEitherKW = chainEitherK;
-/**
- * @category combinators
- * @since 2.12.0
- */
-export var chainFirstEitherK = 
-/*#__PURE__*/
-chainFirstEitherK_(FromEither, Chain);
-/**
- * Less strict version of [`chainFirstEitherK`](#chainfirsteitherk).
- *
- * @category combinators
- * @since 2.12.0
- */
-export var chainFirstEitherKW = chainFirstEitherK;
 /**
  * @category constructors
  * @since 2.0.0
diff --git a/node_modules/fp-ts/es6/ReaderTaskEither.d.ts b/node_modules/fp-ts/es6/ReaderTaskEither.d.ts
index 7683671..aadce0b 100644
--- a/node_modules/fp-ts/es6/ReaderTaskEither.d.ts
+++ b/node_modules/fp-ts/es6/ReaderTaskEither.d.ts
@@ -208,29 +208,6 @@ export declare const getOrElseW: <R2, E, B>(
  * @since 2.10.0
  */
 export declare const toUnion: <R, E, A>(fa: ReaderTaskEither<R, E, A>) => ReaderTask<R, E | A>
-/**
- * @category interop
- * @since 2.12.0
- */
-export declare const fromNullable: <E>(e: E) => <R, A>(a: A) => ReaderTaskEither<R, E, NonNullable<A>>
-/**
- * @category interop
- * @since 2.12.0
- */
-export declare const fromNullableK: <E>(
-  e: E
-) => <A extends ReadonlyArray<unknown>, B>(
-  f: (...a: A) => B | null | undefined
-) => <R>(...a: A) => ReaderTaskEither<R, E, NonNullable<B>>
-/**
- * @category interop
- * @since 2.12.0
- */
-export declare const chainNullableK: <E>(
-  e: E
-) => <A, B>(
-  f: (a: A) => B | null | undefined
-) => <R>(ma: ReaderTaskEither<R, E, A>) => ReaderTaskEither<R, E, NonNullable<B>>
 /**
  * Changes the value of the local context during the execution of the action `ma` (similar to `Contravariant`'s
  * `contramap`).
@@ -580,15 +557,6 @@ export declare const ApplyPar: Apply3<URI>
 export declare const apFirst: <R, E, B>(
   second: ReaderTaskEither<R, E, B>
 ) => <A>(first: ReaderTaskEither<R, E, A>) => ReaderTaskEither<R, E, A>
-/**
- * Less strict version of [`apFirst`](#apfirst).
- *
- * @category combinators
- * @since 2.12.0
- */
-export declare const apFirstW: <R2, E2, A, B>(
-  second: ReaderTaskEither<R2, E2, B>
-) => <R1, E1>(first: ReaderTaskEither<R1, E1, A>) => ReaderTaskEither<R1 & R2, E1 | E2, A>
 /**
  * Combine two effectful actions, keeping only the result of the second.
  *
@@ -600,15 +568,6 @@ export declare const apFirstW: <R2, E2, A, B>(
 export declare const apSecond: <R, E, B>(
   second: ReaderTaskEither<R, E, B>
 ) => <A>(first: ReaderTaskEither<R, E, A>) => ReaderTaskEither<R, E, B>
-/**
- * Less strict version of [`apSecond`](#apsecond).
- *
- * @category combinators
- * @since 2.12.0
- */
-export declare const apSecondW: <R2, E2, A, B>(
-  second: ReaderTaskEither<R2, E2, B>
-) => <R1, E1>(first: ReaderTaskEither<R1, E1, A>) => ReaderTaskEither<R1 & R2, E1 | E2, B>
 /**
  * @category instances
  * @since 2.7.0
@@ -823,22 +782,6 @@ export declare const chainEitherK: <E, A, B>(
 export declare const chainEitherKW: <E2, A, B>(
   f: (a: A) => Either<E2, B>
 ) => <R, E1>(ma: ReaderTaskEither<R, E1, A>) => ReaderTaskEither<R, E1 | E2, B>
-/**
- * @category combinators
- * @since 2.12.0
- */
-export declare const chainFirstEitherK: <A, E, B>(
-  f: (a: A) => E.Either<E, B>
-) => <R>(ma: ReaderTaskEither<R, E, A>) => ReaderTaskEither<R, E, A>
-/**
- * Less strict version of [`chainFirstEitherK`](#chainfirsteitherk).
- *
- * @category combinators
- * @since 2.12.0
- */
-export declare const chainFirstEitherKW: <A, E2, B>(
-  f: (a: A) => Either<E2, B>
-) => <R, E1>(ma: ReaderTaskEither<R, E1, A>) => ReaderTaskEither<R, E1 | E2, A>
 /**
  * @category constructors
  * @since 2.0.0
@@ -946,20 +889,10 @@ export declare const chainFirstTaskK: <A, B>(
  * @since 2.0.4
  */
 export declare function bracket<R, E, A, B>(
-  acquire: ReaderTaskEither<R, E, A>,
+  aquire: ReaderTaskEither<R, E, A>,
   use: (a: A) => ReaderTaskEither<R, E, B>,
   release: (a: A, e: Either<E, B>) => ReaderTaskEither<R, E, void>
 ): ReaderTaskEither<R, E, B>
-/**
- * Less strict version of [`bracket`](#bracket).
- *
- * @since 2.12.0
- */
-export declare function bracketW<R1, E1, A, R2, E2, B, R3, E3>(
-  acquire: ReaderTaskEither<R1, E1, A>,
-  use: (a: A) => ReaderTaskEither<R2, E2, B>,
-  release: (a: A, e: Either<E2, B>) => ReaderTaskEither<R3, E3, void>
-): ReaderTaskEither<R1 & R2 & R3, E1 | E2 | E3, B>
 /**
  * @since 2.9.0
  */
diff --git a/node_modules/fp-ts/es6/ReaderTaskEither.js b/node_modules/fp-ts/es6/ReaderTaskEither.js
index 84921c1..420283a 100644
--- a/node_modules/fp-ts/es6/ReaderTaskEither.js
+++ b/node_modules/fp-ts/es6/ReaderTaskEither.js
@@ -5,7 +5,7 @@ import { compact as compact_, separate as separate_ } from './Compactable';
 import * as E from './Either';
 import * as ET from './EitherT';
 import { filter as filter_, filterMap as filterMap_, partition as partition_, partitionMap as partitionMap_ } from './Filterable';
-import { chainEitherK as chainEitherK_, chainOptionK as chainOptionK_, filterOrElse as filterOrElse_, fromEitherK as fromEitherK_, fromOption as fromOption_, fromOptionK as fromOptionK_, fromPredicate as fromPredicate_, chainFirstEitherK as chainFirstEitherK_ } from './FromEither';
+import { chainEitherK as chainEitherK_, chainOptionK as chainOptionK_, filterOrElse as filterOrElse_, fromEitherK as fromEitherK_, fromOption as fromOption_, fromOptionK as fromOptionK_, fromPredicate as fromPredicate_ } from './FromEither';
 import { chainFirstIOK as chainFirstIOK_, chainIOK as chainIOK_, fromIOK as fromIOK_ } from './FromIO';
 import { ask as ask_, asks as asks_, chainFirstReaderK as chainFirstReaderK_, chainReaderK as chainReaderK_, fromReaderK as fromReaderK_ } from './FromReader';
 import { chainFirstTaskK as chainFirstTaskK_, chainTaskK as chainTaskK_, fromTaskK as fromTaskK_ } from './FromTask';
@@ -200,27 +200,6 @@ export var getOrElseW = getOrElse;
 export var toUnion = 
 /*#__PURE__*/
 ET.toUnion(RT.Functor);
-/**
- * @category interop
- * @since 2.12.0
- */
-export var fromNullable = 
-/*#__PURE__*/
-ET.fromNullable(RT.Pointed);
-/**
- * @category interop
- * @since 2.12.0
- */
-export var fromNullableK = 
-/*#__PURE__*/
-ET.fromNullableK(RT.Pointed);
-/**
- * @category interop
- * @since 2.12.0
- */
-export var chainNullableK = 
-/*#__PURE__*/
-ET.chainNullableK(RT.Monad);
 // -------------------------------------------------------------------------------------
 // combinators
 // -------------------------------------------------------------------------------------
@@ -603,13 +582,6 @@ export var ApplyPar = {
 export var apFirst = 
 /*#__PURE__*/
 apFirst_(ApplyPar);
-/**
- * Less strict version of [`apFirst`](#apfirst).
- *
- * @category combinators
- * @since 2.12.0
- */
-export var apFirstW = apFirst;
 /**
  * Combine two effectful actions, keeping only the result of the second.
  *
@@ -621,13 +593,6 @@ export var apFirstW = apFirst;
 export var apSecond = 
 /*#__PURE__*/
 apSecond_(ApplyPar);
-/**
- * Less strict version of [`apSecond`](#apsecond).
- *
- * @category combinators
- * @since 2.12.0
- */
-export var apSecondW = apSecond;
 /**
  * @category instances
  * @since 2.7.0
@@ -897,20 +862,6 @@ chainEitherK_(FromEither, Chain);
  * @since 2.6.1
  */
 export var chainEitherKW = chainEitherK;
-/**
- * @category combinators
- * @since 2.12.0
- */
-export var chainFirstEitherK = 
-/*#__PURE__*/
-chainFirstEitherK_(FromEither, Chain);
-/**
- * Less strict version of [`chainFirstEitherK`](#chainfirsteitherk).
- *
- * @category combinators
- * @since 2.12.0
- */
-export var chainFirstEitherKW = chainFirstEitherK;
 /**
  * @category constructors
  * @since 2.0.0
@@ -1009,17 +960,9 @@ chainFirstTaskK_(FromTask, Chain);
  *
  * @since 2.0.4
  */
-export function bracket(acquire, use, release) {
-    return bracketW(acquire, use, release);
-}
-/**
- * Less strict version of [`bracket`](#bracket).
- *
- * @since 2.12.0
- */
-export function bracketW(acquire, use, release) {
+export function bracket(aquire, use, release) {
     return function (r) {
-        return TE.bracketW(acquire(r), function (a) { return use(a)(r); }, function (a, e) { return release(a, e)(r); });
+        return TE.bracket(aquire(r), function (a) { return use(a)(r); }, function (a, e) { return release(a, e)(r); });
     };
 }
 // -------------------------------------------------------------------------------------
diff --git a/node_modules/fp-ts/es6/ReadonlyArray.d.ts b/node_modules/fp-ts/es6/ReadonlyArray.d.ts
index 6846a51..a339d8e 100644
--- a/node_modules/fp-ts/es6/ReadonlyArray.d.ts
+++ b/node_modules/fp-ts/es6/ReadonlyArray.d.ts
@@ -1548,10 +1548,7 @@ export declare const empty: ReadonlyArray<never>
  *
  * @since 2.9.0
  */
-export declare function every<A, B extends A>(
-  refinement: Refinement<A, B>
-): Refinement<ReadonlyArray<A>, ReadonlyArray<B>>
-export declare function every<A>(predicate: Predicate<A>): Predicate<ReadonlyArray<A>>
+export declare const every: <A>(predicate: Predicate<A>) => (as: readonly A[]) => boolean
 /**
  * Check if a predicate holds true for any array member.
  *
@@ -1573,18 +1570,6 @@ export declare const some: <A>(predicate: Predicate<A>) => (as: readonly A[]) =>
  * @since 2.11.0
  */
 export declare const exists: <A>(predicate: Predicate<A>) => (as: readonly A[]) => as is RNEA.ReadonlyNonEmptyArray<A>
-/**
- * Places an element in between members of a `ReadonlyArray`, then folds the results using the provided `Monoid`.
- *
- * @example
- * import * as S from 'fp-ts/string'
- * import { intercalate } from 'fp-ts/Array'
- *
- * assert.deepStrictEqual(intercalate(S.Monoid)('-')(['a', 'b', 'c']), 'a-b-c')
- *
- * @since 2.12.0
- */
-export declare const intercalate: <A>(M: Monoid<A>) => (middle: A) => (as: readonly A[]) => A
 /**
  * @since 2.9.0
  */
diff --git a/node_modules/fp-ts/es6/ReadonlyArray.js b/node_modules/fp-ts/es6/ReadonlyArray.js
index 0df7c81..c8ab5c9 100644
--- a/node_modules/fp-ts/es6/ReadonlyArray.js
+++ b/node_modules/fp-ts/es6/ReadonlyArray.js
@@ -1893,9 +1893,21 @@ export var fromArray = function (as) { return (isEmpty(as) ? empty : as.slice())
  * @since 2.5.0
  */
 export var empty = RNEA.empty;
-export function every(predicate) {
-    return function (as) { return as.every(predicate); };
-}
+/**
+ * Check if a predicate holds true for every array member.
+ *
+ * @example
+ * import { every } from 'fp-ts/ReadonlyArray'
+ * import { pipe } from 'fp-ts/function'
+ *
+ * const isPositive = (n: number): boolean => n > 0
+ *
+ * assert.deepStrictEqual(pipe([1, 2, 3], every(isPositive)), true)
+ * assert.deepStrictEqual(pipe([1, 2, -3], every(isPositive)), false)
+ *
+ * @since 2.9.0
+ */
+export var every = function (predicate) { return function (as) { return as.every(predicate); }; };
 /**
  * Check if a predicate holds true for any array member.
  *
@@ -1919,21 +1931,6 @@ export var some = function (predicate) { return function (as) {
  * @since 2.11.0
  */
 export var exists = some;
-/**
- * Places an element in between members of a `ReadonlyArray`, then folds the results using the provided `Monoid`.
- *
- * @example
- * import * as S from 'fp-ts/string'
- * import { intercalate } from 'fp-ts/Array'
- *
- * assert.deepStrictEqual(intercalate(S.Monoid)('-')(['a', 'b', 'c']), 'a-b-c')
- *
- * @since 2.12.0
- */
-export var intercalate = function (M) {
-    var intercalateM = RNEA.intercalate(M);
-    return function (middle) { return match(function () { return M.empty; }, intercalateM(middle)); };
-};
 // -------------------------------------------------------------------------------------
 // do notation
 // -------------------------------------------------------------------------------------
diff --git a/node_modules/fp-ts/es6/ReadonlyNonEmptyArray.d.ts b/node_modules/fp-ts/es6/ReadonlyNonEmptyArray.d.ts
index 31403de..bcf837e 100644
--- a/node_modules/fp-ts/es6/ReadonlyNonEmptyArray.d.ts
+++ b/node_modules/fp-ts/es6/ReadonlyNonEmptyArray.d.ts
@@ -768,18 +768,6 @@ export declare const modifyLast: <A>(f: Endomorphism<A>) => (as: ReadonlyNonEmpt
  * @since 2.11.0
  */
 export declare const updateLast: <A>(a: A) => (as: ReadonlyNonEmptyArray<A>) => ReadonlyNonEmptyArray<A>
-/**
- * Places an element in between members of a `ReadonlyNonEmptyArray`, then folds the results using the provided `Semigroup`.
- *
- * @example
- * import * as S from 'fp-ts/string'
- * import { intercalate } from 'fp-ts/ReadonlyNonEmptyArray'
- *
- * assert.deepStrictEqual(intercalate(S.Semigroup)('-')(['a', 'b', 'c']), 'a-b-c')
- *
- * @since 2.12.0
- */
-export declare const intercalate: <A>(S: Se.Semigroup<A>) => (middle: A) => (as: ReadonlyNonEmptyArray<A>) => A
 /**
  * This is just `sort` followed by `group`.
  *
diff --git a/node_modules/fp-ts/es6/ReadonlyNonEmptyArray.js b/node_modules/fp-ts/es6/ReadonlyNonEmptyArray.js
index 0dc3903..ac91342 100644
--- a/node_modules/fp-ts/es6/ReadonlyNonEmptyArray.js
+++ b/node_modules/fp-ts/es6/ReadonlyNonEmptyArray.js
@@ -6,7 +6,7 @@ var __spreadArray = (this && this.__spreadArray) || function (to, from) {
 import { apFirst as apFirst_, apS as apS_, apSecond as apSecond_ } from './Apply';
 import { bind as bind_, chainFirst as chainFirst_ } from './Chain';
 import { fromEquals } from './Eq';
-import { flow, identity, pipe, SK } from './function';
+import { identity, pipe, SK } from './function';
 import { bindTo as bindTo_, flap as flap_ } from './Functor';
 import * as _ from './internal';
 import { getMonoid } from './Ord';
@@ -1026,21 +1026,6 @@ export var modifyLast = function (f) { return function (as) {
  * @since 2.11.0
  */
 export var updateLast = function (a) { return modifyLast(function () { return a; }); };
-/**
- * Places an element in between members of a `ReadonlyNonEmptyArray`, then folds the results using the provided `Semigroup`.
- *
- * @example
- * import * as S from 'fp-ts/string'
- * import { intercalate } from 'fp-ts/ReadonlyNonEmptyArray'
- *
- * assert.deepStrictEqual(intercalate(S.Semigroup)('-')(['a', 'b', 'c']), 'a-b-c')
- *
- * @since 2.12.0
- */
-export var intercalate = function (S) {
-    var concatAllS = concatAll(S);
-    return function (middle) { return flow(intersperse(middle), concatAllS); };
-};
 export function groupSort(O) {
     var sortO = sort(O);
     var groupO = group(O);
diff --git a/node_modules/fp-ts/es6/ReadonlyRecord.d.ts b/node_modules/fp-ts/es6/ReadonlyRecord.d.ts
index 5efd0c4..92abdb6 100644
--- a/node_modules/fp-ts/es6/ReadonlyRecord.d.ts
+++ b/node_modules/fp-ts/es6/ReadonlyRecord.d.ts
@@ -23,14 +23,13 @@ import { Option } from './Option'
 import { Ord } from './Ord'
 import { Predicate } from './Predicate'
 import { Refinement } from './Refinement'
-import * as Se from './Semigroup'
+import { Semigroup } from './Semigroup'
 import { Separated } from './Separated'
 import { Show } from './Show'
 import { Traversable1 } from './Traversable'
 import { TraversableWithIndex1 } from './TraversableWithIndex'
 import { Unfoldable, Unfoldable1 } from './Unfoldable'
 import { PipeableWilt1, PipeableWither1, Witherable1 } from './Witherable'
-import Semigroup = Se.Semigroup
 /**
  * @category model
  * @since 2.5.0
@@ -218,7 +217,7 @@ export declare const updateAt: <A>(
   a: A
 ) => <K extends string>(r: Readonly<Record<K, A>>) => Option<Readonly<Record<K, A>>>
 /**
- * Applies a mapping function to one specific key/value pair in a `ReadonlyRecord`.
+ * Applies a mapping function to one spcific key/value pair in a `ReadonlyRecord`.
  *
  * @returns If the specified key exists it returns an `Option` containing a new `Record`
  * with the entry updated, otherwise it returns `None`
@@ -727,28 +726,6 @@ export declare function fromFoldableMap<F, B>(
   M: Magma<B>,
   F: FoldableHKT<F>
 ): <A>(fa: HKT<F, A>, f: (a: A) => readonly [string, B]) => ReadonlyRecord<string, B>
-/**
- * Alias of [`toReadonlyArray`](#toReadonlyArray).
- *
- * @since 2.12.0
- *
- * @example
- * import { toEntries } from 'fp-ts/Record'
- *
- * assert.deepStrictEqual(toEntries({ a: 1, b: 2 }), [['a', 1], ['b', 2]])
- */
-export declare const toEntries: <K extends string, A>(r: Readonly<Record<K, A>>) => readonly (readonly [K, A])[]
-/**
- * Converts an `Array` of `[key, value]` tuples into a `Record`.
- *
- * @since 2.12.0
- *
- * @example
- * import { fromEntries } from 'fp-ts/Record'
- *
- * assert.deepStrictEqual(fromEntries([['a', 1], ['b', 2], ['a', 3]]), { b: 2, a: 3 })
- */
-export declare const fromEntries: <A>(fa: readonly (readonly [string, A])[]) => Record<string, A>
 /**
  * Test if every value in a `ReadonlyRecord` satisfies the predicate.
  *
@@ -760,10 +737,7 @@ export declare const fromEntries: <A>(fa: readonly (readonly [string, A])[]) =>
  *
  * @since 2.5.0
  */
-export declare function every<A, B extends A>(
-  refinement: Refinement<A, B>
-): Refinement<ReadonlyRecord<string, A>, ReadonlyRecord<string, B>>
-export declare function every<A>(predicate: Predicate<A>): Predicate<ReadonlyRecord<string, A>>
+export declare function every<A>(predicate: Predicate<A>): (r: ReadonlyRecord<string, A>) => boolean
 /**
  * Test if at least one value in a `ReadonlyRecord` satisfies the predicate.
  *
@@ -1250,7 +1224,7 @@ export declare const getWitherable: (O: Ord<string>) => Witherable1<URI>
  * @category instances
  * @since 2.11.0
  */
-export declare const getUnionSemigroup: <A>(S: Se.Semigroup<A>) => Se.Semigroup<Readonly<Record<string, A>>>
+export declare const getUnionSemigroup: <A>(S: Semigroup<A>) => Semigroup<Readonly<Record<string, A>>>
 /**
  * Same as `getMonoid`.
  * Returns a `Monoid` instance for `ReadonlyRecord`s given a `Semigroup`
@@ -1268,7 +1242,7 @@ export declare const getUnionSemigroup: <A>(S: Se.Semigroup<A>) => Se.Semigroup<
  * @category instances
  * @since 2.11.0
  */
-export declare const getUnionMonoid: <A>(S: Se.Semigroup<A>) => Monoid<Readonly<Record<string, A>>>
+export declare const getUnionMonoid: <A>(S: Semigroup<A>) => Monoid<Readonly<Record<string, A>>>
 /**
  * Given a `Semigroup` in the base type, it produces a `Semigroup`
  * in the `ReadonlyRecord` of the base type.
@@ -1286,7 +1260,7 @@ export declare const getUnionMonoid: <A>(S: Se.Semigroup<A>) => Monoid<Readonly<
  * @category instances
  * @since 2.11.0
  */
-export declare const getIntersectionSemigroup: <A>(S: Se.Semigroup<A>) => Se.Semigroup<Readonly<Record<string, A>>>
+export declare const getIntersectionSemigroup: <A>(S: Semigroup<A>) => Semigroup<Readonly<Record<string, A>>>
 /**
  * Produces a `Magma` with a `concat` function that combines
  * two `ReadonlyRecord`s by making the `difference`.
diff --git a/node_modules/fp-ts/es6/ReadonlyRecord.js b/node_modules/fp-ts/es6/ReadonlyRecord.js
index 9b69152..3704405 100644
--- a/node_modules/fp-ts/es6/ReadonlyRecord.js
+++ b/node_modules/fp-ts/es6/ReadonlyRecord.js
@@ -1,9 +1,7 @@
-import * as RA from './ReadonlyArray';
 import { fromEquals } from './Eq';
 import { flow, identity, pipe, SK } from './function';
 import { flap as flap_ } from './Functor';
 import * as _ from './internal';
-import * as Se from './Semigroup';
 import { separated } from './Separated';
 import * as S from './string';
 import { wiltDefault, witherDefault } from './Witherable';
@@ -188,7 +186,7 @@ export var updateAt = function (k, a) { return function (r) {
     return _.some(out);
 }; };
 /**
- * Applies a mapping function to one specific key/value pair in a `ReadonlyRecord`.
+ * Applies a mapping function to one spcific key/value pair in a `ReadonlyRecord`.
  *
  * @returns If the specified key exists it returns an `Option` containing a new `Record`
  * with the entry updated, otherwise it returns `None`
@@ -441,29 +439,16 @@ export function fromFoldableMap(M, F) {
     };
 }
 /**
- * Alias of [`toReadonlyArray`](#toReadonlyArray).
- *
- * @since 2.12.0
+ * Test if every value in a `ReadonlyRecord` satisfies the predicate.
  *
  * @example
- * import { toEntries } from 'fp-ts/Record'
- *
- * assert.deepStrictEqual(toEntries({ a: 1, b: 2 }), [['a', 1], ['b', 2]])
- */
-export var toEntries = toReadonlyArray;
-/**
- * Converts an `Array` of `[key, value]` tuples into a `Record`.
+ * import { every } from "fp-ts/ReadonlyRecord"
  *
- * @since 2.12.0
+ * assert.deepStrictEqual(every((n: number) => n >= 0)({ a: 1, b: 2 }), true);
+ * assert.deepStrictEqual(every((n: number) => n >= 0)({ a: 1, b: -1 }), false);
  *
- * @example
- * import { fromEntries } from 'fp-ts/Record'
- *
- * assert.deepStrictEqual(fromEntries([['a', 1], ['b', 2], ['a', 3]]), { b: 2, a: 3 })
+ * @since 2.5.0
  */
-export var fromEntries = function (fa) {
-    return fromFoldable(Se.last(), RA.Foldable)(fa);
-};
 export function every(predicate) {
     return function (r) {
         for (var k in r) {
@@ -719,8 +704,7 @@ var _traverseWithIndex = function (O) { return function (F) {
         var fr = F.of({});
         var _loop_1 = function (key) {
             fr = F.ap(F.map(fr, function (r) { return function (b) {
-                r[key] = b;
-                return r;
+                return Object.assign({}, r, { [key]: b })
             }; }), f(key, ta[key]));
         };
         for (var _i = 0, ks_1 = ks; _i < ks_1.length; _i++) {
diff --git a/node_modules/fp-ts/es6/ReadonlySet.d.ts b/node_modules/fp-ts/es6/ReadonlySet.d.ts
index 36a3255..c47c186 100644
--- a/node_modules/fp-ts/es6/ReadonlySet.d.ts
+++ b/node_modules/fp-ts/es6/ReadonlySet.d.ts
@@ -192,8 +192,7 @@ export declare const some: <A>(predicate: Predicate<A>) => (set: ReadonlySet<A>)
 /**
  * @since 2.5.0
  */
-export declare function every<A, B extends A>(refinement: Refinement<A, B>): Refinement<ReadonlySet<A>, ReadonlySet<B>>
-export declare function every<A>(predicate: Predicate<A>): Predicate<ReadonlySet<A>>
+export declare const every: <A>(predicate: Predicate<A>) => (set: ReadonlySet<A>) => boolean
 /**
  * `true` if and only if every element in the first set is an element of the second set
  *
diff --git a/node_modules/fp-ts/es6/ReadonlySet.js b/node_modules/fp-ts/es6/ReadonlySet.js
index 61a8405..36470b5 100644
--- a/node_modules/fp-ts/es6/ReadonlySet.js
+++ b/node_modules/fp-ts/es6/ReadonlySet.js
@@ -343,9 +343,10 @@ export var some = function (predicate) { return function (set) {
     }
     return found;
 }; };
-export function every(predicate) {
-    return not(some(not(predicate)));
-}
+/**
+ * @since 2.5.0
+ */
+export var every = function (predicate) { return not(some(not(predicate))); };
 export function isSubset(E) {
     var elemE = elem(E);
     return function (me, that) {
diff --git a/node_modules/fp-ts/es6/Record.d.ts b/node_modules/fp-ts/es6/Record.d.ts
index 711e770..3805b23 100644
--- a/node_modules/fp-ts/es6/Record.d.ts
+++ b/node_modules/fp-ts/es6/Record.d.ts
@@ -21,14 +21,13 @@ import { Option } from './Option'
 import { Ord } from './Ord'
 import { Predicate } from './Predicate'
 import { Refinement } from './Refinement'
-import * as Se from './Semigroup'
+import { Semigroup } from './Semigroup'
 import { Separated } from './Separated'
 import { Show } from './Show'
 import { Traversable1 } from './Traversable'
 import { TraversableWithIndex1 } from './TraversableWithIndex'
 import { Unfoldable, Unfoldable1 } from './Unfoldable'
 import { PipeableWilt1, PipeableWither1, Witherable1 } from './Witherable'
-import Semigroup = Se.Semigroup
 /**
  * Calculate the number of key/value pairs in a `Record`.
  *
@@ -624,28 +623,6 @@ export declare function fromFoldable<F, A>(
   M: Magma<A>,
   F: FoldableHKT<F>
 ): (fka: HKT<F, [string, A]>) => Record<string, A>
-/**
- * Alias of [`toArray`](#toArray).
- *
- * @since 2.12.0
- *
- * @example
- * import { toEntries } from 'fp-ts/Record'
- *
- * assert.deepStrictEqual(toEntries({ a: 1, b: 2 }), [['a', 1], ['b', 2]])
- */
-export declare const toEntries: <K extends string, A>(r: Record<K, A>) => [K, A][]
-/**
- * Converts an `Array` of `[key, value]` tuples into a `Record`.
- *
- * @since 2.12.0
- *
- * @example
- * import { fromEntries } from 'fp-ts/Record'
- *
- * assert.deepStrictEqual(fromEntries([['a', 1], ['b', 2], ['a', 3]]), { b: 2, a: 3 })
- */
-export declare const fromEntries: <A>(fa: [string, A][]) => Record<string, A>
 /**
  * Create a `Record` from a foldable collection using the specified functions to
  *
@@ -708,10 +685,7 @@ export declare function fromFoldableMap<F, B>(
  *
  * @since 2.0.0
  */
-export declare const every: {
-  <A, B extends A>(refinement: Refinement<A, B>): Refinement<Record<string, A>, Record<string, B>>
-  <A>(predicate: Predicate<A>): Predicate<Record<string, A>>
-}
+export declare const every: <A>(predicate: Predicate<A>) => (r: Record<string, A>) => boolean
 /**
  * Test if at least one value in a `Record` satisfies the predicate.
  *
@@ -1186,7 +1160,7 @@ export declare const getWitherable: (O: Ord<string>) => Witherable1<URI>
  * @category instances
  * @since 2.11.0
  */
-export declare const getUnionSemigroup: <A>(S: Se.Semigroup<A>) => Se.Semigroup<Record<string, A>>
+export declare const getUnionSemigroup: <A>(S: Semigroup<A>) => Semigroup<Record<string, A>>
 /**
  * Same as `getMonoid`.
  * Returns a `Monoid` instance for `Record`s given a `Semigroup`
@@ -1204,7 +1178,7 @@ export declare const getUnionSemigroup: <A>(S: Se.Semigroup<A>) => Se.Semigroup<
  * @category instances
  * @since 2.11.0
  */
-export declare const getUnionMonoid: <A>(S: Se.Semigroup<A>) => Monoid<Record<string, A>>
+export declare const getUnionMonoid: <A>(S: Semigroup<A>) => Monoid<Record<string, A>>
 /**
  * Given a `Semigroup` in the base type, it produces a `Semigroup`
  * in the `Record` of the base type.
@@ -1222,7 +1196,7 @@ export declare const getUnionMonoid: <A>(S: Se.Semigroup<A>) => Monoid<Record<st
  * @category instances
  * @since 2.11.0
  */
-export declare const getIntersectionSemigroup: <A>(S: Se.Semigroup<A>) => Se.Semigroup<Record<string, A>>
+export declare const getIntersectionSemigroup: <A>(S: Semigroup<A>) => Semigroup<Record<string, A>>
 /**
  * Produces a `Magma` with a `concat` function that combines
  * two `Record`s by making the `difference`.
diff --git a/node_modules/fp-ts/es6/Record.js b/node_modules/fp-ts/es6/Record.js
index 7342eda..0b72dbf 100644
--- a/node_modules/fp-ts/es6/Record.js
+++ b/node_modules/fp-ts/es6/Record.js
@@ -9,12 +9,10 @@ var __assign = (this && this.__assign) || function () {
     };
     return __assign.apply(this, arguments);
 };
-import * as A from './Array';
 import { pipe } from './function';
 import { flap as flap_ } from './Functor';
 import * as _ from './internal';
 import * as RR from './ReadonlyRecord';
-import * as Se from './Semigroup';
 import * as S from './string';
 import { wiltDefault, witherDefault } from './Witherable';
 // -------------------------------------------------------------------------------------
@@ -356,28 +354,6 @@ export function filterWithIndex(predicateWithIndex) {
 export function fromFoldable(M, F) {
     return RR.fromFoldable(M, F);
 }
-/**
- * Alias of [`toArray`](#toArray).
- *
- * @since 2.12.0
- *
- * @example
- * import { toEntries } from 'fp-ts/Record'
- *
- * assert.deepStrictEqual(toEntries({ a: 1, b: 2 }), [['a', 1], ['b', 2]])
- */
-export var toEntries = toArray;
-/**
- * Converts an `Array` of `[key, value]` tuples into a `Record`.
- *
- * @since 2.12.0
- *
- * @example
- * import { fromEntries } from 'fp-ts/Record'
- *
- * assert.deepStrictEqual(fromEntries([['a', 1], ['b', 2], ['a', 3]]), { b: 2, a: 3 })
- */
-export var fromEntries = function (fa) { return fromFoldable(Se.last(), A.Foldable)(fa); };
 export function fromFoldableMap(M, F) {
     return RR.fromFoldableMap(M, F);
 }
diff --git a/node_modules/fp-ts/es6/Set.d.ts b/node_modules/fp-ts/es6/Set.d.ts
index 638c1f1..54df70f 100644
--- a/node_modules/fp-ts/es6/Set.d.ts
+++ b/node_modules/fp-ts/es6/Set.d.ts
@@ -208,10 +208,7 @@ export declare const some: <A>(predicate: Predicate<A>) => (set: Set<A>) => bool
 /**
  * @since 2.0.0
  */
-export declare const every: {
-  <A, B extends A>(refinement: Refinement<A, B>): Refinement<Set<A>, Set<B>>
-  <A>(predicate: Predicate<A>): Predicate<Set<A>>
-}
+export declare const every: <A>(predicate: Predicate<A>) => (set: Set<A>) => boolean
 /**
  * @since 2.10.0
  */
diff --git a/node_modules/fp-ts/es6/StateReaderTaskEither.d.ts b/node_modules/fp-ts/es6/StateReaderTaskEither.d.ts
index 62f279b..7822f50 100644
--- a/node_modules/fp-ts/es6/StateReaderTaskEither.d.ts
+++ b/node_modules/fp-ts/es6/StateReaderTaskEither.d.ts
@@ -397,15 +397,6 @@ export declare const Apply: Apply4<URI>
 export declare const apFirst: <S, R, E, B>(
   second: StateReaderTaskEither<S, R, E, B>
 ) => <A>(first: StateReaderTaskEither<S, R, E, A>) => StateReaderTaskEither<S, R, E, A>
-/**
- * Less strict version of [`apFirst`](#apfirst).
- *
- * @category combinators
- * @since 2.12.0
- */
-export declare const apFirstW: <S, R2, E2, A, B>(
-  second: StateReaderTaskEither<S, R2, E2, B>
-) => <R1, E1>(first: StateReaderTaskEither<S, R1, E1, A>) => StateReaderTaskEither<S, R1 & R2, E1 | E2, A>
 /**
  * Combine two effectful actions, keeping only the result of the second.
  *
@@ -417,15 +408,6 @@ export declare const apFirstW: <S, R2, E2, A, B>(
 export declare const apSecond: <S, R, E, B>(
   second: StateReaderTaskEither<S, R, E, B>
 ) => <A>(first: StateReaderTaskEither<S, R, E, A>) => StateReaderTaskEither<S, R, E, B>
-/**
- * Less strict version of [`apSecond`](#apsecond).
- *
- * @category combinators
- * @since 2.12.0
- */
-export declare const apSecondW: <S, R2, E2, A, B>(
-  second: StateReaderTaskEither<S, R2, E2, B>
-) => <R1, E1>(first: StateReaderTaskEither<S, R1, E1, A>) => StateReaderTaskEither<S, R1 & R2, E1 | E2, B>
 /**
  * @category instances
  * @since 2.7.0
@@ -638,22 +620,6 @@ export declare const chainEitherK: <E, A, B>(
 export declare const chainEitherKW: <E2, A, B>(
   f: (a: A) => Either<E2, B>
 ) => <S, R, E1>(ma: StateReaderTaskEither<S, R, E1, A>) => StateReaderTaskEither<S, R, E1 | E2, B>
-/**
- * @category combinators
- * @since 2.12.0
- */
-export declare const chainFirstEitherK: <A, E, B>(
-  f: (a: A) => E.Either<E, B>
-) => <S, R>(ma: StateReaderTaskEither<S, R, E, A>) => StateReaderTaskEither<S, R, E, A>
-/**
- * Less strict version of [`chainFirstEitherK`](#chainfirsteitherk).
- *
- * @category combinators
- * @since 2.12.0
- */
-export declare const chainFirstEitherKW: <A, E2, B>(
-  f: (a: A) => Either<E2, B>
-) => <S, R, E1>(ma: StateReaderTaskEither<S, R, E1, A>) => StateReaderTaskEither<S, R, E1 | E2, A>
 /**
  * @category constructors
  * @since 2.4.4
diff --git a/node_modules/fp-ts/es6/StateReaderTaskEither.js b/node_modules/fp-ts/es6/StateReaderTaskEither.js
index 3de28dc..1a0e775 100644
--- a/node_modules/fp-ts/es6/StateReaderTaskEither.js
+++ b/node_modules/fp-ts/es6/StateReaderTaskEither.js
@@ -1,7 +1,7 @@
 import { apFirst as apFirst_, apS as apS_, apSecond as apSecond_ } from './Apply';
 import { bind as bind_, chainFirst as chainFirst_ } from './Chain';
 import * as E from './Either';
-import { chainEitherK as chainEitherK_, chainOptionK as chainOptionK_, filterOrElse as filterOrElse_, fromEitherK as fromEitherK_, fromOption as fromOption_, fromOptionK as fromOptionK_, fromPredicate as fromPredicate_, chainFirstEitherK as chainFirstEitherK_ } from './FromEither';
+import { chainEitherK as chainEitherK_, chainOptionK as chainOptionK_, filterOrElse as filterOrElse_, fromEitherK as fromEitherK_, fromOption as fromOption_, fromOptionK as fromOptionK_, fromPredicate as fromPredicate_ } from './FromEither';
 import { chainFirstIOK as chainFirstIOK_, chainIOK as chainIOK_, fromIOK as fromIOK_ } from './FromIO';
 import { ask as ask_, asks as asks_, chainFirstReaderK as chainFirstReaderK_, chainReaderK as chainReaderK_, fromReaderK as fromReaderK_ } from './FromReader';
 import { chainStateK as chainStateK_, fromStateK as fromStateK_, get as get_, gets as gets_, modify as modify_, put as put_ } from './FromState';
@@ -410,13 +410,6 @@ export var Apply = {
 export var apFirst = 
 /*#__PURE__*/
 apFirst_(Apply);
-/**
- * Less strict version of [`apFirst`](#apfirst).
- *
- * @category combinators
- * @since 2.12.0
- */
-export var apFirstW = apFirst;
 /**
  * Combine two effectful actions, keeping only the result of the second.
  *
@@ -428,13 +421,6 @@ export var apFirstW = apFirst;
 export var apSecond = 
 /*#__PURE__*/
 apSecond_(Apply);
-/**
- * Less strict version of [`apSecond`](#apsecond).
- *
- * @category combinators
- * @since 2.12.0
- */
-export var apSecondW = apSecond;
 /**
  * @category instances
  * @since 2.7.0
@@ -704,20 +690,6 @@ chainEitherK_(FromEither, Chain);
  * @since 2.6.1
  */
 export var chainEitherKW = chainEitherK;
-/**
- * @category combinators
- * @since 2.12.0
- */
-export var chainFirstEitherK = 
-/*#__PURE__*/
-chainFirstEitherK_(FromEither, Chain);
-/**
- * Less strict version of [`chainFirstEitherK`](#chainfirsteitherk).
- *
- * @category combinators
- * @since 2.12.0
- */
-export var chainFirstEitherKW = chainFirstEitherK;
 /**
  * @category constructors
  * @since 2.4.4
diff --git a/node_modules/fp-ts/es6/TaskEither.d.ts b/node_modules/fp-ts/es6/TaskEither.d.ts
index 0b4c7e8..59e822c 100644
--- a/node_modules/fp-ts/es6/TaskEither.d.ts
+++ b/node_modules/fp-ts/es6/TaskEither.d.ts
@@ -166,6 +166,8 @@ export declare const getOrElseW: <E, B>(onLeft: (e: E) => Task<B>) => <A>(ma: Ta
 /**
  * Transforms a `Promise` that may reject to a `Promise` that never rejects and returns an `Either` instead.
  *
+ * Note: `f` should never `throw` errors, they are not caught.
+ *
  * See also [`tryCatchK`](#trycatchk).
  *
  * @example
@@ -198,27 +200,6 @@ export declare const tryCatchK: <E, A extends readonly unknown[], B>(
  * @since 2.10.0
  */
 export declare const toUnion: <E, A>(fa: TaskEither<E, A>) => Task<E | A>
-/**
- * @category interop
- * @since 2.12.0
- */
-export declare const fromNullable: <E>(e: E) => <A>(a: A) => TaskEither<E, NonNullable<A>>
-/**
- * @category interop
- * @since 2.12.0
- */
-export declare const fromNullableK: <E>(
-  e: E
-) => <A extends ReadonlyArray<unknown>, B>(
-  f: (...a: A) => B | null | undefined
-) => (...a: A) => TaskEither<E, NonNullable<B>>
-/**
- * @category interop
- * @since 2.12.0
- */
-export declare const chainNullableK: <E>(
-  e: E
-) => <A, B>(f: (a: A) => B | null | undefined) => (ma: TaskEither<E, A>) => TaskEither<E, NonNullable<B>>
 /**
  * Returns `ma` if is a `Right` or the value returned by `onLeft` otherwise.
  *
@@ -266,18 +247,6 @@ export declare const orElseFirst: <E, B>(
 export declare const orElseFirstW: <E1, E2, B>(
   onLeft: (e: E1) => TaskEither<E2, B>
 ) => <A>(ma: TaskEither<E1, A>) => TaskEither<E1 | E2, A>
-/**
- * @category combinators
- * @since 2.12.0
- */
-export declare const orElseFirstIOK: <E, B>(onLeft: (e: E) => IO<B>) => <A>(ma: TaskEither<E, A>) => TaskEither<E, A>
-/**
- * @category combinators
- * @since 2.12.0
- */
-export declare const orElseFirstTaskK: <E, B>(
-  onLeft: (e: E) => Task<B>
-) => <A>(ma: TaskEither<E, A>) => TaskEither<E, A>
 /**
  * @category combinators
  * @since 2.11.0
@@ -521,15 +490,6 @@ export declare const ApplyPar: Apply2<URI>
  * @since 2.0.0
  */
 export declare const apFirst: <E, B>(second: TaskEither<E, B>) => <A>(first: TaskEither<E, A>) => TaskEither<E, A>
-/**
- * Less strict version of [`apFirst`](#apfirst).
- *
- * @category combinators
- * @since 2.12.0
- */
-export declare const apFirstW: <E2, A, B>(
-  second: TaskEither<E2, B>
-) => <E1>(first: TaskEither<E1, A>) => TaskEither<E1 | E2, A>
 /**
  * Combine two effectful actions, keeping only the result of the second.
  *
@@ -539,15 +499,6 @@ export declare const apFirstW: <E2, A, B>(
  * @since 2.0.0
  */
 export declare const apSecond: <E, B>(second: TaskEither<E, B>) => <A>(first: TaskEither<E, A>) => TaskEither<E, B>
-/**
- * Less strict version of [`apSecond`](#apsecond).
- *
- * @category combinators
- * @since 2.12.0
- */
-export declare const apSecondW: <E2, A, B>(
-  second: TaskEither<E2, B>
-) => <E1>(first: TaskEither<E1, A>) => TaskEither<E1 | E2, B>
 /**
  * @category instances
  * @since 2.7.0
@@ -657,22 +608,6 @@ export declare const chainEitherK: <E, A, B>(f: (a: A) => E.Either<E, B>) => (ma
 export declare const chainEitherKW: <E2, A, B>(
   f: (a: A) => Either<E2, B>
 ) => <E1>(ma: TaskEither<E1, A>) => TaskEither<E1 | E2, B>
-/**
- * @category combinators
- * @since 2.12.0
- */
-export declare const chainFirstEitherK: <A, E, B>(
-  f: (a: A) => E.Either<E, B>
-) => (ma: TaskEither<E, A>) => TaskEither<E, A>
-/**
- * Less strict version of [`chainFirstEitherK`](#chainfirsteitherk).
- *
- * @category combinators
- * @since 2.12.0
- */
-export declare const chainFirstEitherKW: <A, E2, B>(
-  f: (a: A) => E.Either<E2, B>
-) => <E1>(ma: TaskEither<E1, A>) => TaskEither<E1 | E2, A>
 /**
  * @category constructors
  * @since 2.0.0
@@ -813,16 +748,6 @@ export declare const bracket: <E, A, B>(
   use: (a: A) => TaskEither<E, B>,
   release: (a: A, e: E.Either<E, B>) => TaskEither<E, void>
 ) => TaskEither<E, B>
-/**
- * Less strict version of [`bracket`](#bracket).
- *
- * @since 2.12.0
- */
-export declare const bracketW: <E1, A, E2, B, E3>(
-  acquire: TaskEither<E1, A>,
-  use: (a: A) => TaskEither<E2, B>,
-  release: (a: A, e: E.Either<E2, B>) => TaskEither<E3, void>
-) => TaskEither<E1 | E2 | E3, B>
 /**
  * @since 2.9.0
  */
diff --git a/node_modules/fp-ts/es6/TaskEither.js b/node_modules/fp-ts/es6/TaskEither.js
index a8311ab..d42ab75 100644
--- a/node_modules/fp-ts/es6/TaskEither.js
+++ b/node_modules/fp-ts/es6/TaskEither.js
@@ -1,39 +1,3 @@
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
-var __generator = (this && this.__generator) || function (thisArg, body) {
-    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
-    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
-    function verb(n) { return function (v) { return step([n, v]); }; }
-    function step(op) {
-        if (f) throw new TypeError("Generator is already executing.");
-        while (_) try {
-            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
-            if (y = 0, t) op = [op[0] & 2, t.value];
-            switch (op[0]) {
-                case 0: case 1: t = op; break;
-                case 4: _.label++; return { value: op[1], done: false };
-                case 5: _.label++; y = op[1]; op = [0]; continue;
-                case 7: op = _.ops.pop(); _.trys.pop(); continue;
-                default:
-                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
-                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
-                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
-                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
-                    if (t[2]) _.ops.pop();
-                    _.trys.pop(); continue;
-            }
-            op = body.call(thisArg, _);
-        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
-        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
-    }
-};
 import { getApplicativeMonoid } from './Applicative';
 import { ap as ap_, apFirst as apFirst_, apS as apS_, apSecond as apSecond_, getApplySemigroup as getApplySemigroup_ } from './Apply';
 import { bind as bind_, chainFirst as chainFirst_ } from './Chain';
@@ -41,7 +5,7 @@ import { compact as compact_, separate as separate_ } from './Compactable';
 import * as E from './Either';
 import * as ET from './EitherT';
 import { filter as filter_, filterMap as filterMap_, partition as partition_, partitionMap as partitionMap_ } from './Filterable';
-import { chainEitherK as chainEitherK_, chainOptionK as chainOptionK_, filterOrElse as filterOrElse_, fromEitherK as fromEitherK_, fromOption as fromOption_, fromOptionK as fromOptionK_, fromPredicate as fromPredicate_, chainFirstEitherK as chainFirstEitherK_ } from './FromEither';
+import { chainEitherK as chainEitherK_, chainOptionK as chainOptionK_, filterOrElse as filterOrElse_, fromEitherK as fromEitherK_, fromOption as fromOption_, fromOptionK as fromOptionK_, fromPredicate as fromPredicate_ } from './FromEither';
 import { chainFirstIOK as chainFirstIOK_, chainIOK as chainIOK_, fromIOK as fromIOK_ } from './FromIO';
 import { chainFirstTaskK as chainFirstTaskK_, chainTaskK as chainTaskK_, fromTaskK as fromTaskK_ } from './FromTask';
 import { flow, identity, pipe, SK } from './function';
@@ -188,6 +152,8 @@ export var getOrElseW = getOrElse;
 /**
  * Transforms a `Promise` that may reject to a `Promise` that never rejects and returns an `Either` instead.
  *
+ * Note: `f` should never `throw` errors, they are not caught.
+ *
  * See also [`tryCatchK`](#trycatchk).
  *
  * @example
@@ -204,21 +170,9 @@ export var getOrElseW = getOrElse;
  * @category interop
  * @since 2.0.0
  */
-export var tryCatch = function (f, onRejected) { return function () { return __awaiter(void 0, void 0, void 0, function () {
-    var reason_1;
-    return __generator(this, function (_a) {
-        switch (_a.label) {
-            case 0:
-                _a.trys.push([0, 2, , 3]);
-                return [4 /*yield*/, f().then(_.right)];
-            case 1: return [2 /*return*/, _a.sent()];
-            case 2:
-                reason_1 = _a.sent();
-                return [2 /*return*/, _.left(onRejected(reason_1))];
-            case 3: return [2 /*return*/];
-        }
-    });
-}); }; };
+export var tryCatch = function (f, onRejected) { return function () {
+    return f().then(_.right, function (reason) { return _.left(onRejected(reason)); });
+}; };
 /**
  * Converts a function returning a `Promise` to one returning a `TaskEither`.
  *
@@ -239,27 +193,6 @@ export var tryCatchK = function (f, onRejected) { return function () {
 export var toUnion = 
 /*#__PURE__*/
 ET.toUnion(T.Functor);
-/**
- * @category interop
- * @since 2.12.0
- */
-export var fromNullable = 
-/*#__PURE__*/
-ET.fromNullable(T.Pointed);
-/**
- * @category interop
- * @since 2.12.0
- */
-export var fromNullableK = 
-/*#__PURE__*/
-ET.fromNullableK(T.Pointed);
-/**
- * @category interop
- * @since 2.12.0
- */
-export var chainNullableK = 
-/*#__PURE__*/
-ET.chainNullableK(T.Monad);
 // -------------------------------------------------------------------------------------
 // combinators
 // -------------------------------------------------------------------------------------
@@ -306,16 +239,6 @@ ET.orElseFirst(T.Monad);
  * @since 2.11.0
  */
 export var orElseFirstW = orElseFirst;
-/**
- * @category combinators
- * @since 2.12.0
- */
-export var orElseFirstIOK = function (onLeft) { return orElseFirst(fromIOK(onLeft)); };
-/**
- * @category combinators
- * @since 2.12.0
- */
-export var orElseFirstTaskK = function (onLeft) { return orElseFirst(fromTaskK(onLeft)); };
 /**
  * @category combinators
  * @since 2.11.0
@@ -635,13 +558,6 @@ export var ApplyPar = {
 export var apFirst = 
 /*#__PURE__*/
 apFirst_(ApplyPar);
-/**
- * Less strict version of [`apFirst`](#apfirst).
- *
- * @category combinators
- * @since 2.12.0
- */
-export var apFirstW = apFirst;
 /**
  * Combine two effectful actions, keeping only the result of the second.
  *
@@ -653,13 +569,6 @@ export var apFirstW = apFirst;
 export var apSecond = 
 /*#__PURE__*/
 apSecond_(ApplyPar);
-/**
- * Less strict version of [`apSecond`](#apsecond).
- *
- * @category combinators
- * @since 2.12.0
- */
-export var apSecondW = apSecond;
 /**
  * @category instances
  * @since 2.7.0
@@ -829,20 +738,6 @@ chainEitherK_(FromEither, Chain);
  * @since 2.6.1
  */
 export var chainEitherKW = chainEitherK;
-/**
- * @category combinators
- * @since 2.12.0
- */
-export var chainFirstEitherK = 
-/*#__PURE__*/
-chainFirstEitherK_(FromEither, Chain);
-/**
- * Less strict version of [`chainFirstEitherK`](#chainfirsteitherk).
- *
- * @category combinators
- * @since 2.12.0
- */
-export var chainFirstEitherKW = chainFirstEitherK;
 /**
  * @category constructors
  * @since 2.0.0
@@ -949,16 +844,10 @@ export function taskify(f) {
  *
  * @since 2.0.0
  */
-export var bracket = function (acquire, use, release) { return bracketW(acquire, use, release); };
-/**
- * Less strict version of [`bracket`](#bracket).
- *
- * @since 2.12.0
- */
-export var bracketW = function (acquire, use, release) {
-    return pipe(acquire, chainW(function (a) {
+export var bracket = function (acquire, use, release) {
+    return pipe(acquire, chain(function (a) {
         return pipe(use(a), T.chain(function (e) {
-            return pipe(release(a, e), chainW(function () { return T.of(e); }));
+            return pipe(release(a, e), chain(function () { return T.of(e); }));
         }));
     }));
 };
diff --git a/node_modules/fp-ts/es6/TaskOption.d.ts b/node_modules/fp-ts/es6/TaskOption.d.ts
index 43bb981..8e1a51c 100644
--- a/node_modules/fp-ts/es6/TaskOption.d.ts
+++ b/node_modules/fp-ts/es6/TaskOption.d.ts
@@ -140,6 +140,8 @@ export declare const fromNullable: <A>(a: A) => TaskOption<NonNullable<A>>
 /**
  * Transforms a `Promise` that may reject to a `Promise` that never rejects and returns an `Option` instead.
  *
+ * Note: `f` should never `throw` errors, they are not caught.
+ *
  * See also [`tryCatchK`](#trycatchk).
  *
  * @category interop
@@ -430,23 +432,6 @@ export declare const chainFirstIOK: <A, B>(f: (a: A) => import('./IO').IO<B>) =>
  * @since 2.11.0
  */
 export declare const FromEither: FromEither1<URI>
-/**
- * @category combinators
- * @since 2.12.0
- */
-export declare const fromEitherK: <E, A extends readonly unknown[], B>(
-  f: (...a: A) => Either<E, B>
-) => (...a: A) => TaskOption<B>
-/**
- * @category combinators
- * @since 2.12.0
- */
-export declare const chainEitherK: <E, A, B>(f: (a: A) => Either<E, B>) => (ma: TaskOption<A>) => TaskOption<B>
-/**
- * @category combinators
- * @since 2.12.0
- */
-export declare const chainFirstEitherK: <E, A, B>(f: (a: A) => Either<E, B>) => (ma: TaskOption<A>) => TaskOption<A>
 /**
  * @category instances
  * @since 2.10.0
diff --git a/node_modules/fp-ts/es6/TaskOption.js b/node_modules/fp-ts/es6/TaskOption.js
index ac1bcac..56d8a1f 100644
--- a/node_modules/fp-ts/es6/TaskOption.js
+++ b/node_modules/fp-ts/es6/TaskOption.js
@@ -1,44 +1,7 @@
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
-var __generator = (this && this.__generator) || function (thisArg, body) {
-    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
-    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
-    function verb(n) { return function (v) { return step([n, v]); }; }
-    function step(op) {
-        if (f) throw new TypeError("Generator is already executing.");
-        while (_) try {
-            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
-            if (y = 0, t) op = [op[0] & 2, t.value];
-            switch (op[0]) {
-                case 0: case 1: t = op; break;
-                case 4: _.label++; return { value: op[1], done: false };
-                case 5: _.label++; y = op[1]; op = [0]; continue;
-                case 7: op = _.ops.pop(); _.trys.pop(); continue;
-                default:
-                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
-                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
-                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
-                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
-                    if (t[2]) _.ops.pop();
-                    _.trys.pop(); continue;
-            }
-            op = body.call(thisArg, _);
-        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
-        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
-    }
-};
 import { apFirst as apFirst_, apS as apS_, apSecond as apSecond_ } from './Apply';
 import { bind as bind_, chainFirst as chainFirst_ } from './Chain';
 import { compact as compact_, separate as separate_ } from './Compactable';
 import { filter as filter_, filterMap as filterMap_, partition as partition_, partitionMap as partitionMap_ } from './Filterable';
-import { chainEitherK as chainEitherK_, chainFirstEitherK as chainFirstEitherK_, fromEitherK as fromEitherK_ } from './FromEither';
 import { chainFirstIOK as chainFirstIOK_, chainIOK as chainIOK_, fromIOK as fromIOK_ } from './FromIO';
 import { chainFirstTaskK as chainFirstTaskK_, chainTaskK as chainTaskK_, fromTaskK as fromTaskK_ } from './FromTask';
 import { flow, identity, pipe, SK } from './function';
@@ -171,26 +134,16 @@ OT.fromNullable(T.Pointed);
 /**
  * Transforms a `Promise` that may reject to a `Promise` that never rejects and returns an `Option` instead.
  *
+ * Note: `f` should never `throw` errors, they are not caught.
+ *
  * See also [`tryCatchK`](#trycatchk).
  *
  * @category interop
  * @since 2.10.0
  */
-export var tryCatch = function (f) { return function () { return __awaiter(void 0, void 0, void 0, function () {
-    var reason_1;
-    return __generator(this, function (_a) {
-        switch (_a.label) {
-            case 0:
-                _a.trys.push([0, 2, , 3]);
-                return [4 /*yield*/, f().then(_.some)];
-            case 1: return [2 /*return*/, _a.sent()];
-            case 2:
-                reason_1 = _a.sent();
-                return [2 /*return*/, _.none];
-            case 3: return [2 /*return*/];
-        }
-    });
-}); }; };
+export var tryCatch = function (f) { return function () {
+    return f().then(function (a) { return O.some(a); }, function () { return O.none; });
+}; };
 /**
  * Converts a function returning a `Promise` to one returning a `TaskOption`.
  *
@@ -614,27 +567,6 @@ export var FromEither = {
     URI: URI,
     fromEither: fromEither
 };
-/**
- * @category combinators
- * @since 2.12.0
- */
-export var fromEitherK = 
-/*#__PURE__*/
-fromEitherK_(FromEither);
-/**
- * @category combinators
- * @since 2.12.0
- */
-export var chainEitherK = 
-/*#__PURE__*/
-chainEitherK_(FromEither, Chain);
-/**
- * @category combinators
- * @since 2.12.0
- */
-export var chainFirstEitherK = 
-/*#__PURE__*/
-chainFirstEitherK_(FromEither, Chain);
 /**
  * @category instances
  * @since 2.10.0
@@ -781,3 +713,7 @@ export var traverseSeqArray = function (f) { return traverseReadonlyArrayWithInd
 export var sequenceSeqArray = 
 /*#__PURE__*/
 traverseSeqArray(identity);
+// -------------------------------------------------------------------------------------
+// deprecated
+// -------------------------------------------------------------------------------------
+// tslint:disable: deprecation
diff --git a/node_modules/fp-ts/es6/index.d.ts b/node_modules/fp-ts/es6/index.d.ts
index f461cec..06a33df 100644
--- a/node_modules/fp-ts/es6/index.d.ts
+++ b/node_modules/fp-ts/es6/index.d.ts
@@ -51,7 +51,6 @@ import * as identity from './Identity'
 import * as invariant from './Invariant'
 import * as io from './IO'
 import * as ioEither from './IOEither'
-import * as ioOption from './IOOption'
 import * as ioRef from './IORef'
 import * as joinSemilattice from './JoinSemilattice'
 import * as json from './Json'
@@ -318,10 +317,6 @@ export {
    * @since 2.0.0
    */
   ioEither,
-  /**
-   * @since 2.12.0
-   */
-  ioOption,
   /**
    * @since 2.0.0
    */
diff --git a/node_modules/fp-ts/es6/index.js b/node_modules/fp-ts/es6/index.js
index aed3e17..f03691e 100644
--- a/node_modules/fp-ts/es6/index.js
+++ b/node_modules/fp-ts/es6/index.js
@@ -51,7 +51,6 @@ import * as identity from './Identity';
 import * as invariant from './Invariant';
 import * as io from './IO';
 import * as ioEither from './IOEither';
-import * as ioOption from './IOOption';
 import * as ioRef from './IORef';
 import * as joinSemilattice from './JoinSemilattice';
 import * as json from './Json';
@@ -318,10 +317,6 @@ io,
  * @since 2.0.0
  */
 ioEither, 
-/**
- * @since 2.12.0
- */
-ioOption, 
 /**
  * @since 2.0.0
  */
diff --git a/node_modules/fp-ts/es6/pipeable.d.ts b/node_modules/fp-ts/es6/pipeable.d.ts
index ae4994c..fe85699 100644
--- a/node_modules/fp-ts/es6/pipeable.d.ts
+++ b/node_modules/fp-ts/es6/pipeable.d.ts
@@ -1417,7 +1417,7 @@ export declare function pipeable<F, I>(
   (I extends Semigroupoid<F> ? PipeableSemigroupoid<F> : {}) &
   (I extends MonadThrow<F> ? PipeableMonadThrow<F> : {})
 /**
- * Use [`pipe`](https://gcanti.github.io/fp-ts/modules/function.ts.html#pipe) from `function` module instead.
+ * Use [`pipe`](https://gcanti.github.io/fp-ts/modules/function.ts.html#flow) from `function` module instead.
  *
  * @since 2.0.0
  * @deprecated
diff --git a/node_modules/fp-ts/es6/pipeable.js b/node_modules/fp-ts/es6/pipeable.js
index 732b028..41a3f4c 100644
--- a/node_modules/fp-ts/es6/pipeable.js
+++ b/node_modules/fp-ts/es6/pipeable.js
@@ -150,7 +150,7 @@ export function pipeable(I) {
     return r;
 }
 /**
- * Use [`pipe`](https://gcanti.github.io/fp-ts/modules/function.ts.html#pipe) from `function` module instead.
+ * Use [`pipe`](https://gcanti.github.io/fp-ts/modules/function.ts.html#flow) from `function` module instead.
  *
  * @since 2.0.0
  * @deprecated
diff --git a/node_modules/fp-ts/es6/string.d.ts b/node_modules/fp-ts/es6/string.d.ts
index 9732fa8..f1d9762 100644
--- a/node_modules/fp-ts/es6/string.d.ts
+++ b/node_modules/fp-ts/es6/string.d.ts
@@ -31,12 +31,6 @@ export declare const Eq: E.Eq<string>
  * @since 2.10.0
  */
 export declare const Semigroup: S.Semigroup<string>
-/**
- * An empty `string`.
- *
- * @since 2.10.0
- */
-export declare const empty: string
 /**
  * `string` monoid under concatenation.
  *
@@ -162,6 +156,12 @@ export declare const trimRight: (s: string) => string
  * @since 2.11.0
  */
 export declare const slice: (start: number, end: number) => (s: string) => string
+/**
+ * An empty `string`.
+ *
+ * @since 2.10.0
+ */
+export declare const empty: string
 /**
  * Test whether a `string` is empty.
  *
diff --git a/node_modules/fp-ts/es6/string.js b/node_modules/fp-ts/es6/string.js
index f249e2b..7b4c985 100644
--- a/node_modules/fp-ts/es6/string.js
+++ b/node_modules/fp-ts/es6/string.js
@@ -29,12 +29,6 @@ export var Eq = {
 export var Semigroup = {
     concat: function (first, second) { return first + second; }
 };
-/**
- * An empty `string`.
- *
- * @since 2.10.0
- */
-export var empty = '';
 /**
  * `string` monoid under concatenation.
  *
@@ -51,7 +45,7 @@ export var empty = '';
  */
 export var Monoid = {
     concat: Semigroup.concat,
-    empty: empty
+    empty: ''
 };
 /**
  * @example
@@ -179,6 +173,12 @@ export var slice = function (start, end) { return function (s) { return s.slice(
 // -------------------------------------------------------------------------------------
 // utils
 // -------------------------------------------------------------------------------------
+/**
+ * An empty `string`.
+ *
+ * @since 2.10.0
+ */
+export var empty = '';
 /**
  * Test whether a `string` is empty.
  *
diff --git a/node_modules/fp-ts/lib/Array.d.ts b/node_modules/fp-ts/lib/Array.d.ts
index 6cac9bf..993334c 100644
--- a/node_modules/fp-ts/lib/Array.d.ts
+++ b/node_modules/fp-ts/lib/Array.d.ts
@@ -2096,10 +2096,7 @@ export declare const unsafeDeleteAt: <A>(i: number, as: A[]) => A[]
  *
  * @since 2.9.0
  */
-export declare const every: {
-  <A, B extends A>(refinement: Refinement<A, B>): Refinement<Array<A>, Array<B>>
-  <A>(predicate: Predicate<A>): Predicate<Array<A>>
-}
+export declare const every: <A>(predicate: Predicate<A>) => (as: Array<A>) => boolean
 /**
  * `some` tells if the provided predicate holds true at least for one element in the `Array`.
  *
@@ -2118,18 +2115,6 @@ export declare const some: <A>(predicate: Predicate<A>) => (as: A[]) => as is NE
  * @since 2.11.0
  */
 export declare const exists: <A>(predicate: Predicate<A>) => (as: A[]) => as is NEA.NonEmptyArray<A>
-/**
- * Places an element in between members of an `Array`, then folds the results using the provided `Monoid`.
- *
- * @example
- * import * as S from 'fp-ts/string'
- * import { intercalate } from 'fp-ts/Array'
- *
- * assert.deepStrictEqual(intercalate(S.Monoid)('-')(['a', 'b', 'c']), 'a-b-c')
- *
- * @since 2.12.0
- */
-export declare const intercalate: <A>(M: Monoid<A>) => (middle: A) => (as: Array<A>) => A
 /**
  * @since 2.9.0
  */
diff --git a/node_modules/fp-ts/lib/Array.js b/node_modules/fp-ts/lib/Array.js
index 1576e42..9fdc3df 100644
--- a/node_modules/fp-ts/lib/Array.js
+++ b/node_modules/fp-ts/lib/Array.js
@@ -22,7 +22,7 @@ Object.defineProperty(exports, "__esModule", { value: true });
 exports.lefts = exports.rights = exports.reverse = exports.modifyAt = exports.deleteAt = exports.updateAt = exports.insertAt = exports.copy = exports.findLastIndex = exports.findLastMap = exports.findLast = exports.findFirstMap = exports.findFirst = exports.findIndex = exports.dropLeftWhile = exports.dropRight = exports.dropLeft = exports.spanLeft = exports.takeLeftWhile = exports.takeRight = exports.takeLeft = exports.init = exports.tail = exports.last = exports.head = exports.lookup = exports.isOutOfBound = exports.size = exports.scanRight = exports.scanLeft = exports.chainWithIndex = exports.foldRight = exports.matchRight = exports.matchRightW = exports.foldLeft = exports.matchLeft = exports.matchLeftW = exports.match = exports.matchW = exports.fromEither = exports.fromOption = exports.fromPredicate = exports.replicate = exports.makeBy = exports.appendW = exports.append = exports.prependW = exports.prepend = exports.isNonEmpty = exports.isEmpty = void 0;
 exports.traverseWithIndex = exports.sequence = exports.traverse = exports.reduceRightWithIndex = exports.reduceRight = exports.reduceWithIndex = exports.reduce = exports.foldMapWithIndex = exports.foldMap = exports.duplicate = exports.extend = exports.filterWithIndex = exports.alt = exports.altW = exports.partitionMapWithIndex = exports.partitionMap = exports.partitionWithIndex = exports.partition = exports.filter = exports.separate = exports.compact = exports.filterMap = exports.filterMapWithIndex = exports.mapWithIndex = exports.flatten = exports.chain = exports.ap = exports.map = exports.zero = exports.of = exports.difference = exports.intersection = exports.union = exports.concat = exports.concatW = exports.comprehension = exports.fromOptionK = exports.chunksOf = exports.splitAt = exports.chop = exports.sortBy = exports.uniq = exports.elem = exports.rotate = exports.intersperse = exports.prependAll = exports.unzip = exports.zip = exports.zipWith = exports.sort = void 0;
 exports.some = exports.every = exports.unsafeDeleteAt = exports.unsafeUpdateAt = exports.unsafeInsertAt = exports.fromEitherK = exports.FromEither = exports.filterE = exports.ChainRecBreadthFirst = exports.chainRecBreadthFirst = exports.ChainRecDepthFirst = exports.chainRecDepthFirst = exports.Witherable = exports.TraversableWithIndex = exports.Traversable = exports.FoldableWithIndex = exports.Foldable = exports.FilterableWithIndex = exports.Filterable = exports.Compactable = exports.Extend = exports.Alternative = exports.guard = exports.Zero = exports.Alt = exports.Unfoldable = exports.Monad = exports.chainFirst = exports.Chain = exports.Applicative = exports.apSecond = exports.apFirst = exports.Apply = exports.FunctorWithIndex = exports.Pointed = exports.flap = exports.Functor = exports.getDifferenceMagma = exports.getIntersectionSemigroup = exports.getUnionMonoid = exports.getUnionSemigroup = exports.getOrd = exports.getEq = exports.getMonoid = exports.getSemigroup = exports.getShow = exports.URI = exports.unfold = exports.wilt = exports.wither = void 0;
-exports.array = exports.prependToAll = exports.snoc = exports.cons = exports.empty = exports.range = exports.apS = exports.bind = exports.bindTo = exports.Do = exports.intercalate = exports.exists = void 0;
+exports.array = exports.prependToAll = exports.snoc = exports.cons = exports.empty = exports.range = exports.apS = exports.bind = exports.bindTo = exports.Do = exports.exists = void 0;
 var Apply_1 = require("./Apply");
 var Chain_1 = require("./Chain");
 var FromEither_1 = require("./FromEither");
@@ -2471,18 +2471,6 @@ exports.some = some;
  * @since 2.11.0
  */
 exports.exists = exports.some;
-/**
- * Places an element in between members of an `Array`, then folds the results using the provided `Monoid`.
- *
- * @example
- * import * as S from 'fp-ts/string'
- * import { intercalate } from 'fp-ts/Array'
- *
- * assert.deepStrictEqual(intercalate(S.Monoid)('-')(['a', 'b', 'c']), 'a-b-c')
- *
- * @since 2.12.0
- */
-exports.intercalate = RA.intercalate;
 // -------------------------------------------------------------------------------------
 // do notation
 // -------------------------------------------------------------------------------------
diff --git a/node_modules/fp-ts/lib/Bounded.d.ts b/node_modules/fp-ts/lib/Bounded.d.ts
index 19916bf..5b13290 100644
--- a/node_modules/fp-ts/lib/Bounded.d.ts
+++ b/node_modules/fp-ts/lib/Bounded.d.ts
@@ -7,8 +7,7 @@
  *
  * @since 2.0.0
  */
-import * as O from './Ord'
-import Ord = O.Ord
+import { Ord } from './Ord'
 /**
  * @category type classes
  * @since 2.0.0
@@ -17,20 +16,6 @@ export interface Bounded<A> extends Ord<A> {
   readonly top: A
   readonly bottom: A
 }
-/**
- * Clamp a value between bottom and top values.
- *
- * @category utils
- * @since 2.12.0
- */
-export declare const clamp: <T>(B: Bounded<T>) => (a: T) => T
-/**
- * Reverses the Ord of a bound and swaps top and bottom values.
- *
- * @category utils
- * @since 2.12.0
- */
-export declare const reverse: <T>(B: Bounded<T>) => Bounded<T>
 /**
  * Use [`Bounded`](./number.ts.html#bounded) instead.
  *
diff --git a/node_modules/fp-ts/lib/Bounded.js b/node_modules/fp-ts/lib/Bounded.js
index 9a126bb..89e30d1 100644
--- a/node_modules/fp-ts/lib/Bounded.js
+++ b/node_modules/fp-ts/lib/Bounded.js
@@ -1,25 +1,6 @@
 "use strict";
-var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
-    if (k2 === undefined) k2 = k;
-    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
-}) : (function(o, m, k, k2) {
-    if (k2 === undefined) k2 = k;
-    o[k2] = m[k];
-}));
-var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
-    Object.defineProperty(o, "default", { enumerable: true, value: v });
-}) : function(o, v) {
-    o["default"] = v;
-});
-var __importStar = (this && this.__importStar) || function (mod) {
-    if (mod && mod.__esModule) return mod;
-    var result = {};
-    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
-    __setModuleDefault(result, mod);
-    return result;
-};
 Object.defineProperty(exports, "__esModule", { value: true });
-exports.boundedNumber = exports.reverse = exports.clamp = void 0;
+exports.boundedNumber = void 0;
 /**
  * The `Bounded` type class represents totally ordered types that have an upper and lower boundary.
  *
@@ -29,34 +10,7 @@ exports.boundedNumber = exports.reverse = exports.clamp = void 0;
  *
  * @since 2.0.0
  */
-var O = __importStar(require("./Ord"));
-// -------------------------------------------------------------------------------------
-// utils
-// -------------------------------------------------------------------------------------
-/**
- * Clamp a value between bottom and top values.
- *
- * @category utils
- * @since 2.12.0
- */
-var clamp = function (B) { return O.clamp(B)(B.bottom, B.top); };
-exports.clamp = clamp;
-/**
- * Reverses the Ord of a bound and swaps top and bottom values.
- *
- * @category utils
- * @since 2.12.0
- */
-var reverse = function (B) {
-    var R = O.reverse(B);
-    return {
-        equals: R.equals,
-        compare: R.compare,
-        top: B.bottom,
-        bottom: B.top
-    };
-};
-exports.reverse = reverse;
+var Ord_1 = require("./Ord");
 // -------------------------------------------------------------------------------------
 // deprecated
 // -------------------------------------------------------------------------------------
@@ -69,8 +23,8 @@ exports.reverse = reverse;
  * @deprecated
  */
 exports.boundedNumber = {
-    equals: O.ordNumber.equals,
-    compare: O.ordNumber.compare,
+    equals: Ord_1.ordNumber.equals,
+    compare: Ord_1.ordNumber.compare,
     top: Infinity,
     bottom: -Infinity
 };
diff --git a/node_modules/fp-ts/lib/Either.d.ts b/node_modules/fp-ts/lib/Either.d.ts
index 9b3ec39..a783413 100644
--- a/node_modules/fp-ts/lib/Either.d.ts
+++ b/node_modules/fp-ts/lib/Either.d.ts
@@ -593,13 +593,6 @@ export declare const flap: <A>(a: A) => <E, B>(fab: Either<E, (a: A) => B>) => E
  * @since 2.0.0
  */
 export declare const apFirst: <E, B>(second: Either<E, B>) => <A>(first: Either<E, A>) => Either<E, A>
-/**
- * Less strict version of [`apFirst`](#apfirst)
- *
- * @category combinators
- * @since 2.12.0
- */
-export declare const apFirstW: <E2, A, B>(second: Either<E2, B>) => <E1>(first: Either<E1, A>) => Either<E1 | E2, A>
 /**
  * Combine two effectful actions, keeping only the result of the second.
  *
@@ -609,13 +602,6 @@ export declare const apFirstW: <E2, A, B>(second: Either<E2, B>) => <E1>(first:
  * @since 2.0.0
  */
 export declare const apSecond: <E, B>(second: Either<E, B>) => <A>(first: Either<E, A>) => Either<E, B>
-/**
- * Less strict version of [`apSecond`](#apsecond)
- *
- * @category combinators
- * @since 2.12.0
- */
-export declare const apSecondW: <E2, A, B>(second: Either<E2, B>) => <E1>(first: Either<E1, A>) => Either<E1 | E2, B>
 /**
  * Composes computations in sequence, using the return value of one computation to determine the next computation and
  * keeping only the result of the first.
diff --git a/node_modules/fp-ts/lib/Either.js b/node_modules/fp-ts/lib/Either.js
index dcf7ee7..43d64f0 100644
--- a/node_modules/fp-ts/lib/Either.js
+++ b/node_modules/fp-ts/lib/Either.js
@@ -20,7 +20,7 @@ var __importStar = (this && this.__importStar) || function (mod) {
 };
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.fold = exports.match = exports.foldW = exports.matchW = exports.isRight = exports.isLeft = exports.fromOption = exports.fromPredicate = exports.FromEither = exports.MonadThrow = exports.throwError = exports.ChainRec = exports.Extend = exports.extend = exports.Alt = exports.alt = exports.altW = exports.Bifunctor = exports.mapLeft = exports.bimap = exports.Traversable = exports.sequence = exports.traverse = exports.Foldable = exports.reduceRight = exports.foldMap = exports.reduce = exports.Monad = exports.Chain = exports.chain = exports.chainW = exports.Applicative = exports.Apply = exports.ap = exports.apW = exports.Pointed = exports.of = exports.Functor = exports.map = exports.getAltValidation = exports.getApplicativeValidation = exports.getWitherable = exports.getFilterable = exports.getCompactable = exports.getSemigroup = exports.getEq = exports.getShow = exports.URI = exports.right = exports.left = void 0;
-exports.getValidation = exports.getValidationMonoid = exports.getValidationSemigroup = exports.getApplyMonoid = exports.getApplySemigroup = exports.either = exports.stringifyJSON = exports.parseJSON = exports.sequenceArray = exports.traverseArray = exports.traverseArrayWithIndex = exports.traverseReadonlyArrayWithIndex = exports.traverseReadonlyNonEmptyArrayWithIndex = exports.ApT = exports.apSW = exports.apS = exports.bindW = exports.bind = exports.bindTo = exports.Do = exports.exists = exports.elem = exports.toError = exports.toUnion = exports.chainNullableK = exports.fromNullableK = exports.tryCatchK = exports.tryCatch = exports.fromNullable = exports.orElse = exports.orElseW = exports.swap = exports.filterOrElseW = exports.filterOrElse = exports.chainOptionK = exports.fromOptionK = exports.duplicate = exports.flatten = exports.flattenW = exports.chainFirstW = exports.chainFirst = exports.apSecondW = exports.apSecond = exports.apFirstW = exports.apFirst = exports.flap = exports.getOrElse = exports.getOrElseW = void 0;
+exports.getValidation = exports.getValidationMonoid = exports.getValidationSemigroup = exports.getApplyMonoid = exports.getApplySemigroup = exports.either = exports.stringifyJSON = exports.parseJSON = exports.sequenceArray = exports.traverseArray = exports.traverseArrayWithIndex = exports.traverseReadonlyArrayWithIndex = exports.traverseReadonlyNonEmptyArrayWithIndex = exports.ApT = exports.apSW = exports.apS = exports.bindW = exports.bind = exports.bindTo = exports.Do = exports.exists = exports.elem = exports.toError = exports.toUnion = exports.chainNullableK = exports.fromNullableK = exports.tryCatchK = exports.tryCatch = exports.fromNullable = exports.orElse = exports.orElseW = exports.swap = exports.filterOrElseW = exports.filterOrElse = exports.chainOptionK = exports.fromOptionK = exports.duplicate = exports.flatten = exports.flattenW = exports.chainFirstW = exports.chainFirst = exports.apSecond = exports.apFirst = exports.flap = exports.getOrElse = exports.getOrElseW = void 0;
 var Applicative_1 = require("./Applicative");
 var Apply_1 = require("./Apply");
 var Chain_1 = require("./Chain");
@@ -819,13 +819,6 @@ Functor_1.flap(exports.Functor);
 exports.apFirst = 
 /*#__PURE__*/
 Apply_1.apFirst(exports.Apply);
-/**
- * Less strict version of [`apFirst`](#apfirst)
- *
- * @category combinators
- * @since 2.12.0
- */
-exports.apFirstW = exports.apFirst;
 /**
  * Combine two effectful actions, keeping only the result of the second.
  *
@@ -837,13 +830,6 @@ exports.apFirstW = exports.apFirst;
 exports.apSecond = 
 /*#__PURE__*/
 Apply_1.apSecond(exports.Apply);
-/**
- * Less strict version of [`apSecond`](#apsecond)
- *
- * @category combinators
- * @since 2.12.0
- */
-exports.apSecondW = exports.apSecond;
 /**
  * Composes computations in sequence, using the return value of one computation to determine the next computation and
  * keeping only the result of the first.
diff --git a/node_modules/fp-ts/lib/EitherT.d.ts b/node_modules/fp-ts/lib/EitherT.d.ts
index 27eb1a9..1e9fa0b 100644
--- a/node_modules/fp-ts/lib/EitherT.d.ts
+++ b/node_modules/fp-ts/lib/EitherT.d.ts
@@ -76,111 +76,6 @@ export declare function leftF<F extends URIS2, FE>(
 ): <E, A = never>(fe: Kind2<F, FE, E>) => Kind2<F, FE, Either<E, A>>
 export declare function leftF<F extends URIS>(F: Functor1<F>): <E, A = never>(fe: Kind<F, E>) => Kind<F, Either<E, A>>
 export declare function leftF<F>(F: Functor<F>): <E, A = never>(fe: HKT<F, E>) => HKT<F, Either<E, A>>
-/**
- * @since 2.12.0
- */
-export declare function fromNullable<F extends URIS3>(
-  F: Pointed3<F>
-): <E>(e: E) => <A, S, R>(a: A) => Kind3<F, S, R, Either<E, NonNullable<A>>>
-export declare function fromNullable<F extends URIS3, R>(
-  F: Pointed3C<F, R>
-): <E>(e: E) => <A, S>(a: A) => Kind3<F, S, R, Either<E, NonNullable<A>>>
-export declare function fromNullable<F extends URIS2>(
-  F: Pointed2<F>
-): <E>(e: E) => <A, R>(a: A) => Kind2<F, R, Either<E, NonNullable<A>>>
-export declare function fromNullable<F extends URIS2, R>(
-  F: Pointed2C<F, R>
-): <E>(e: E) => <A>(a: A) => Kind2<F, R, Either<E, NonNullable<A>>>
-export declare function fromNullable<F extends URIS>(
-  F: Pointed1<F>
-): <E>(e: E) => <A>(a: A) => Kind<F, Either<E, NonNullable<A>>>
-export declare function fromNullable<F>(F: Pointed<F>): <E>(e: E) => <A>(a: A) => HKT<F, Either<E, NonNullable<A>>>
-/**
- * @since 2.12.0
- */
-export declare function fromNullableK<F extends URIS3>(
-  F: Pointed3<F>
-): <E>(
-  e: E
-) => <A extends ReadonlyArray<unknown>, B>(
-  f: (...a: A) => B | null | undefined
-) => <S, R>(...a: A) => Kind3<F, S, R, Either<E, NonNullable<B>>>
-export declare function fromNullableK<F extends URIS3, R>(
-  F: Pointed3C<F, R>
-): <E>(
-  e: E
-) => <A extends ReadonlyArray<unknown>, B>(
-  f: (...a: A) => B | null | undefined
-) => <S>(...a: A) => Kind3<F, S, R, Either<E, NonNullable<B>>>
-export declare function fromNullableK<F extends URIS2>(
-  F: Pointed2<F>
-): <E>(
-  e: E
-) => <A extends ReadonlyArray<unknown>, B>(
-  f: (...a: A) => B | null | undefined
-) => <R>(...a: A) => Kind2<F, R, Either<E, NonNullable<B>>>
-export declare function fromNullableK<F extends URIS2, R>(
-  F: Pointed2C<F, R>
-): <E>(
-  e: E
-) => <A extends ReadonlyArray<unknown>, B>(
-  f: (...a: A) => B | null | undefined
-) => (...a: A) => Kind2<F, R, Either<E, NonNullable<B>>>
-export declare function fromNullableK<F extends URIS>(
-  F: Pointed1<F>
-): <E>(
-  e: E
-) => <A extends ReadonlyArray<unknown>, B>(
-  f: (...a: A) => B | null | undefined
-) => (...a: A) => Kind<F, Either<E, NonNullable<B>>>
-export declare function fromNullableK<F>(
-  F: Pointed<F>
-): <E>(
-  e: E
-) => <A extends ReadonlyArray<unknown>, B>(
-  f: (...a: A) => B | null | undefined
-) => (...a: A) => HKT<F, Either<E, NonNullable<B>>>
-/**
- * @since 2.12.0
- */
-export declare function chainNullableK<M extends URIS3>(
-  M: Monad3<M>
-): <E>(
-  e: E
-) => <A, B>(
-  f: (a: A) => B | null | undefined
-) => <S, R>(ma: Kind3<M, S, R, Either<E, A>>) => Kind3<M, S, R, Either<E, NonNullable<B>>>
-export declare function chainNullableK<M extends URIS3, R>(
-  M: Monad3C<M, R>
-): <E>(
-  e: E
-) => <A, B>(
-  f: (a: A) => B | null | undefined
-) => <S>(ma: Kind3<M, S, R, Either<E, A>>) => Kind3<M, S, R, Either<E, NonNullable<B>>>
-export declare function chainNullableK<M extends URIS2>(
-  M: Monad2<M>
-): <E>(
-  e: E
-) => <A, B>(
-  f: (a: A) => B | null | undefined
-) => <R>(ma: Kind2<M, R, Either<E, A>>) => Kind2<M, R, Either<E, NonNullable<B>>>
-export declare function chainNullableK<M extends URIS2, T>(
-  M: Monad2C<M, T>
-): <E>(
-  e: E
-) => <A, B>(
-  f: (a: A) => B | null | undefined
-) => (ma: Kind2<M, T, Either<E, A>>) => Kind2<M, T, Either<E, NonNullable<B>>>
-export declare function chainNullableK<M extends URIS>(
-  M: Monad1<M>
-): <E>(
-  e: E
-) => <A, B>(f: (a: A) => B | null | undefined) => (ma: Kind<M, Either<E, A>>) => Kind<M, Either<E, NonNullable<B>>>
-export declare function chainNullableK<M>(
-  M: Monad<M>
-): <E>(
-  e: E
-) => <A, B>(f: (a: A) => B | null | undefined) => (ma: HKT<M, Either<E, A>>) => HKT<M, Either<E, NonNullable<B>>>
 /**
  * @since 2.10.0
  */
diff --git a/node_modules/fp-ts/lib/EitherT.js b/node_modules/fp-ts/lib/EitherT.js
index 0454966..e54d1c5 100644
--- a/node_modules/fp-ts/lib/EitherT.js
+++ b/node_modules/fp-ts/lib/EitherT.js
@@ -19,7 +19,7 @@ var __importStar = (this && this.__importStar) || function (mod) {
     return result;
 };
 Object.defineProperty(exports, "__esModule", { value: true });
-exports.getEitherM = exports.toUnion = exports.swap = exports.orLeft = exports.orElseFirst = exports.orElse = exports.getOrElse = exports.matchE = exports.match = exports.altValidation = exports.mapLeft = exports.bimap = exports.alt = exports.chain = exports.ap = exports.map = exports.chainNullableK = exports.fromNullableK = exports.fromNullable = exports.leftF = exports.rightF = exports.left = exports.right = void 0;
+exports.getEitherM = exports.toUnion = exports.swap = exports.orLeft = exports.orElseFirst = exports.orElse = exports.getOrElse = exports.matchE = exports.match = exports.altValidation = exports.mapLeft = exports.bimap = exports.alt = exports.chain = exports.ap = exports.map = exports.leftF = exports.rightF = exports.left = exports.right = void 0;
 var Apply_1 = require("./Apply");
 var E = __importStar(require("./Either"));
 var function_1 = require("./function");
@@ -40,27 +40,6 @@ function leftF(F) {
     return function (fe) { return F.map(fe, E.left); };
 }
 exports.leftF = leftF;
-function fromNullable(F) {
-    return function (e) { return function_1.flow(E.fromNullable(e), F.of); };
-}
-exports.fromNullable = fromNullable;
-function fromNullableK(F) {
-    var fromNullableF = fromNullable(F);
-    return function (e) {
-        var fromNullableFE = fromNullableF(e);
-        return function (f) { return function_1.flow(f, fromNullableFE); };
-    };
-}
-exports.fromNullableK = fromNullableK;
-function chainNullableK(M) {
-    var chainM = chain(M);
-    var fromNullableKM = fromNullableK(M);
-    return function (e) {
-        var fromNullableKMe = fromNullableKM(e);
-        return function (f) { return chainM(fromNullableKMe(f)); };
-    };
-}
-exports.chainNullableK = chainNullableK;
 function map(F) {
     return Functor_1.map(F, E.Functor);
 }
diff --git a/node_modules/fp-ts/lib/Foldable.d.ts b/node_modules/fp-ts/lib/Foldable.d.ts
index 152429a..19fdcfe 100644
--- a/node_modules/fp-ts/lib/Foldable.d.ts
+++ b/node_modules/fp-ts/lib/Foldable.d.ts
@@ -175,17 +175,17 @@ export declare function reduceM<M, F>(
 export declare function intercalate<M, F extends URIS3>(
   M: Monoid<M>,
   F: Foldable3<F>
-): <R, E>(middle: M, fm: Kind3<F, R, E, M>) => M
+): <R, E>(sep: M, fm: Kind3<F, R, E, M>) => M
 export declare function intercalate<M, F extends URIS2>(
   M: Monoid<M>,
   F: Foldable2<F>
-): <E>(middle: M, fm: Kind2<F, E, M>) => M
+): <E>(sep: M, fm: Kind2<F, E, M>) => M
 export declare function intercalate<M, F extends URIS2, E>(
   M: Monoid<M>,
   F: Foldable2C<F, E>
-): (middle: M, fm: Kind2<F, E, M>) => M
-export declare function intercalate<M, F extends URIS>(M: Monoid<M>, F: Foldable1<F>): (middle: M, fm: Kind<F, M>) => M
-export declare function intercalate<M, F>(M: Monoid<M>, F: Foldable<F>): (middle: M, fm: HKT<F, M>) => M
+): (sep: M, fm: Kind2<F, E, M>) => M
+export declare function intercalate<M, F extends URIS>(M: Monoid<M>, F: Foldable1<F>): (sep: M, fm: Kind<F, M>) => M
+export declare function intercalate<M, F>(M: Monoid<M>, F: Foldable<F>): (sep: M, fm: HKT<F, M>) => M
 /**
  * Transforms a `Foldable` into a `toReadonlyArray`.
  *
diff --git a/node_modules/fp-ts/lib/Foldable.js b/node_modules/fp-ts/lib/Foldable.js
index c73cc08..08f2458 100644
--- a/node_modules/fp-ts/lib/Foldable.js
+++ b/node_modules/fp-ts/lib/Foldable.js
@@ -23,10 +23,10 @@ function reduceM(M, F) {
 }
 exports.reduceM = reduceM;
 function intercalate(M, F) {
-    return function (middle, fm) {
+    return function (sep, fm) {
         var go = function (_a, x) {
             var init = _a.init, acc = _a.acc;
-            return init ? { init: false, acc: x } : { init: false, acc: M.concat(M.concat(acc, middle), x) };
+            return init ? { init: false, acc: x } : { init: false, acc: M.concat(M.concat(acc, sep), x) };
         };
         return F.reduce(fm, { init: true, acc: M.empty }, go).acc;
     };
diff --git a/node_modules/fp-ts/lib/FromEither.d.ts b/node_modules/fp-ts/lib/FromEither.d.ts
index 5bf4394..64ee53f 100644
--- a/node_modules/fp-ts/lib/FromEither.d.ts
+++ b/node_modules/fp-ts/lib/FromEither.d.ts
@@ -262,38 +262,6 @@ export declare function chainEitherK<M>(
   F: FromEither<M>,
   M: Chain<M>
 ): <A, E, B>(f: (a: A) => Either<E, B>) => (ma: HKT2<M, E, A>) => HKT2<M, E, B>
-/**
- * @category combinators
- * @since 2.12.0
- */
-export declare function chainFirstEitherK<M extends URIS4>(
-  F: FromEither4<M>,
-  M: Chain4<M>
-): <A, E, B>(f: (a: A) => Either<E, B>) => <S, R>(ma: Kind4<M, S, R, E, A>) => Kind4<M, S, R, E, A>
-export declare function chainFirstEitherK<M extends URIS3>(
-  F: FromEither3<M>,
-  M: Chain3<M>
-): <A, E, B>(f: (a: A) => Either<E, B>) => <R>(ma: Kind3<M, R, E, A>) => Kind3<M, R, E, A>
-export declare function chainFirstEitherK<M extends URIS3, E>(
-  F: FromEither3C<M, E>,
-  M: Chain3C<M, E>
-): <A, B>(f: (a: A) => Either<E, B>) => <R>(ma: Kind3<M, R, E, A>) => Kind3<M, R, E, A>
-export declare function chainFirstEitherK<M extends URIS2>(
-  F: FromEither2<M>,
-  M: Chain2<M>
-): <A, E, B>(f: (a: A) => Either<E, B>) => (ma: Kind2<M, E, A>) => Kind2<M, E, A>
-export declare function chainFirstEitherK<M extends URIS2, E>(
-  F: FromEither2C<M, E>,
-  M: Chain2C<M, E>
-): <A, B>(f: (a: A) => Either<E, B>) => (ma: Kind2<M, E, A>) => Kind2<M, E, A>
-export declare function chainFirstEitherK<M extends URIS>(
-  F: FromEither1<M>,
-  M: Chain1<M>
-): <E, A, B>(f: (a: A) => Either<E, B>) => (ma: Kind<M, A>) => Kind<M, A>
-export declare function chainFirstEitherK<M>(
-  F: FromEither<M>,
-  M: Chain<M>
-): <A, E, B>(f: (a: A) => Either<E, B>) => (ma: HKT2<M, E, A>) => HKT2<M, E, A>
 /**
  * @category combinators
  * @since 2.10.0
diff --git a/node_modules/fp-ts/lib/FromEither.js b/node_modules/fp-ts/lib/FromEither.js
index bba137f..8c7764c 100644
--- a/node_modules/fp-ts/lib/FromEither.js
+++ b/node_modules/fp-ts/lib/FromEither.js
@@ -24,8 +24,7 @@ var __importStar = (this && this.__importStar) || function (mod) {
     return result;
 };
 Object.defineProperty(exports, "__esModule", { value: true });
-exports.filterOrElse = exports.chainFirstEitherK = exports.chainEitherK = exports.fromEitherK = exports.chainOptionK = exports.fromOptionK = exports.fromPredicate = exports.fromOption = void 0;
-var Chain_1 = require("./Chain");
+exports.filterOrElse = exports.chainEitherK = exports.fromEitherK = exports.chainOptionK = exports.fromOptionK = exports.fromPredicate = exports.fromOption = void 0;
 var function_1 = require("./function");
 var _ = __importStar(require("./internal"));
 function fromOption(F) {
@@ -63,10 +62,6 @@ function chainEitherK(F, M) {
     return function (f) { return function (ma) { return M.chain(ma, fromEitherKF(f)); }; };
 }
 exports.chainEitherK = chainEitherK;
-function chainFirstEitherK(F, M) {
-    return function_1.flow(fromEitherK(F), Chain_1.chainFirst(M));
-}
-exports.chainFirstEitherK = chainFirstEitherK;
 function filterOrElse(F, M) {
     return function (predicate, onFalse) { return function (ma) {
         return M.chain(ma, function (a) { return F.fromEither(predicate(a) ? _.right(a) : _.left(onFalse(a))); });
diff --git a/node_modules/fp-ts/lib/IOEither.d.ts b/node_modules/fp-ts/lib/IOEither.d.ts
index 8621fec..536715b 100644
--- a/node_modules/fp-ts/lib/IOEither.d.ts
+++ b/node_modules/fp-ts/lib/IOEither.d.ts
@@ -178,11 +178,6 @@ export declare const orElseFirst: <E, B>(onLeft: (e: E) => IOEither<E, B>) => <A
 export declare const orElseFirstW: <E1, E2, B>(
   onLeft: (e: E1) => IOEither<E2, B>
 ) => <A>(ma: IOEither<E1, A>) => IOEither<E1 | E2, A>
-/**
- * @category combinators
- * @since 2.12.0
- */
-export declare const orElseFirstIOK: <E, B>(onLeft: (e: E) => IO<B>) => <A>(ma: IOEither<E, A>) => IOEither<E, A>
 /**
  * @category combinators
  * @since 2.11.0
@@ -357,15 +352,6 @@ export declare const ApplyPar: Apply2<URI>
  * @since 2.0.0
  */
 export declare const apFirst: <E, B>(second: IOEither<E, B>) => <A>(first: IOEither<E, A>) => IOEither<E, A>
-/**
- * Less strict version of [`apFirst`](#apfirst).
- *
- * @category combinators
- * @since 2.12.0
- */
-export declare const apFirstW: <E2, A, B>(
-  second: IOEither<E2, B>
-) => <E1>(first: IOEither<E1, A>) => IOEither<E1 | E2, A>
 /**
  * Combine two effectful actions, keeping only the result of the second.
  *
@@ -375,15 +361,6 @@ export declare const apFirstW: <E2, A, B>(
  * @since 2.0.0
  */
 export declare const apSecond: <E, B>(second: IOEither<E, B>) => <A>(first: IOEither<E, A>) => IOEither<E, B>
-/**
- * Less strict version of [`apSecond`](#apsecond).
- *
- * @category combinators
- * @since 2.12.0
- */
-export declare const apSecondW: <E2, A, B>(
-  second: IOEither<E2, B>
-) => <E1>(first: IOEither<E1, A>) => IOEither<E1 | E2, B>
 /**
  * @category instances
  * @since 2.8.4
@@ -502,18 +479,6 @@ export declare const chainEitherK: <E, A, B>(f: (a: A) => E.Either<E, B>) => (ma
 export declare const chainEitherKW: <E2, A, B>(
   f: (a: A) => Either<E2, B>
 ) => <E1>(ma: IOEither<E1, A>) => IOEither<E1 | E2, B>
-/**
- * @category combinators
- * @since 2.12.0
- */
-export declare const chainFirstEitherK: <A, E, B>(f: (a: A) => E.Either<E, B>) => (ma: IOEither<E, A>) => IOEither<E, A>
-/**
- * @category combinators
- * @since 2.12.0
- */
-export declare const chainFirstEitherKW: <A, E2, B>(
-  f: (a: A) => E.Either<E2, B>
-) => <E1>(ma: IOEither<E1, A>) => IOEither<E1 | E2, A>
 /**
  * @category constructors
  * @since 2.0.0
@@ -567,16 +532,6 @@ export declare const bracket: <E, A, B>(
   use: (a: A) => IOEither<E, B>,
   release: (a: A, e: E.Either<E, B>) => IOEither<E, void>
 ) => IOEither<E, B>
-/**
- * Less strict version of [`bracket`](#bracket).
- *
- * @since 2.12.0
- */
-export declare const bracketW: <E1, A, E2, B, E3>(
-  acquire: IOEither<E1, A>,
-  use: (a: A) => IOEither<E2, B>,
-  release: (a: A, e: E.Either<E2, B>) => IOEither<E3, void>
-) => IOEither<E1 | E2 | E3, B>
 /**
  * @since 2.9.0
  */
diff --git a/node_modules/fp-ts/lib/IOEither.js b/node_modules/fp-ts/lib/IOEither.js
index fab3657..c66ae7a 100644
--- a/node_modules/fp-ts/lib/IOEither.js
+++ b/node_modules/fp-ts/lib/IOEither.js
@@ -19,9 +19,8 @@ var __importStar = (this && this.__importStar) || function (mod) {
     return result;
 };
 Object.defineProperty(exports, "__esModule", { value: true });
-exports.apSecond = exports.apFirstW = exports.apFirst = exports.ApplyPar = exports.Bifunctor = exports.Pointed = exports.flap = exports.Functor = exports.getFilterable = exports.getCompactable = exports.getAltIOValidation = exports.getApplicativeIOValidation = exports.URI = exports.throwError = exports.altW = exports.alt = exports.flatten = exports.flattenW = exports.chainW = exports.chain = exports.of = exports.apW = exports.ap = exports.mapLeft = exports.bimap = exports.map = exports.swap = exports.orLeft = exports.orElseFirstIOK = exports.orElseFirstW = exports.orElseFirst = exports.orElseW = exports.orElse = exports.toUnion = exports.tryCatchK = exports.tryCatch = exports.getOrElseW = exports.getOrElse = exports.foldW = exports.matchEW = exports.fold = exports.matchE = exports.matchW = exports.match = exports.fromIO = exports.fromEither = exports.leftIO = exports.rightIO = exports.right = exports.left = void 0;
-exports.getSemigroup = exports.getApplyMonoid = exports.getApplySemigroup = exports.ioEither = exports.Applicative = exports.sequenceSeqArray = exports.traverseSeqArray = exports.traverseSeqArrayWithIndex = exports.sequenceArray = exports.traverseArray = exports.traverseArrayWithIndex = exports.traverseReadonlyArrayWithIndexSeq = exports.traverseReadonlyNonEmptyArrayWithIndexSeq = exports.traverseReadonlyArrayWithIndex = exports.traverseReadonlyNonEmptyArrayWithIndex = exports.ApT = exports.apSW = exports.apS = exports.bindW = exports.bind = exports.bindTo = exports.Do = exports.bracketW = exports.bracket = exports.fromEitherK = exports.filterOrElseW = exports.filterOrElse = exports.fromPredicate = exports.chainFirstEitherKW = exports.chainFirstEitherK = exports.chainEitherKW = exports.chainEitherK = exports.chainOptionK = exports.fromOptionK = exports.fromOption = exports.FromEither = exports.chainFirstIOK = exports.chainIOK = exports.fromIOK = exports.FromIO = exports.MonadThrow = exports.MonadIO = exports.Alt = exports.chainFirstW = exports.chainFirst = exports.Monad = exports.Chain = exports.ApplicativeSeq = exports.ApplicativePar = exports.apSecondW = void 0;
-exports.getIOValidation = void 0;
+exports.ApplicativeSeq = exports.ApplicativePar = exports.apSecond = exports.apFirst = exports.ApplyPar = exports.Bifunctor = exports.Pointed = exports.flap = exports.Functor = exports.getFilterable = exports.getCompactable = exports.getAltIOValidation = exports.getApplicativeIOValidation = exports.URI = exports.throwError = exports.altW = exports.alt = exports.flatten = exports.flattenW = exports.chainW = exports.chain = exports.of = exports.apW = exports.ap = exports.mapLeft = exports.bimap = exports.map = exports.swap = exports.orLeft = exports.orElseFirstW = exports.orElseFirst = exports.orElseW = exports.orElse = exports.toUnion = exports.tryCatchK = exports.tryCatch = exports.getOrElseW = exports.getOrElse = exports.foldW = exports.matchEW = exports.fold = exports.matchE = exports.matchW = exports.match = exports.fromIO = exports.fromEither = exports.leftIO = exports.rightIO = exports.right = exports.left = void 0;
+exports.getIOValidation = exports.getSemigroup = exports.getApplyMonoid = exports.getApplySemigroup = exports.ioEither = exports.Applicative = exports.sequenceSeqArray = exports.traverseSeqArray = exports.traverseSeqArrayWithIndex = exports.sequenceArray = exports.traverseArray = exports.traverseArrayWithIndex = exports.traverseReadonlyArrayWithIndexSeq = exports.traverseReadonlyNonEmptyArrayWithIndexSeq = exports.traverseReadonlyArrayWithIndex = exports.traverseReadonlyNonEmptyArrayWithIndex = exports.ApT = exports.apSW = exports.apS = exports.bindW = exports.bind = exports.bindTo = exports.Do = exports.bracket = exports.fromEitherK = exports.filterOrElseW = exports.filterOrElse = exports.fromPredicate = exports.chainEitherKW = exports.chainEitherK = exports.chainOptionK = exports.fromOptionK = exports.fromOption = exports.FromEither = exports.chainFirstIOK = exports.chainIOK = exports.fromIOK = exports.FromIO = exports.MonadThrow = exports.MonadIO = exports.Alt = exports.chainFirstW = exports.chainFirst = exports.Monad = exports.Chain = void 0;
 var Applicative_1 = require("./Applicative");
 var Apply_1 = require("./Apply");
 var Chain_1 = require("./Chain");
@@ -203,14 +202,6 @@ ET.orElseFirst(I.Monad);
  * @since 2.11.0
  */
 exports.orElseFirstW = exports.orElseFirst;
-/**
- * @category combinators
- * @since 2.12.0
- */
-var orElseFirstIOK = function (onLeft) {
-    return exports.orElseFirst(exports.fromIOK(onLeft));
-};
-exports.orElseFirstIOK = orElseFirstIOK;
 /**
  * @category combinators
  * @since 2.11.0
@@ -478,13 +469,6 @@ exports.ApplyPar = {
 exports.apFirst = 
 /*#__PURE__*/
 Apply_1.apFirst(exports.ApplyPar);
-/**
- * Less strict version of [`apFirst`](#apfirst).
- *
- * @category combinators
- * @since 2.12.0
- */
-exports.apFirstW = exports.apFirst;
 /**
  * Combine two effectful actions, keeping only the result of the second.
  *
@@ -496,13 +480,6 @@ exports.apFirstW = exports.apFirst;
 exports.apSecond = 
 /*#__PURE__*/
 Apply_1.apSecond(exports.ApplyPar);
-/**
- * Less strict version of [`apSecond`](#apsecond).
- *
- * @category combinators
- * @since 2.12.0
- */
-exports.apSecondW = exports.apSecond;
 /**
  * @category instances
  * @since 2.8.4
@@ -670,18 +647,6 @@ FromEither_1.chainEitherK(exports.FromEither, exports.Chain);
  * @since 2.6.1
  */
 exports.chainEitherKW = exports.chainEitherK;
-/**
- * @category combinators
- * @since 2.12.0
- */
-exports.chainFirstEitherK = 
-/*#__PURE__*/
-FromEither_1.chainFirstEitherK(exports.FromEither, exports.Chain);
-/**
- * @category combinators
- * @since 2.12.0
- */
-exports.chainFirstEitherKW = exports.chainFirstEitherK;
 /**
  * @category constructors
  * @since 2.0.0
@@ -721,21 +686,14 @@ FromEither_1.fromEitherK(exports.FromEither);
  *
  * @since 2.0.0
  */
-var bracket = function (acquire, use, release) { return exports.bracketW(acquire, use, release); };
-exports.bracket = bracket;
-/**
- * Less strict version of [`bracket`](#bracket).
- *
- * @since 2.12.0
- */
-var bracketW = function (acquire, use, release) {
-    return function_1.pipe(acquire, exports.chainW(function (a) {
+var bracket = function (acquire, use, release) {
+    return function_1.pipe(acquire, exports.chain(function (a) {
         return function_1.pipe(use(a), I.chain(function (e) {
-            return function_1.pipe(release(a, e), exports.chainW(function () { return I.of(e); }));
+            return function_1.pipe(release(a, e), exports.chain(function () { return I.of(e); }));
         }));
     }));
 };
-exports.bracketW = bracketW;
+exports.bracket = bracket;
 // -------------------------------------------------------------------------------------
 // do notation
 // -------------------------------------------------------------------------------------
diff --git a/node_modules/fp-ts/lib/IOOption.d.ts b/node_modules/fp-ts/lib/IOOption.d.ts
deleted file mode 100644
index ef83ca5..0000000
--- a/node_modules/fp-ts/lib/IOOption.d.ts
+++ /dev/null
@@ -1,440 +0,0 @@
-/**
- * @since 2.12.0
- */
-import { Alt1 } from './Alt'
-import { Alternative1 } from './Alternative'
-import { Applicative1 } from './Applicative'
-import { Apply1 } from './Apply'
-import { Chain1 } from './Chain'
-import { Compactable1 } from './Compactable'
-import { Either } from './Either'
-import { Filterable1 } from './Filterable'
-import { FromEither1 } from './FromEither'
-import { FromIO1 } from './FromIO'
-import { Lazy } from './function'
-import { Functor1 } from './Functor'
-import { Monad1 } from './Monad'
-import { MonadIO1 } from './MonadIO'
-import { NaturalTransformation11, NaturalTransformation21 } from './NaturalTransformation'
-import * as O from './Option'
-import { Pointed1 } from './Pointed'
-import { Predicate } from './Predicate'
-import { ReadonlyNonEmptyArray } from './ReadonlyNonEmptyArray'
-import { Refinement } from './Refinement'
-import { Separated } from './Separated'
-import * as I from './IO'
-import { URI as IEURI } from './IOEither'
-import { Zero1 } from './Zero'
-import IO = I.IO
-import Option = O.Option
-/**
- * @category model
- * @since 2.12.0
- */
-export interface IOOption<A> extends IO<Option<A>> {}
-/**
- * @category constructors
- * @since 2.12.0
- */
-export declare const some: <A>(a: A) => IOOption<A>
-/**
- * @category constructors
- * @since 2.12.0
- */
-export declare const fromPredicate: {
-  <A, B extends A>(refinement: Refinement<A, B>): (a: A) => IOOption<B>
-  <A>(predicate: Predicate<A>): <B extends A>(b: B) => IOOption<B>
-  <A>(predicate: Predicate<A>): (a: A) => IOOption<A>
-}
-/**
- * @category natural transformations
- * @since 2.12.0
- */
-export declare const fromOption: NaturalTransformation11<O.URI, URI>
-/**
- * @category natural transformations
- * @since 2.12.0
- */
-export declare const fromEither: FromEither1<URI>['fromEither']
-/**
- * @category natural transformations
- * @since 2.12.0
- */
-export declare const fromIO: FromIO1<URI>['fromIO']
-/**
- * @category natural transformations
- * @since 2.12.0
- */
-export declare const fromIOEither: NaturalTransformation21<IEURI, URI>
-/**
- * @category destructors
- * @since 2.12.0
- */
-export declare const match: <B, A>(onNone: () => B, onSome: (a: A) => B) => (ma: IOOption<A>) => IO<B>
-/**
- * Less strict version of [`match`](#match).
- *
- * @category destructors
- * @since 2.12.0
- */
-export declare const matchW: <B, A, C>(onNone: () => B, onSome: (a: A) => C) => (ma: IOOption<A>) => IO<B | C>
-/**
- * @category destructors
- * @since 2.12.0
- */
-export declare const matchE: <B, A>(onNone: () => IO<B>, onSome: (a: A) => IO<B>) => (ma: IOOption<A>) => IO<B>
-/**
- * Alias of [`matchE`](#matche).
- *
- * @category destructors
- * @since 2.12.0
- */
-export declare const fold: <B, A>(onNone: () => I.IO<B>, onSome: (a: A) => I.IO<B>) => (ma: IOOption<A>) => I.IO<B>
-/**
- * Less strict version of [`matchE`](#matche).
- *
- * @category destructors
- * @since 2.12.0
- */
-export declare const matchEW: <B, C, A>(onNone: () => IO<B>, onSome: (a: A) => IO<C>) => (ma: IOOption<A>) => IO<B | C>
-/**
- * @category destructors
- * @since 2.12.0
- */
-export declare const getOrElse: <A>(onNone: Lazy<IO<A>>) => (fa: IOOption<A>) => IO<A>
-/**
- * Less strict version of [`getOrElse`](#getorelse).
- *
- * @category destructors
- * @since 2.12.0
- */
-export declare const getOrElseW: <B>(onNone: Lazy<IO<B>>) => <A>(ma: IOOption<A>) => IO<A | B>
-/**
- * @category destructors
- * @since 2.12.0
- */
-export declare const toUndefined: <A>(ma: IOOption<A>) => IO<A | undefined>
-/**
- * @category destructors
- * @since 2.12.0
- */
-export declare const toNullable: <A>(ma: IOOption<A>) => IO<A | null>
-/**
- * @category interop
- * @since 2.12.0
- */
-export declare const fromNullable: <A>(a: A) => IOOption<NonNullable<A>>
-/**
- * @category interop
- * @since 2.12.0
- */
-export declare const fromNullableK: <A extends ReadonlyArray<unknown>, B>(
-  f: (...a: A) => B | null | undefined
-) => (...a: A) => IOOption<NonNullable<B>>
-/**
- * @category interop
- * @since 2.12.0
- */
-export declare const chainNullableK: <A, B>(
-  f: (a: A) => B | null | undefined
-) => (ma: IOOption<A>) => IOOption<NonNullable<B>>
-/**
- * @category combinators
- * @since 2.12.0
- */
-export declare const fromOptionK: <A extends ReadonlyArray<unknown>, B>(
-  f: (...a: A) => Option<B>
-) => (...a: A) => IOOption<B>
-/**
- * @category combinators
- * @since 2.12.0
- */
-export declare const chainOptionK: <A, B>(f: (a: A) => Option<B>) => (ma: IOOption<A>) => IOOption<B>
-/**
- * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types
- * use the type constructor `F` to represent some computational context.
- *
- * @category Functor
- * @since 2.12.0
- */
-export declare const map: <A, B>(f: (a: A) => B) => (fa: IOOption<A>) => IOOption<B>
-/**
- * @category Apply
- * @since 2.12.0
- */
-export declare const ap: <A>(fa: IOOption<A>) => <B>(fab: IOOption<(a: A) => B>) => IOOption<B>
-/**
- * @category Pointed
- * @since 2.12.0
- */
-export declare const of: Pointed1<URI>['of']
-/**
- * @category Monad
- * @since 2.12.0
- */
-export declare const chain: <A, B>(f: (a: A) => IOOption<B>) => (ma: IOOption<A>) => IOOption<B>
-/**
- * Derivable from `Chain`.
- *
- * @category combinators
- * @since 2.12.0
- */
-export declare const flatten: <A>(mma: IOOption<IOOption<A>>) => IOOption<A>
-/**
- * @category Alt
- * @since 2.12.0
- */
-export declare const alt: <A>(second: Lazy<IOOption<A>>) => (first: IOOption<A>) => IOOption<A>
-/**
- * Less strict version of [`alt`](#alt).
- *
- * @category Alt
- * @since 2.12.0
- */
-export declare const altW: <B>(second: Lazy<IOOption<B>>) => <A>(first: IOOption<A>) => IOOption<A | B>
-/**
- * @category Zero
- * @since 2.12.0
- */
-export declare const zero: Zero1<URI>['zero']
-/**
- * @category constructors
- * @since 2.12.0
- */
-export declare const none: IOOption<never>
-/**
- * @category Compactable
- * @since 2.12.0
- */
-export declare const compact: Compactable1<URI>['compact']
-/**
- * @category Compactable
- * @since 2.12.0
- */
-export declare const separate: Compactable1<URI>['separate']
-/**
- * @category Filterable
- * @since 2.12.0
- */
-export declare const filter: {
-  <A, B extends A>(refinement: Refinement<A, B>): (fb: IOOption<A>) => IOOption<B>
-  <A>(predicate: Predicate<A>): <B extends A>(fb: IOOption<B>) => IOOption<B>
-  <A>(predicate: Predicate<A>): (fa: IOOption<A>) => IOOption<A>
-}
-/**
- * @category Filterable
- * @since 2.12.0
- */
-export declare const filterMap: <A, B>(f: (a: A) => Option<B>) => (fga: IOOption<A>) => IOOption<B>
-/**
- * @category Filterable
- * @since 2.12.0
- */
-export declare const partition: {
-  <A, B extends A>(refinement: Refinement<A, B>): (fb: IOOption<A>) => Separated<IOOption<A>, IOOption<B>>
-  <A>(predicate: Predicate<A>): <B extends A>(fb: IOOption<B>) => Separated<IOOption<B>, IOOption<B>>
-  <A>(predicate: Predicate<A>): (fa: IOOption<A>) => Separated<IOOption<A>, IOOption<A>>
-}
-/**
- * @category Filterable
- * @since 2.12.0
- */
-export declare const partitionMap: <A, B, C>(
-  f: (a: A) => Either<B, C>
-) => (fa: IOOption<A>) => Separated<IOOption<B>, IOOption<C>>
-/**
- * @category instances
- * @since 2.12.0
- */
-declare const URI = 'IOOption'
-/**
- * @category instances
- * @since 2.12.0
- */
-export declare type URI = typeof URI
-declare module './HKT' {
-  interface URItoKind<A> {
-    readonly [URI]: IOOption<A>
-  }
-}
-/**
- * @category instances
- * @since 2.12.0
- */
-export declare const Functor: Functor1<URI>
-/**
- * Derivable from `Functor`.
- *
- * @category combinators
- * @since 2.12.0
- */
-export declare const flap: <A>(a: A) => <B>(fab: IOOption<(a: A) => B>) => IOOption<B>
-/**
- * @category instances
- * @since 2.12.0
- */
-export declare const Pointed: Pointed1<URI>
-/**
- * @category instances
- * @since 2.12.0
- */
-export declare const Apply: Apply1<URI>
-/**
- * Combine two effectful actions, keeping only the result of the first.
- *
- * Derivable from `Apply`.
- *
- * @category combinators
- * @since 2.12.0
- */
-export declare const apFirst: <B>(second: IOOption<B>) => <A>(first: IOOption<A>) => IOOption<A>
-/**
- * Combine two effectful actions, keeping only the result of the second.
- *
- * Derivable from `Apply`.
- *
- * @category combinators
- * @since 2.12.0
- */
-export declare const apSecond: <B>(second: IOOption<B>) => <A>(first: IOOption<A>) => IOOption<B>
-/**
- * @category instances
- * @since 2.12.0
- */
-export declare const Applicative: Applicative1<URI>
-/**
- * @category instances
- * @since 2.12.0
- */
-export declare const Chain: Chain1<URI>
-/**
- * Composes computations in sequence, using the return value of one computation to determine the next computation and
- * keeping only the result of the first.
- *
- * Derivable from `Chain`.
- *
- * @category combinators
- * @since 2.12.0
- */
-export declare const chainFirst: <A, B>(f: (a: A) => IOOption<B>) => (first: IOOption<A>) => IOOption<A>
-/**
- * @category instances
- * @since 2.12.0
- */
-export declare const Alt: Alt1<URI>
-/**
- * @category instances
- * @since 2.12.0
- */
-export declare const Zero: Zero1<URI>
-/**
- * @category constructors
- * @since 2.12.0
- */
-export declare const guard: (b: boolean) => IOOption<void>
-/**
- * @category instances
- * @since 2.12.0
- */
-export declare const Alternative: Alternative1<URI>
-/**
- * @category instances
- * @since 2.12.0
- */
-export declare const Monad: Monad1<URI>
-/**
- * @category instances
- * @since 2.12.0
- */
-export declare const MonadIO: MonadIO1<URI>
-/**
- * @category instances
- * @since 2.12.0
- */
-export declare const Compactable: Compactable1<URI>
-/**
- * @category instances
- * @since 2.12.0
- */
-export declare const Filterable: Filterable1<URI>
-/**
- * @category instances
- * @since 2.12.0
- */
-export declare const FromIO: FromIO1<URI>
-/**
- * @category combinators
- * @since 2.12.0
- */
-export declare const fromIOK: <A extends readonly unknown[], B>(f: (...a: A) => I.IO<B>) => (...a: A) => IOOption<B>
-/**
- * @category combinators
- * @since 2.12.0
- */
-export declare const chainIOK: <A, B>(f: (a: A) => I.IO<B>) => (first: IOOption<A>) => IOOption<B>
-/**
- * @category combinators
- * @since 2.12.0
- */
-export declare const chainFirstIOK: <A, B>(f: (a: A) => I.IO<B>) => (first: IOOption<A>) => IOOption<A>
-/**
- * @category instances
- * @since 2.12.0
- */
-export declare const FromEither: FromEither1<URI>
-/**
- * @category combinators
- * @since 2.12.0
- */
-export declare const fromEitherK: <E, A extends readonly unknown[], B>(
-  f: (...a: A) => Either<E, B>
-) => (...a: A) => IOOption<B>
-/**
- * @category combinators
- * @since 2.12.0
- */
-export declare const chainEitherK: <E, A, B>(f: (a: A) => Either<E, B>) => (ma: IOOption<A>) => IOOption<B>
-/**
- * @category combinators
- * @since 2.12.0
- */
-export declare const chainFirstEitherK: <E, A, B>(f: (a: A) => Either<E, B>) => (ma: IOOption<A>) => IOOption<A>
-/**
- * @since 2.12.0
- */
-export declare const Do: IOOption<{}>
-/**
- * @since 2.12.0
- */
-export declare const bindTo: <N extends string>(name: N) => <A>(fa: IOOption<A>) => IOOption<{ readonly [K in N]: A }>
-/**
- * @since 2.12.0
- */
-export declare const bind: <N extends string, A, B>(
-  name: Exclude<N, keyof A>,
-  f: (a: A) => IOOption<B>
-) => (ma: IOOption<A>) => IOOption<{ readonly [K in N | keyof A]: K extends keyof A ? A[K] : B }>
-/**
- * @since 2.12.0
- */
-export declare const apS: <N extends string, A, B>(
-  name: Exclude<N, keyof A>,
-  fb: IOOption<B>
-) => (fa: IOOption<A>) => IOOption<{ readonly [K in N | keyof A]: K extends keyof A ? A[K] : B }>
-/**
- * @since 2.12.0
- */
-export declare const ApT: IOOption<readonly []>
-/**
- * @since 2.12.0
- */
-export declare const traverseReadonlyNonEmptyArrayWithIndex: <A, B>(
-  f: (index: number, a: A) => IOOption<B>
-) => (as: ReadonlyNonEmptyArray<A>) => IOOption<ReadonlyNonEmptyArray<B>>
-/**
- * @since 2.12.0
- */
-export declare const traverseReadonlyArrayWithIndex: <A, B>(
-  f: (index: number, a: A) => IOOption<B>
-) => (as: readonly A[]) => IOOption<readonly B[]>
-export {}
diff --git a/node_modules/fp-ts/lib/IOOption.js b/node_modules/fp-ts/lib/IOOption.js
deleted file mode 100644
index 6a13ad8..0000000
--- a/node_modules/fp-ts/lib/IOOption.js
+++ /dev/null
@@ -1,606 +0,0 @@
-"use strict";
-var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
-    if (k2 === undefined) k2 = k;
-    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
-}) : (function(o, m, k, k2) {
-    if (k2 === undefined) k2 = k;
-    o[k2] = m[k];
-}));
-var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
-    Object.defineProperty(o, "default", { enumerable: true, value: v });
-}) : function(o, v) {
-    o["default"] = v;
-});
-var __importStar = (this && this.__importStar) || function (mod) {
-    if (mod && mod.__esModule) return mod;
-    var result = {};
-    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
-    __setModuleDefault(result, mod);
-    return result;
-};
-Object.defineProperty(exports, "__esModule", { value: true });
-exports.MonadIO = exports.Monad = exports.Alternative = exports.guard = exports.Zero = exports.Alt = exports.chainFirst = exports.Chain = exports.Applicative = exports.apSecond = exports.apFirst = exports.Apply = exports.Pointed = exports.flap = exports.Functor = exports.partitionMap = exports.partition = exports.filterMap = exports.filter = exports.separate = exports.compact = exports.none = exports.zero = exports.altW = exports.alt = exports.flatten = exports.chain = exports.of = exports.ap = exports.map = exports.chainOptionK = exports.fromOptionK = exports.chainNullableK = exports.fromNullableK = exports.fromNullable = exports.toNullable = exports.toUndefined = exports.getOrElseW = exports.getOrElse = exports.matchEW = exports.fold = exports.matchE = exports.matchW = exports.match = exports.fromIOEither = exports.fromIO = exports.fromEither = exports.fromOption = exports.fromPredicate = exports.some = void 0;
-exports.traverseReadonlyArrayWithIndex = exports.traverseReadonlyNonEmptyArrayWithIndex = exports.ApT = exports.apS = exports.bind = exports.bindTo = exports.Do = exports.chainFirstEitherK = exports.chainEitherK = exports.fromEitherK = exports.FromEither = exports.chainFirstIOK = exports.chainIOK = exports.fromIOK = exports.FromIO = exports.Filterable = exports.Compactable = void 0;
-var Apply_1 = require("./Apply");
-var Chain_1 = require("./Chain");
-var Compactable_1 = require("./Compactable");
-var Filterable_1 = require("./Filterable");
-var FromEither_1 = require("./FromEither");
-var FromIO_1 = require("./FromIO");
-var function_1 = require("./function");
-var Functor_1 = require("./Functor");
-var _ = __importStar(require("./internal"));
-var O = __importStar(require("./Option"));
-var OT = __importStar(require("./OptionT"));
-var I = __importStar(require("./IO"));
-var Zero_1 = require("./Zero");
-// -------------------------------------------------------------------------------------
-// constructors
-// -------------------------------------------------------------------------------------
-/**
- * @category constructors
- * @since 2.12.0
- */
-exports.some = 
-/*#__PURE__*/
-OT.some(I.Pointed);
-/**
- * @category constructors
- * @since 2.12.0
- */
-exports.fromPredicate = 
-/*#__PURE__*/
-OT.fromPredicate(I.Pointed);
-// -------------------------------------------------------------------------------------
-// natural transformations
-// -------------------------------------------------------------------------------------
-/**
- * @category natural transformations
- * @since 2.12.0
- */
-exports.fromOption = I.of;
-/**
- * @category natural transformations
- * @since 2.12.0
- */
-exports.fromEither = 
-/*#__PURE__*/
-OT.fromEither(I.Pointed);
-/**
- * @category natural transformations
- * @since 2.12.0
- */
-exports.fromIO = 
-/*#__PURE__*/
-OT.fromF(I.Functor);
-/**
- * @category natural transformations
- * @since 2.12.0
- */
-exports.fromIOEither = 
-/*#__PURE__*/
-I.map(O.fromEither);
-// -------------------------------------------------------------------------------------
-// destructors
-// -------------------------------------------------------------------------------------
-/**
- * @category destructors
- * @since 2.12.0
- */
-exports.match = 
-/*#__PURE__*/
-OT.match(I.Functor);
-/**
- * Less strict version of [`match`](#match).
- *
- * @category destructors
- * @since 2.12.0
- */
-exports.matchW = exports.match;
-/**
- * @category destructors
- * @since 2.12.0
- */
-exports.matchE = 
-/*#__PURE__*/
-OT.matchE(I.Chain);
-/**
- * Alias of [`matchE`](#matche).
- *
- * @category destructors
- * @since 2.12.0
- */
-exports.fold = exports.matchE;
-/**
- * Less strict version of [`matchE`](#matche).
- *
- * @category destructors
- * @since 2.12.0
- */
-exports.matchEW = exports.matchE;
-/**
- * @category destructors
- * @since 2.12.0
- */
-exports.getOrElse = 
-/*#__PURE__*/
-OT.getOrElse(I.Monad);
-/**
- * Less strict version of [`getOrElse`](#getorelse).
- *
- * @category destructors
- * @since 2.12.0
- */
-exports.getOrElseW = exports.getOrElse;
-/**
- * @category destructors
- * @since 2.12.0
- */
-exports.toUndefined = I.map(O.toUndefined);
-/**
- * @category destructors
- * @since 2.12.0
- */
-exports.toNullable = I.map(O.toNullable);
-// -------------------------------------------------------------------------------------
-// interop
-// -------------------------------------------------------------------------------------
-/**
- * @category interop
- * @since 2.12.0
- */
-exports.fromNullable = 
-/*#__PURE__*/
-OT.fromNullable(I.Pointed);
-/**
- * @category interop
- * @since 2.12.0
- */
-exports.fromNullableK = 
-/*#__PURE__*/
-OT.fromNullableK(I.Pointed);
-/**
- * @category interop
- * @since 2.12.0
- */
-exports.chainNullableK = 
-/*#__PURE__*/
-OT.chainNullableK(I.Monad);
-// -------------------------------------------------------------------------------------
-// combinators
-// -------------------------------------------------------------------------------------
-/**
- * @category combinators
- * @since 2.12.0
- */
-exports.fromOptionK = 
-/*#__PURE__*/
-OT.fromOptionK(I.Pointed);
-/**
- * @category combinators
- * @since 2.12.0
- */
-exports.chainOptionK = 
-/*#__PURE__*/
-OT.chainOptionK(I.Monad);
-// -------------------------------------------------------------------------------------
-// type class members
-// -------------------------------------------------------------------------------------
-/**
- * `map` can be used to turn functions `(a: A) => B` into functions `(fa: F<A>) => F<B>` whose argument and return types
- * use the type constructor `F` to represent some computational context.
- *
- * @category Functor
- * @since 2.12.0
- */
-exports.map = 
-/*#__PURE__*/
-OT.map(I.Functor);
-/**
- * @category Apply
- * @since 2.12.0
- */
-exports.ap = 
-/*#__PURE__*/
-OT.ap(I.Apply);
-/**
- * @category Pointed
- * @since 2.12.0
- */
-exports.of = exports.some;
-/**
- * @category Monad
- * @since 2.12.0
- */
-exports.chain = 
-/*#__PURE__*/
-OT.chain(I.Monad);
-/**
- * Derivable from `Chain`.
- *
- * @category combinators
- * @since 2.12.0
- */
-exports.flatten = 
-/*#__PURE__*/
-exports.chain(function_1.identity);
-/**
- * @category Alt
- * @since 2.12.0
- */
-exports.alt = 
-/*#__PURE__*/
-OT.alt(I.Monad);
-/**
- * Less strict version of [`alt`](#alt).
- *
- * @category Alt
- * @since 2.12.0
- */
-exports.altW = exports.alt;
-/**
- * @category Zero
- * @since 2.12.0
- */
-exports.zero = 
-/*#__PURE__*/
-OT.zero(I.Pointed);
-/**
- * @category constructors
- * @since 2.12.0
- */
-exports.none = 
-/*#__PURE__*/
-exports.zero();
-/**
- * @category Compactable
- * @since 2.12.0
- */
-exports.compact = 
-/*#__PURE__*/
-Compactable_1.compact(I.Functor, O.Compactable);
-/**
- * @category Compactable
- * @since 2.12.0
- */
-exports.separate = 
-/*#__PURE__*/
-Compactable_1.separate(I.Functor, O.Compactable, O.Functor);
-/**
- * @category Filterable
- * @since 2.12.0
- */
-exports.filter = 
-/*#__PURE__*/
-Filterable_1.filter(I.Functor, O.Filterable);
-/**
- * @category Filterable
- * @since 2.12.0
- */
-exports.filterMap = 
-/*#__PURE__*/
-Filterable_1.filterMap(I.Functor, O.Filterable);
-/**
- * @category Filterable
- * @since 2.12.0
- */
-exports.partition = 
-/*#__PURE__*/
-Filterable_1.partition(I.Functor, O.Filterable);
-/**
- * @category Filterable
- * @since 2.12.0
- */
-exports.partitionMap = 
-/*#__PURE__*/
-Filterable_1.partitionMap(I.Functor, O.Filterable);
-// -------------------------------------------------------------------------------------
-// instances
-// -------------------------------------------------------------------------------------
-var _map = function (fa, f) { return function_1.pipe(fa, exports.map(f)); };
-/* istanbul ignore next */
-var _ap = function (fab, fa) { return function_1.pipe(fab, exports.ap(fa)); };
-/* istanbul ignore next */
-var _chain = function (ma, f) { return function_1.pipe(ma, exports.chain(f)); };
-/* istanbul ignore next */
-var _alt = function (fa, that) { return function_1.pipe(fa, exports.alt(that)); };
-/* istanbul ignore next */
-var _filter = function (fa, predicate) { return function_1.pipe(fa, exports.filter(predicate)); };
-/* istanbul ignore next */
-var _filterMap = function (fa, f) { return function_1.pipe(fa, exports.filterMap(f)); };
-/* istanbul ignore next */
-var _partition = function (fa, predicate) {
-    return function_1.pipe(fa, exports.partition(predicate));
-};
-/* istanbul ignore next */
-var _partitionMap = function (fa, f) { return function_1.pipe(fa, exports.partitionMap(f)); };
-/**
- * @category instances
- * @since 2.12.0
- */
-var URI = 'IOOption';
-/**
- * @category instances
- * @since 2.12.0
- */
-exports.Functor = {
-    URI: URI,
-    map: _map
-};
-/**
- * Derivable from `Functor`.
- *
- * @category combinators
- * @since 2.12.0
- */
-exports.flap = 
-/*#__PURE__*/
-Functor_1.flap(exports.Functor);
-/**
- * @category instances
- * @since 2.12.0
- */
-exports.Pointed = {
-    URI: URI,
-    of: exports.of
-};
-/**
- * @category instances
- * @since 2.12.0
- */
-exports.Apply = {
-    URI: URI,
-    map: _map,
-    ap: _ap
-};
-/**
- * Combine two effectful actions, keeping only the result of the first.
- *
- * Derivable from `Apply`.
- *
- * @category combinators
- * @since 2.12.0
- */
-exports.apFirst = 
-/*#__PURE__*/
-Apply_1.apFirst(exports.Apply);
-/**
- * Combine two effectful actions, keeping only the result of the second.
- *
- * Derivable from `Apply`.
- *
- * @category combinators
- * @since 2.12.0
- */
-exports.apSecond = 
-/*#__PURE__*/
-Apply_1.apSecond(exports.Apply);
-/**
- * @category instances
- * @since 2.12.0
- */
-exports.Applicative = {
-    URI: URI,
-    map: _map,
-    ap: _ap,
-    of: exports.of
-};
-/**
- * @category instances
- * @since 2.12.0
- */
-exports.Chain = {
-    URI: URI,
-    map: _map,
-    ap: _ap,
-    chain: _chain
-};
-/**
- * Composes computations in sequence, using the return value of one computation to determine the next computation and
- * keeping only the result of the first.
- *
- * Derivable from `Chain`.
- *
- * @category combinators
- * @since 2.12.0
- */
-exports.chainFirst = 
-/*#__PURE__*/
-Chain_1.chainFirst(exports.Chain);
-/**
- * @category instances
- * @since 2.12.0
- */
-exports.Alt = {
-    URI: URI,
-    map: _map,
-    alt: _alt
-};
-/**
- * @category instances
- * @since 2.12.0
- */
-exports.Zero = {
-    URI: URI,
-    zero: exports.zero
-};
-/**
- * @category constructors
- * @since 2.12.0
- */
-exports.guard = 
-/*#__PURE__*/
-Zero_1.guard(exports.Zero, exports.Pointed);
-/**
- * @category instances
- * @since 2.12.0
- */
-exports.Alternative = {
-    URI: URI,
-    map: _map,
-    ap: _ap,
-    of: exports.of,
-    alt: _alt,
-    zero: exports.zero
-};
-/**
- * @category instances
- * @since 2.12.0
- */
-exports.Monad = {
-    URI: URI,
-    map: _map,
-    ap: _ap,
-    of: exports.of,
-    chain: _chain
-};
-/**
- * @category instances
- * @since 2.12.0
- */
-exports.MonadIO = {
-    URI: URI,
-    map: _map,
-    ap: _ap,
-    of: exports.of,
-    chain: _chain,
-    fromIO: exports.fromIO
-};
-/**
- * @category instances
- * @since 2.12.0
- */
-exports.Compactable = {
-    URI: URI,
-    compact: exports.compact,
-    separate: exports.separate
-};
-/**
- * @category instances
- * @since 2.12.0
- */
-exports.Filterable = {
-    URI: URI,
-    map: _map,
-    compact: exports.compact,
-    separate: exports.separate,
-    filter: _filter,
-    filterMap: _filterMap,
-    partition: _partition,
-    partitionMap: _partitionMap
-};
-/**
- * @category instances
- * @since 2.12.0
- */
-exports.FromIO = {
-    URI: URI,
-    fromIO: exports.fromIO
-};
-/**
- * @category combinators
- * @since 2.12.0
- */
-exports.fromIOK = 
-/*#__PURE__*/
-FromIO_1.fromIOK(exports.FromIO);
-/**
- * @category combinators
- * @since 2.12.0
- */
-exports.chainIOK = 
-/*#__PURE__*/
-FromIO_1.chainIOK(exports.FromIO, exports.Chain);
-/**
- * @category combinators
- * @since 2.12.0
- */
-exports.chainFirstIOK = 
-/*#__PURE__*/
-FromIO_1.chainFirstIOK(exports.FromIO, exports.Chain);
-/**
- * @category instances
- * @since 2.12.0
- */
-exports.FromEither = {
-    URI: URI,
-    fromEither: exports.fromEither
-};
-/**
- * @category combinators
- * @since 2.12.0
- */
-exports.fromEitherK = 
-/*#__PURE__*/
-FromEither_1.fromEitherK(exports.FromEither);
-/**
- * @category combinators
- * @since 2.12.0
- */
-exports.chainEitherK = 
-/*#__PURE__*/
-FromEither_1.chainEitherK(exports.FromEither, exports.Chain);
-/**
- * @category combinators
- * @since 2.12.0
- */
-exports.chainFirstEitherK = 
-/*#__PURE__*/
-FromEither_1.chainFirstEitherK(exports.FromEither, exports.Chain);
-// -------------------------------------------------------------------------------------
-// do notation
-// -------------------------------------------------------------------------------------
-/**
- * @since 2.12.0
- */
-exports.Do = 
-/*#__PURE__*/
-exports.of(_.emptyRecord);
-/**
- * @since 2.12.0
- */
-exports.bindTo = 
-/*#__PURE__*/
-Functor_1.bindTo(exports.Functor);
-/**
- * @since 2.12.0
- */
-exports.bind = 
-/*#__PURE__*/
-Chain_1.bind(exports.Chain);
-// -------------------------------------------------------------------------------------
-// sequence S
-// -------------------------------------------------------------------------------------
-/**
- * @since 2.12.0
- */
-exports.apS = 
-/*#__PURE__*/
-Apply_1.apS(exports.Apply);
-// -------------------------------------------------------------------------------------
-// sequence T
-// -------------------------------------------------------------------------------------
-/**
- * @since 2.12.0
- */
-exports.ApT = 
-/*#__PURE__*/
-exports.of(_.emptyReadonlyArray);
-// -------------------------------------------------------------------------------------
-// array utils
-// -------------------------------------------------------------------------------------
-/**
- * @since 2.12.0
- */
-var traverseReadonlyNonEmptyArrayWithIndex = function (f) {
-    return function_1.flow(I.traverseReadonlyNonEmptyArrayWithIndex(f), I.map(O.traverseReadonlyNonEmptyArrayWithIndex(function_1.SK)));
-};
-exports.traverseReadonlyNonEmptyArrayWithIndex = traverseReadonlyNonEmptyArrayWithIndex;
-/**
- * @since 2.12.0
- */
-var traverseReadonlyArrayWithIndex = function (f) {
-    var g = exports.traverseReadonlyNonEmptyArrayWithIndex(f);
-    return function (as) { return (_.isNonEmpty(as) ? g(as) : exports.ApT); };
-};
-exports.traverseReadonlyArrayWithIndex = traverseReadonlyArrayWithIndex;
diff --git a/node_modules/fp-ts/lib/NonEmptyArray.d.ts b/node_modules/fp-ts/lib/NonEmptyArray.d.ts
index 5a63574..b1ce2b0 100644
--- a/node_modules/fp-ts/lib/NonEmptyArray.d.ts
+++ b/node_modules/fp-ts/lib/NonEmptyArray.d.ts
@@ -705,18 +705,6 @@ export declare const modifyLast: <A>(f: Endomorphism<A>) => (as: NonEmptyArray<A
  * @since 2.11.0
  */
 export declare const updateLast: <A>(a: A) => (as: NonEmptyArray<A>) => NonEmptyArray<A>
-/**
- * Places an element in between members of a `NonEmptyArray`, then folds the results using the provided `Semigroup`.
- *
- * @example
- * import * as S from 'fp-ts/string'
- * import { intercalate } from 'fp-ts/NonEmptyArray'
- *
- * assert.deepStrictEqual(intercalate(S.Semigroup)('-')(['a', 'b', 'c']), 'a-b-c')
- *
- * @since 2.12.0
- */
-export declare const intercalate: <A>(S: Semigroup<A>) => (middle: A) => (as: NonEmptyArray<A>) => A
 /**
  * This is just `sort` followed by `group`.
  *
diff --git a/node_modules/fp-ts/lib/NonEmptyArray.js b/node_modules/fp-ts/lib/NonEmptyArray.js
index fd948e8..068b4a6 100644
--- a/node_modules/fp-ts/lib/NonEmptyArray.js
+++ b/node_modules/fp-ts/lib/NonEmptyArray.js
@@ -25,8 +25,8 @@ var __spreadArray = (this && this.__spreadArray) || function (to, from) {
 };
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.mapWithIndex = exports.map = exports.flatten = exports.duplicate = exports.extend = exports.chain = exports.ap = exports.alt = exports.altW = exports.chunksOf = exports.splitAt = exports.chop = exports.chainWithIndex = exports.foldMap = exports.foldMapWithIndex = exports.intersperse = exports.prependAll = exports.unzip = exports.zip = exports.zipWith = exports.of = exports.copy = exports.modifyAt = exports.updateAt = exports.insertAt = exports.sort = exports.groupBy = exports.group = exports.reverse = exports.concat = exports.concatW = exports.unappend = exports.unprepend = exports.range = exports.replicate = exports.makeBy = exports.fromArray = exports.fromReadonlyNonEmptyArray = exports.rotate = exports.union = exports.sortBy = exports.uniq = exports.unsafeUpdateAt = exports.unsafeInsertAt = exports.append = exports.appendW = exports.prepend = exports.prependW = exports.isOutOfBound = exports.isNonEmpty = void 0;
-exports.filter = exports.groupSort = exports.intercalate = exports.updateLast = exports.modifyLast = exports.updateHead = exports.modifyHead = exports.matchRight = exports.matchLeft = exports.concatAll = exports.max = exports.min = exports.init = exports.last = exports.tail = exports.head = exports.apS = exports.bind = exports.bindTo = exports.Do = exports.Comonad = exports.Alt = exports.TraversableWithIndex = exports.Traversable = exports.FoldableWithIndex = exports.Foldable = exports.Monad = exports.chainFirst = exports.Chain = exports.Applicative = exports.apSecond = exports.apFirst = exports.Apply = exports.FunctorWithIndex = exports.Pointed = exports.flap = exports.Functor = exports.getUnionSemigroup = exports.getEq = exports.getSemigroup = exports.getShow = exports.URI = exports.extract = exports.traverseWithIndex = exports.sequence = exports.traverse = exports.reduceRightWithIndex = exports.reduceRight = exports.reduceWithIndex = exports.reduce = void 0;
-exports.nonEmptyArray = exports.fold = exports.prependToAll = exports.snoc = exports.cons = exports.unsnoc = exports.uncons = exports.filterWithIndex = void 0;
+exports.filterWithIndex = exports.filter = exports.groupSort = exports.updateLast = exports.modifyLast = exports.updateHead = exports.modifyHead = exports.matchRight = exports.matchLeft = exports.concatAll = exports.max = exports.min = exports.init = exports.last = exports.tail = exports.head = exports.apS = exports.bind = exports.bindTo = exports.Do = exports.Comonad = exports.Alt = exports.TraversableWithIndex = exports.Traversable = exports.FoldableWithIndex = exports.Foldable = exports.Monad = exports.chainFirst = exports.Chain = exports.Applicative = exports.apSecond = exports.apFirst = exports.Apply = exports.FunctorWithIndex = exports.Pointed = exports.flap = exports.Functor = exports.getUnionSemigroup = exports.getEq = exports.getSemigroup = exports.getShow = exports.URI = exports.extract = exports.traverseWithIndex = exports.sequence = exports.traverse = exports.reduceRightWithIndex = exports.reduceRight = exports.reduceWithIndex = exports.reduce = void 0;
+exports.nonEmptyArray = exports.fold = exports.prependToAll = exports.snoc = exports.cons = exports.unsnoc = exports.uncons = void 0;
 var Apply_1 = require("./Apply");
 var Chain_1 = require("./Chain");
 var function_1 = require("./function");
@@ -1076,18 +1076,6 @@ exports.modifyLast = modifyLast;
  */
 var updateLast = function (a) { return exports.modifyLast(function () { return a; }); };
 exports.updateLast = updateLast;
-/**
- * Places an element in between members of a `NonEmptyArray`, then folds the results using the provided `Semigroup`.
- *
- * @example
- * import * as S from 'fp-ts/string'
- * import { intercalate } from 'fp-ts/NonEmptyArray'
- *
- * assert.deepStrictEqual(intercalate(S.Semigroup)('-')(['a', 'b', 'c']), 'a-b-c')
- *
- * @since 2.12.0
- */
-exports.intercalate = RNEA.intercalate;
 function groupSort(O) {
     var sortO = exports.sort(O);
     var groupO = group(O);
diff --git a/node_modules/fp-ts/lib/Option.d.ts b/node_modules/fp-ts/lib/Option.d.ts
index 54f65e5..6ffb617 100644
--- a/node_modules/fp-ts/lib/Option.d.ts
+++ b/node_modules/fp-ts/lib/Option.d.ts
@@ -619,11 +619,6 @@ export declare const fromEitherK: <E, A extends readonly unknown[], B>(
  * @since 2.11.0
  */
 export declare const chainEitherK: <E, A, B>(f: (a: A) => Either<E, B>) => (ma: Option<A>) => Option<B>
-/**
- * @category combinators
- * @since 2.12.0
- */
-export declare const chainFirstEitherK: <E, A, B>(f: (a: A) => Either<E, B>) => (ma: Option<A>) => Option<A>
 /**
  * Constructs a new `Option` from a nullable type. If the value is `null` or `undefined`, returns `None`, otherwise
  * returns the value wrapped in a `Some`.
diff --git a/node_modules/fp-ts/lib/Option.js b/node_modules/fp-ts/lib/Option.js
index 98604c5..afeab1f 100644
--- a/node_modules/fp-ts/lib/Option.js
+++ b/node_modules/fp-ts/lib/Option.js
@@ -20,7 +20,7 @@ var __importStar = (this && this.__importStar) || function (mod) {
 };
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.fromEither = exports.MonadThrow = exports.throwError = exports.Witherable = exports.wilt = exports.wither = exports.Traversable = exports.sequence = exports.traverse = exports.Filterable = exports.partitionMap = exports.partition = exports.filterMap = exports.filter = exports.Compactable = exports.separate = exports.compact = exports.Extend = exports.extend = exports.Alternative = exports.guard = exports.Zero = exports.zero = exports.Alt = exports.alt = exports.altW = exports.Foldable = exports.reduceRight = exports.foldMap = exports.reduce = exports.Monad = exports.Chain = exports.chain = exports.Applicative = exports.Apply = exports.ap = exports.Pointed = exports.of = exports.Functor = exports.map = exports.getMonoid = exports.getOrd = exports.getEq = exports.getShow = exports.URI = exports.getRight = exports.getLeft = exports.fromPredicate = exports.some = exports.none = void 0;
-exports.getLastMonoid = exports.getFirstMonoid = exports.getApplyMonoid = exports.getApplySemigroup = exports.option = exports.mapNullable = exports.getRefinement = exports.sequenceArray = exports.traverseArray = exports.traverseArrayWithIndex = exports.traverseReadonlyArrayWithIndex = exports.traverseReadonlyNonEmptyArrayWithIndex = exports.ApT = exports.apS = exports.bind = exports.bindTo = exports.Do = exports.exists = exports.elem = exports.toUndefined = exports.toNullable = exports.chainNullableK = exports.fromNullableK = exports.tryCatchK = exports.tryCatch = exports.fromNullable = exports.chainFirstEitherK = exports.chainEitherK = exports.fromEitherK = exports.duplicate = exports.chainFirst = exports.flatten = exports.apSecond = exports.apFirst = exports.flap = exports.getOrElse = exports.getOrElseW = exports.fold = exports.match = exports.foldW = exports.matchW = exports.isNone = exports.isSome = exports.FromEither = void 0;
+exports.getLastMonoid = exports.getFirstMonoid = exports.getApplyMonoid = exports.getApplySemigroup = exports.option = exports.mapNullable = exports.getRefinement = exports.sequenceArray = exports.traverseArray = exports.traverseArrayWithIndex = exports.traverseReadonlyArrayWithIndex = exports.traverseReadonlyNonEmptyArrayWithIndex = exports.ApT = exports.apS = exports.bind = exports.bindTo = exports.Do = exports.exists = exports.elem = exports.toUndefined = exports.toNullable = exports.chainNullableK = exports.fromNullableK = exports.tryCatchK = exports.tryCatch = exports.fromNullable = exports.chainEitherK = exports.fromEitherK = exports.duplicate = exports.chainFirst = exports.flatten = exports.apSecond = exports.apFirst = exports.flap = exports.getOrElse = exports.getOrElseW = exports.fold = exports.match = exports.foldW = exports.matchW = exports.isNone = exports.isSome = exports.FromEither = void 0;
 var Applicative_1 = require("./Applicative");
 var Apply_1 = require("./Apply");
 var Chain_1 = require("./Chain");
@@ -790,13 +790,6 @@ FromEither_1.fromEitherK(exports.FromEither);
 exports.chainEitherK = 
 /*#__PURE__*/
 FromEither_1.chainEitherK(exports.FromEither, exports.Chain);
-/**
- * @category combinators
- * @since 2.12.0
- */
-exports.chainFirstEitherK = 
-/*#__PURE__*/
-FromEither_1.chainFirstEitherK(exports.FromEither, exports.Chain);
 // -------------------------------------------------------------------------------------
 // interop
 // -------------------------------------------------------------------------------------
diff --git a/node_modules/fp-ts/lib/Ordering.d.ts b/node_modules/fp-ts/lib/Ordering.d.ts
index 34dc579..fdd6c30 100644
--- a/node_modules/fp-ts/lib/Ordering.d.ts
+++ b/node_modules/fp-ts/lib/Ordering.d.ts
@@ -9,17 +9,6 @@ import * as S from './Semigroup'
  * @since 2.0.0
  */
 export declare type Ordering = -1 | 0 | 1
-/**
- * Less strict version of [`match`](#match).
- *
- * @category destructors
- * @since 2.12.0
- */
-export declare const matchW: <A, B, C>(
-  onLessThan: () => A,
-  onEqual: () => B,
-  onGreaterThan: () => C
-) => (o: Ordering) => A | B | C
 /**
  * @category destructors
  * @since 2.10.0
diff --git a/node_modules/fp-ts/lib/Ordering.js b/node_modules/fp-ts/lib/Ordering.js
index 7b42266..0cea3a2 100644
--- a/node_modules/fp-ts/lib/Ordering.js
+++ b/node_modules/fp-ts/lib/Ordering.js
@@ -1,22 +1,17 @@
 "use strict";
 Object.defineProperty(exports, "__esModule", { value: true });
-exports.monoidOrdering = exports.eqOrdering = exports.semigroupOrdering = exports.invert = exports.sign = exports.Monoid = exports.Semigroup = exports.Eq = exports.reverse = exports.match = exports.matchW = void 0;
+exports.monoidOrdering = exports.eqOrdering = exports.semigroupOrdering = exports.invert = exports.sign = exports.Monoid = exports.Semigroup = exports.Eq = exports.reverse = exports.match = void 0;
 // -------------------------------------------------------------------------------------
 // destructors
 // -------------------------------------------------------------------------------------
-/**
- * Less strict version of [`match`](#match).
- *
- * @category destructors
- * @since 2.12.0
- */
-var matchW = function (onLessThan, onEqual, onGreaterThan) { return function (o) { return (o === -1 ? onLessThan() : o === 0 ? onEqual() : onGreaterThan()); }; };
-exports.matchW = matchW;
 /**
  * @category destructors
  * @since 2.10.0
  */
-exports.match = exports.matchW;
+var match = function (onLessThan, onEqual, onGreaterThan) { return function (o) {
+    return o === -1 ? onLessThan() : o === 0 ? onEqual() : onGreaterThan();
+}; };
+exports.match = match;
 // -------------------------------------------------------------------------------------
 // combinators
 // -------------------------------------------------------------------------------------
diff --git a/node_modules/fp-ts/lib/Reader.d.ts b/node_modules/fp-ts/lib/Reader.d.ts
index 1500da7..94ce94c 100644
--- a/node_modules/fp-ts/lib/Reader.d.ts
+++ b/node_modules/fp-ts/lib/Reader.d.ts
@@ -193,13 +193,6 @@ export declare const Apply: Apply2<URI>
  * @since 2.0.0
  */
 export declare const apFirst: <E, B>(second: Reader<E, B>) => <A>(first: Reader<E, A>) => Reader<E, A>
-/**
- * Less strict version of [`apFirst`](#apfirst).
- *
- * @category combinators
- * @since 2.12.0
- */
-export declare const apFirstW: <R2, A, B>(second: Reader<R2, B>) => <R1>(first: Reader<R1, A>) => Reader<R1 & R2, A>
 /**
  * Combine two effectful actions, keeping only the result of the second.
  *
@@ -209,13 +202,6 @@ export declare const apFirstW: <R2, A, B>(second: Reader<R2, B>) => <R1>(first:
  * @since 2.0.0
  */
 export declare const apSecond: <E, B>(second: Reader<E, B>) => <A>(first: Reader<E, A>) => Reader<E, B>
-/**
- * Less strict version of [`apSecond`](#apsecond).
- *
- * @category combinators
- * @since 2.12.0
- */
-export declare const apSecondW: <R2, A, B>(second: Reader<R2, B>) => <R1>(first: Reader<R1, A>) => Reader<R1 & R2, B>
 /**
  * @category instances
  * @since 2.7.0
diff --git a/node_modules/fp-ts/lib/Reader.js b/node_modules/fp-ts/lib/Reader.js
index cedbaa6..0b5fdb7 100644
--- a/node_modules/fp-ts/lib/Reader.js
+++ b/node_modules/fp-ts/lib/Reader.js
@@ -19,8 +19,8 @@ var __importStar = (this && this.__importStar) || function (mod) {
     return result;
 };
 Object.defineProperty(exports, "__esModule", { value: true });
-exports.sequenceArray = exports.traverseArray = exports.traverseArrayWithIndex = exports.traverseReadonlyArrayWithIndex = exports.traverseReadonlyNonEmptyArrayWithIndex = exports.ApT = exports.apSW = exports.apS = exports.Do = exports.bindW = exports.bind = exports.bindTo = exports.Choice = exports.Strong = exports.Category = exports.Profunctor = exports.chainFirstW = exports.chainFirst = exports.Monad = exports.Chain = exports.Applicative = exports.apSecondW = exports.apSecond = exports.apFirstW = exports.apFirst = exports.Apply = exports.Pointed = exports.flap = exports.Functor = exports.URI = exports.right = exports.left = exports.second = exports.first = exports.id = exports.promap = exports.compose = exports.flatten = exports.flattenW = exports.chain = exports.chainW = exports.of = exports.ap = exports.apW = exports.map = exports.asksReader = exports.asksReaderW = exports.local = exports.asks = exports.ask = void 0;
-exports.getMonoid = exports.getSemigroup = exports.reader = void 0;
+exports.getSemigroup = exports.reader = exports.sequenceArray = exports.traverseArray = exports.traverseArrayWithIndex = exports.traverseReadonlyArrayWithIndex = exports.traverseReadonlyNonEmptyArrayWithIndex = exports.ApT = exports.apSW = exports.apS = exports.Do = exports.bindW = exports.bind = exports.bindTo = exports.Choice = exports.Strong = exports.Category = exports.Profunctor = exports.chainFirstW = exports.chainFirst = exports.Monad = exports.Chain = exports.Applicative = exports.apSecond = exports.apFirst = exports.Apply = exports.Pointed = exports.flap = exports.Functor = exports.URI = exports.right = exports.left = exports.second = exports.first = exports.id = exports.promap = exports.compose = exports.flatten = exports.flattenW = exports.chain = exports.chainW = exports.of = exports.ap = exports.apW = exports.map = exports.asksReader = exports.asksReaderW = exports.local = exports.asks = exports.ask = void 0;
+exports.getMonoid = void 0;
 /**
  * @since 2.0.0
  */
@@ -253,13 +253,6 @@ exports.Apply = {
 exports.apFirst = 
 /*#__PURE__*/
 Apply_1.apFirst(exports.Apply);
-/**
- * Less strict version of [`apFirst`](#apfirst).
- *
- * @category combinators
- * @since 2.12.0
- */
-exports.apFirstW = exports.apFirst;
 /**
  * Combine two effectful actions, keeping only the result of the second.
  *
@@ -271,13 +264,6 @@ exports.apFirstW = exports.apFirst;
 exports.apSecond = 
 /*#__PURE__*/
 Apply_1.apSecond(exports.Apply);
-/**
- * Less strict version of [`apSecond`](#apsecond).
- *
- * @category combinators
- * @since 2.12.0
- */
-exports.apSecondW = exports.apSecond;
 /**
  * @category instances
  * @since 2.7.0
diff --git a/node_modules/fp-ts/lib/ReaderEither.d.ts b/node_modules/fp-ts/lib/ReaderEither.d.ts
index 63ff3e8..018eb5b 100644
--- a/node_modules/fp-ts/lib/ReaderEither.d.ts
+++ b/node_modules/fp-ts/lib/ReaderEither.d.ts
@@ -376,15 +376,6 @@ export declare const Apply: Apply3<URI>
 export declare const apFirst: <R, E, B>(
   second: ReaderEither<R, E, B>
 ) => <A>(first: ReaderEither<R, E, A>) => ReaderEither<R, E, A>
-/**
- * Less strict version of [`apFirst`](#apfirst)
- *
- * @category combinators
- * @since 2.12.0
- */
-export declare const apFirstW: <R2, E2, A, B>(
-  second: ReaderEither<R2, E2, B>
-) => <R1, E1>(first: ReaderEither<R1, E1, A>) => ReaderEither<R1 & R2, E1 | E2, A>
 /**
  * Combine two effectful actions, keeping only the result of the second.
  *
@@ -396,15 +387,6 @@ export declare const apFirstW: <R2, E2, A, B>(
 export declare const apSecond: <R, E, B>(
   second: ReaderEither<R, E, B>
 ) => <A>(first: ReaderEither<R, E, A>) => ReaderEither<R, E, B>
-/**
- * Less strict version of [`apSecond`](#apsecond)
- *
- * @category combinators
- * @since 2.12.0
- */
-export declare const apSecondW: <R2, E2, A, B>(
-  second: ReaderEither<R2, E2, B>
-) => <R1, E1>(first: ReaderEither<R1, E1, A>) => ReaderEither<R1 & R2, E1 | E2, B>
 /**
  * @category instances
  * @since 2.7.0
@@ -558,22 +540,6 @@ export declare const chainEitherK: <E, A, B>(
 export declare const chainEitherKW: <E2, A, B>(
   f: (a: A) => Either<E2, B>
 ) => <R, E1>(ma: ReaderEither<R, E1, A>) => ReaderEither<R, E1 | E2, B>
-/**
- * @category combinators
- * @since 2.12.0
- */
-export declare const chainFirstEitherK: <A, E, B>(
-  f: (a: A) => E.Either<E, B>
-) => <R>(ma: ReaderEither<R, E, A>) => ReaderEither<R, E, A>
-/**
- * Less strict version of [`chainFirstEitherK`](#chainfirsteitherk).
- *
- * @category combinators
- * @since 2.12.0
- */
-export declare const chainFirstEitherKW: <A, E2, B>(
-  f: (a: A) => Either<E2, B>
-) => <R, E1>(ma: ReaderEither<R, E1, A>) => ReaderEither<R, E1 | E2, A>
 /**
  * @category constructors
  * @since 2.0.0
diff --git a/node_modules/fp-ts/lib/ReaderEither.js b/node_modules/fp-ts/lib/ReaderEither.js
index ce8054a..afd2bf0 100644
--- a/node_modules/fp-ts/lib/ReaderEither.js
+++ b/node_modules/fp-ts/lib/ReaderEither.js
@@ -19,8 +19,8 @@ var __importStar = (this && this.__importStar) || function (mod) {
     return result;
 };
 Object.defineProperty(exports, "__esModule", { value: true });
-exports.apSecondW = exports.apSecond = exports.apFirstW = exports.apFirst = exports.Apply = exports.Pointed = exports.flap = exports.Functor = exports.getAltReaderValidation = exports.getApplicativeReaderValidation = exports.getFilterable = exports.getCompactable = exports.URI = exports.throwError = exports.altW = exports.alt = exports.flatten = exports.flattenW = exports.chainW = exports.chain = exports.of = exports.apW = exports.ap = exports.mapLeft = exports.bimap = exports.map = exports.swap = exports.orLeft = exports.orElseFirstW = exports.orElseFirst = exports.orElseW = exports.orElse = exports.asksReaderEither = exports.asksReaderEitherW = exports.local = exports.toUnion = exports.getOrElseW = exports.getOrElse = exports.foldW = exports.matchEW = exports.fold = exports.matchE = exports.matchW = exports.match = exports.fromReader = exports.fromEither = exports.leftReader = exports.rightReader = exports.right = exports.left = void 0;
-exports.getReaderValidation = exports.getSemigroup = exports.getApplyMonoid = exports.getApplySemigroup = exports.readerEither = exports.sequenceArray = exports.traverseArray = exports.traverseArrayWithIndex = exports.traverseReadonlyArrayWithIndex = exports.traverseReadonlyNonEmptyArrayWithIndex = exports.ApT = exports.apSW = exports.apS = exports.bindW = exports.bind = exports.bindTo = exports.Do = exports.fromEitherK = exports.filterOrElseW = exports.filterOrElse = exports.fromPredicate = exports.chainFirstEitherKW = exports.chainFirstEitherK = exports.chainEitherKW = exports.chainEitherK = exports.chainOptionK = exports.fromOptionK = exports.fromOption = exports.FromEither = exports.MonadThrow = exports.chainFirstReaderKW = exports.chainFirstReaderK = exports.chainReaderKW = exports.chainReaderK = exports.fromReaderK = exports.asks = exports.ask = exports.FromReader = exports.Alt = exports.Bifunctor = exports.chainFirstW = exports.chainFirst = exports.Monad = exports.Chain = exports.Applicative = void 0;
+exports.Chain = exports.Applicative = exports.apSecond = exports.apFirst = exports.Apply = exports.Pointed = exports.flap = exports.Functor = exports.getAltReaderValidation = exports.getApplicativeReaderValidation = exports.getFilterable = exports.getCompactable = exports.URI = exports.throwError = exports.altW = exports.alt = exports.flatten = exports.flattenW = exports.chainW = exports.chain = exports.of = exports.apW = exports.ap = exports.mapLeft = exports.bimap = exports.map = exports.swap = exports.orLeft = exports.orElseFirstW = exports.orElseFirst = exports.orElseW = exports.orElse = exports.asksReaderEither = exports.asksReaderEitherW = exports.local = exports.toUnion = exports.getOrElseW = exports.getOrElse = exports.foldW = exports.matchEW = exports.fold = exports.matchE = exports.matchW = exports.match = exports.fromReader = exports.fromEither = exports.leftReader = exports.rightReader = exports.right = exports.left = void 0;
+exports.getReaderValidation = exports.getSemigroup = exports.getApplyMonoid = exports.getApplySemigroup = exports.readerEither = exports.sequenceArray = exports.traverseArray = exports.traverseArrayWithIndex = exports.traverseReadonlyArrayWithIndex = exports.traverseReadonlyNonEmptyArrayWithIndex = exports.ApT = exports.apSW = exports.apS = exports.bindW = exports.bind = exports.bindTo = exports.Do = exports.fromEitherK = exports.filterOrElseW = exports.filterOrElse = exports.fromPredicate = exports.chainEitherKW = exports.chainEitherK = exports.chainOptionK = exports.fromOptionK = exports.fromOption = exports.FromEither = exports.MonadThrow = exports.chainFirstReaderKW = exports.chainFirstReaderK = exports.chainReaderKW = exports.chainReaderK = exports.fromReaderK = exports.asks = exports.ask = exports.FromReader = exports.Alt = exports.Bifunctor = exports.chainFirstW = exports.chainFirst = exports.Monad = void 0;
 var Applicative_1 = require("./Applicative");
 var Apply_1 = require("./Apply");
 var Chain_1 = require("./Chain");
@@ -453,13 +453,6 @@ exports.Apply = {
 exports.apFirst = 
 /*#__PURE__*/
 Apply_1.apFirst(exports.Apply);
-/**
- * Less strict version of [`apFirst`](#apfirst)
- *
- * @category combinators
- * @since 2.12.0
- */
-exports.apFirstW = exports.apFirst;
 /**
  * Combine two effectful actions, keeping only the result of the second.
  *
@@ -471,13 +464,6 @@ exports.apFirstW = exports.apFirst;
 exports.apSecond = 
 /*#__PURE__*/
 Apply_1.apSecond(exports.Apply);
-/**
- * Less strict version of [`apSecond`](#apsecond)
- *
- * @category combinators
- * @since 2.12.0
- */
-exports.apSecondW = exports.apSecond;
 /**
  * @category instances
  * @since 2.7.0
@@ -664,20 +650,6 @@ FromEither_1.chainEitherK(exports.FromEither, exports.Chain);
  * @since 2.6.1
  */
 exports.chainEitherKW = exports.chainEitherK;
-/**
- * @category combinators
- * @since 2.12.0
- */
-exports.chainFirstEitherK = 
-/*#__PURE__*/
-FromEither_1.chainFirstEitherK(exports.FromEither, exports.Chain);
-/**
- * Less strict version of [`chainFirstEitherK`](#chainfirsteitherk).
- *
- * @category combinators
- * @since 2.12.0
- */
-exports.chainFirstEitherKW = exports.chainFirstEitherK;
 /**
  * @category constructors
  * @since 2.0.0
diff --git a/node_modules/fp-ts/lib/ReaderTaskEither.d.ts b/node_modules/fp-ts/lib/ReaderTaskEither.d.ts
index 7683671..aadce0b 100644
--- a/node_modules/fp-ts/lib/ReaderTaskEither.d.ts
+++ b/node_modules/fp-ts/lib/ReaderTaskEither.d.ts
@@ -208,29 +208,6 @@ export declare const getOrElseW: <R2, E, B>(
  * @since 2.10.0
  */
 export declare const toUnion: <R, E, A>(fa: ReaderTaskEither<R, E, A>) => ReaderTask<R, E | A>
-/**
- * @category interop
- * @since 2.12.0
- */
-export declare const fromNullable: <E>(e: E) => <R, A>(a: A) => ReaderTaskEither<R, E, NonNullable<A>>
-/**
- * @category interop
- * @since 2.12.0
- */
-export declare const fromNullableK: <E>(
-  e: E
-) => <A extends ReadonlyArray<unknown>, B>(
-  f: (...a: A) => B | null | undefined
-) => <R>(...a: A) => ReaderTaskEither<R, E, NonNullable<B>>
-/**
- * @category interop
- * @since 2.12.0
- */
-export declare const chainNullableK: <E>(
-  e: E
-) => <A, B>(
-  f: (a: A) => B | null | undefined
-) => <R>(ma: ReaderTaskEither<R, E, A>) => ReaderTaskEither<R, E, NonNullable<B>>
 /**
  * Changes the value of the local context during the execution of the action `ma` (similar to `Contravariant`'s
  * `contramap`).
@@ -580,15 +557,6 @@ export declare const ApplyPar: Apply3<URI>
 export declare const apFirst: <R, E, B>(
   second: ReaderTaskEither<R, E, B>
 ) => <A>(first: ReaderTaskEither<R, E, A>) => ReaderTaskEither<R, E, A>
-/**
- * Less strict version of [`apFirst`](#apfirst).
- *
- * @category combinators
- * @since 2.12.0
- */
-export declare const apFirstW: <R2, E2, A, B>(
-  second: ReaderTaskEither<R2, E2, B>
-) => <R1, E1>(first: ReaderTaskEither<R1, E1, A>) => ReaderTaskEither<R1 & R2, E1 | E2, A>
 /**
  * Combine two effectful actions, keeping only the result of the second.
  *
@@ -600,15 +568,6 @@ export declare const apFirstW: <R2, E2, A, B>(
 export declare const apSecond: <R, E, B>(
   second: ReaderTaskEither<R, E, B>
 ) => <A>(first: ReaderTaskEither<R, E, A>) => ReaderTaskEither<R, E, B>
-/**
- * Less strict version of [`apSecond`](#apsecond).
- *
- * @category combinators
- * @since 2.12.0
- */
-export declare const apSecondW: <R2, E2, A, B>(
-  second: ReaderTaskEither<R2, E2, B>
-) => <R1, E1>(first: ReaderTaskEither<R1, E1, A>) => ReaderTaskEither<R1 & R2, E1 | E2, B>
 /**
  * @category instances
  * @since 2.7.0
@@ -823,22 +782,6 @@ export declare const chainEitherK: <E, A, B>(
 export declare const chainEitherKW: <E2, A, B>(
   f: (a: A) => Either<E2, B>
 ) => <R, E1>(ma: ReaderTaskEither<R, E1, A>) => ReaderTaskEither<R, E1 | E2, B>
-/**
- * @category combinators
- * @since 2.12.0
- */
-export declare const chainFirstEitherK: <A, E, B>(
-  f: (a: A) => E.Either<E, B>
-) => <R>(ma: ReaderTaskEither<R, E, A>) => ReaderTaskEither<R, E, A>
-/**
- * Less strict version of [`chainFirstEitherK`](#chainfirsteitherk).
- *
- * @category combinators
- * @since 2.12.0
- */
-export declare const chainFirstEitherKW: <A, E2, B>(
-  f: (a: A) => Either<E2, B>
-) => <R, E1>(ma: ReaderTaskEither<R, E1, A>) => ReaderTaskEither<R, E1 | E2, A>
 /**
  * @category constructors
  * @since 2.0.0
@@ -946,20 +889,10 @@ export declare const chainFirstTaskK: <A, B>(
  * @since 2.0.4
  */
 export declare function bracket<R, E, A, B>(
-  acquire: ReaderTaskEither<R, E, A>,
+  aquire: ReaderTaskEither<R, E, A>,
   use: (a: A) => ReaderTaskEither<R, E, B>,
   release: (a: A, e: Either<E, B>) => ReaderTaskEither<R, E, void>
 ): ReaderTaskEither<R, E, B>
-/**
- * Less strict version of [`bracket`](#bracket).
- *
- * @since 2.12.0
- */
-export declare function bracketW<R1, E1, A, R2, E2, B, R3, E3>(
-  acquire: ReaderTaskEither<R1, E1, A>,
-  use: (a: A) => ReaderTaskEither<R2, E2, B>,
-  release: (a: A, e: Either<E2, B>) => ReaderTaskEither<R3, E3, void>
-): ReaderTaskEither<R1 & R2 & R3, E1 | E2 | E3, B>
 /**
  * @since 2.9.0
  */
diff --git a/node_modules/fp-ts/lib/ReaderTaskEither.js b/node_modules/fp-ts/lib/ReaderTaskEither.js
index 4398355..6323aa8 100644
--- a/node_modules/fp-ts/lib/ReaderTaskEither.js
+++ b/node_modules/fp-ts/lib/ReaderTaskEither.js
@@ -19,9 +19,9 @@ var __importStar = (this && this.__importStar) || function (mod) {
     return result;
 };
 Object.defineProperty(exports, "__esModule", { value: true });
-exports.chainFirstReaderEitherKW = exports.chainReaderEitherK = exports.chainReaderEitherKW = exports.fromReaderEitherK = exports.chainFirstTaskEitherK = exports.chainFirstTaskEitherKW = exports.chainTaskEitherK = exports.chainTaskEitherKW = exports.fromTaskEitherK = exports.chainIOEitherK = exports.chainIOEitherKW = exports.fromIOEitherK = exports.swap = exports.orLeft = exports.orElseFirstW = exports.orElseFirst = exports.orElseW = exports.orElse = exports.asksReaderTaskEither = exports.asksReaderTaskEitherW = exports.local = exports.chainNullableK = exports.fromNullableK = exports.fromNullable = exports.toUnion = exports.getOrElseW = exports.getOrElse = exports.foldW = exports.matchEW = exports.fold = exports.matchE = exports.matchW = exports.match = exports.fromReaderEither = exports.fromIOEither = exports.fromTask = exports.fromIO = exports.fromReader = exports.fromEither = exports.leftIO = exports.rightIO = exports.leftReaderTask = exports.rightReaderTask = exports.leftReader = exports.rightReader = exports.leftTask = exports.rightTask = exports.right = exports.left = exports.fromTaskEither = void 0;
-exports.chainReaderTaskK = exports.chainReaderTaskKW = exports.fromReaderTaskK = exports.chainFirstReaderKW = exports.chainFirstReaderK = exports.chainReaderKW = exports.chainReaderK = exports.fromReaderK = exports.asks = exports.ask = exports.FromReader = exports.Alt = exports.Bifunctor = exports.chainFirstW = exports.chainFirst = exports.MonadThrow = exports.MonadTask = exports.MonadIO = exports.Monad = exports.Chain = exports.ApplicativeSeq = exports.ApplySeq = exports.ApplicativePar = exports.apSecondW = exports.apSecond = exports.apFirstW = exports.apFirst = exports.ApplyPar = exports.Pointed = exports.flap = exports.Functor = exports.getAltReaderTaskValidation = exports.getApplicativeReaderTaskValidation = exports.getFilterable = exports.getCompactable = exports.URI = exports.throwError = exports.altW = exports.alt = exports.flatten = exports.flattenW = exports.chainW = exports.chain = exports.of = exports.apW = exports.ap = exports.mapLeft = exports.bimap = exports.map = exports.chainFirstReaderEitherK = void 0;
-exports.run = exports.getReaderTaskValidation = exports.getSemigroup = exports.getApplyMonoid = exports.getApplySemigroup = exports.readerTaskEitherSeq = exports.readerTaskEither = exports.sequenceSeqArray = exports.traverseSeqArray = exports.traverseSeqArrayWithIndex = exports.sequenceArray = exports.traverseArray = exports.traverseArrayWithIndex = exports.traverseReadonlyArrayWithIndexSeq = exports.traverseReadonlyNonEmptyArrayWithIndexSeq = exports.traverseReadonlyArrayWithIndex = exports.traverseReadonlyNonEmptyArrayWithIndex = exports.ApT = exports.apSW = exports.apS = exports.bindW = exports.bind = exports.bindTo = exports.Do = exports.bracketW = exports.bracket = exports.chainFirstTaskK = exports.chainTaskK = exports.fromTaskK = exports.FromTask = exports.chainFirstIOK = exports.chainIOK = exports.fromIOK = exports.FromIO = exports.fromEitherK = exports.filterOrElseW = exports.filterOrElse = exports.fromPredicate = exports.chainFirstEitherKW = exports.chainFirstEitherK = exports.chainEitherKW = exports.chainEitherK = exports.chainOptionK = exports.fromOptionK = exports.fromOption = exports.FromEither = exports.chainFirstReaderTaskK = exports.chainFirstReaderTaskKW = void 0;
+exports.bimap = exports.map = exports.chainFirstReaderEitherK = exports.chainFirstReaderEitherKW = exports.chainReaderEitherK = exports.chainReaderEitherKW = exports.fromReaderEitherK = exports.chainFirstTaskEitherK = exports.chainFirstTaskEitherKW = exports.chainTaskEitherK = exports.chainTaskEitherKW = exports.fromTaskEitherK = exports.chainIOEitherK = exports.chainIOEitherKW = exports.fromIOEitherK = exports.swap = exports.orLeft = exports.orElseFirstW = exports.orElseFirst = exports.orElseW = exports.orElse = exports.asksReaderTaskEither = exports.asksReaderTaskEitherW = exports.local = exports.toUnion = exports.getOrElseW = exports.getOrElse = exports.foldW = exports.matchEW = exports.fold = exports.matchE = exports.matchW = exports.match = exports.fromReaderEither = exports.fromIOEither = exports.fromTask = exports.fromIO = exports.fromReader = exports.fromEither = exports.leftIO = exports.rightIO = exports.leftReaderTask = exports.rightReaderTask = exports.leftReader = exports.rightReader = exports.leftTask = exports.rightTask = exports.right = exports.left = exports.fromTaskEither = void 0;
+exports.fromOptionK = exports.fromOption = exports.FromEither = exports.chainFirstReaderTaskK = exports.chainFirstReaderTaskKW = exports.chainReaderTaskK = exports.chainReaderTaskKW = exports.fromReaderTaskK = exports.chainFirstReaderKW = exports.chainFirstReaderK = exports.chainReaderKW = exports.chainReaderK = exports.fromReaderK = exports.asks = exports.ask = exports.FromReader = exports.Alt = exports.Bifunctor = exports.chainFirstW = exports.chainFirst = exports.MonadThrow = exports.MonadTask = exports.MonadIO = exports.Monad = exports.Chain = exports.ApplicativeSeq = exports.ApplySeq = exports.ApplicativePar = exports.apSecond = exports.apFirst = exports.ApplyPar = exports.Pointed = exports.flap = exports.Functor = exports.getAltReaderTaskValidation = exports.getApplicativeReaderTaskValidation = exports.getFilterable = exports.getCompactable = exports.URI = exports.throwError = exports.altW = exports.alt = exports.flatten = exports.flattenW = exports.chainW = exports.chain = exports.of = exports.apW = exports.ap = exports.mapLeft = void 0;
+exports.run = exports.getReaderTaskValidation = exports.getSemigroup = exports.getApplyMonoid = exports.getApplySemigroup = exports.readerTaskEitherSeq = exports.readerTaskEither = exports.sequenceSeqArray = exports.traverseSeqArray = exports.traverseSeqArrayWithIndex = exports.sequenceArray = exports.traverseArray = exports.traverseArrayWithIndex = exports.traverseReadonlyArrayWithIndexSeq = exports.traverseReadonlyNonEmptyArrayWithIndexSeq = exports.traverseReadonlyArrayWithIndex = exports.traverseReadonlyNonEmptyArrayWithIndex = exports.ApT = exports.apSW = exports.apS = exports.bindW = exports.bind = exports.bindTo = exports.Do = exports.bracket = exports.chainFirstTaskK = exports.chainTaskK = exports.fromTaskK = exports.FromTask = exports.chainFirstIOK = exports.chainIOK = exports.fromIOK = exports.FromIO = exports.fromEitherK = exports.filterOrElseW = exports.filterOrElse = exports.fromPredicate = exports.chainEitherKW = exports.chainEitherK = exports.chainOptionK = void 0;
 var Applicative_1 = require("./Applicative");
 var Apply_1 = require("./Apply");
 var Chain_1 = require("./Chain");
@@ -227,27 +227,6 @@ exports.getOrElseW = exports.getOrElse;
 exports.toUnion = 
 /*#__PURE__*/
 ET.toUnion(RT.Functor);
-/**
- * @category interop
- * @since 2.12.0
- */
-exports.fromNullable = 
-/*#__PURE__*/
-ET.fromNullable(RT.Pointed);
-/**
- * @category interop
- * @since 2.12.0
- */
-exports.fromNullableK = 
-/*#__PURE__*/
-ET.fromNullableK(RT.Pointed);
-/**
- * @category interop
- * @since 2.12.0
- */
-exports.chainNullableK = 
-/*#__PURE__*/
-ET.chainNullableK(RT.Monad);
 // -------------------------------------------------------------------------------------
 // combinators
 // -------------------------------------------------------------------------------------
@@ -642,13 +621,6 @@ exports.ApplyPar = {
 exports.apFirst = 
 /*#__PURE__*/
 Apply_1.apFirst(exports.ApplyPar);
-/**
- * Less strict version of [`apFirst`](#apfirst).
- *
- * @category combinators
- * @since 2.12.0
- */
-exports.apFirstW = exports.apFirst;
 /**
  * Combine two effectful actions, keeping only the result of the second.
  *
@@ -660,13 +632,6 @@ exports.apFirstW = exports.apFirst;
 exports.apSecond = 
 /*#__PURE__*/
 Apply_1.apSecond(exports.ApplyPar);
-/**
- * Less strict version of [`apSecond`](#apsecond).
- *
- * @category combinators
- * @since 2.12.0
- */
-exports.apSecondW = exports.apSecond;
 /**
  * @category instances
  * @since 2.7.0
@@ -939,20 +904,6 @@ FromEither_1.chainEitherK(exports.FromEither, exports.Chain);
  * @since 2.6.1
  */
 exports.chainEitherKW = exports.chainEitherK;
-/**
- * @category combinators
- * @since 2.12.0
- */
-exports.chainFirstEitherK = 
-/*#__PURE__*/
-FromEither_1.chainFirstEitherK(exports.FromEither, exports.Chain);
-/**
- * Less strict version of [`chainFirstEitherK`](#chainfirsteitherk).
- *
- * @category combinators
- * @since 2.12.0
- */
-exports.chainFirstEitherKW = exports.chainFirstEitherK;
 /**
  * @category constructors
  * @since 2.0.0
@@ -1051,21 +1002,12 @@ FromTask_1.chainFirstTaskK(exports.FromTask, exports.Chain);
  *
  * @since 2.0.4
  */
-function bracket(acquire, use, release) {
-    return bracketW(acquire, use, release);
-}
-exports.bracket = bracket;
-/**
- * Less strict version of [`bracket`](#bracket).
- *
- * @since 2.12.0
- */
-function bracketW(acquire, use, release) {
+function bracket(aquire, use, release) {
     return function (r) {
-        return TE.bracketW(acquire(r), function (a) { return use(a)(r); }, function (a, e) { return release(a, e)(r); });
+        return TE.bracket(aquire(r), function (a) { return use(a)(r); }, function (a, e) { return release(a, e)(r); });
     };
 }
-exports.bracketW = bracketW;
+exports.bracket = bracket;
 // -------------------------------------------------------------------------------------
 // do notation
 // -------------------------------------------------------------------------------------
diff --git a/node_modules/fp-ts/lib/ReadonlyArray.d.ts b/node_modules/fp-ts/lib/ReadonlyArray.d.ts
index 6846a51..a339d8e 100644
--- a/node_modules/fp-ts/lib/ReadonlyArray.d.ts
+++ b/node_modules/fp-ts/lib/ReadonlyArray.d.ts
@@ -1548,10 +1548,7 @@ export declare const empty: ReadonlyArray<never>
  *
  * @since 2.9.0
  */
-export declare function every<A, B extends A>(
-  refinement: Refinement<A, B>
-): Refinement<ReadonlyArray<A>, ReadonlyArray<B>>
-export declare function every<A>(predicate: Predicate<A>): Predicate<ReadonlyArray<A>>
+export declare const every: <A>(predicate: Predicate<A>) => (as: readonly A[]) => boolean
 /**
  * Check if a predicate holds true for any array member.
  *
@@ -1573,18 +1570,6 @@ export declare const some: <A>(predicate: Predicate<A>) => (as: readonly A[]) =>
  * @since 2.11.0
  */
 export declare const exists: <A>(predicate: Predicate<A>) => (as: readonly A[]) => as is RNEA.ReadonlyNonEmptyArray<A>
-/**
- * Places an element in between members of a `ReadonlyArray`, then folds the results using the provided `Monoid`.
- *
- * @example
- * import * as S from 'fp-ts/string'
- * import { intercalate } from 'fp-ts/Array'
- *
- * assert.deepStrictEqual(intercalate(S.Monoid)('-')(['a', 'b', 'c']), 'a-b-c')
- *
- * @since 2.12.0
- */
-export declare const intercalate: <A>(M: Monoid<A>) => (middle: A) => (as: readonly A[]) => A
 /**
  * @since 2.9.0
  */
diff --git a/node_modules/fp-ts/lib/ReadonlyArray.js b/node_modules/fp-ts/lib/ReadonlyArray.js
index f1645f8..92d3600 100644
--- a/node_modules/fp-ts/lib/ReadonlyArray.js
+++ b/node_modules/fp-ts/lib/ReadonlyArray.js
@@ -27,7 +27,7 @@ Object.defineProperty(exports, "__esModule", { value: true });
 exports.sort = exports.lefts = exports.rights = exports.reverse = exports.modifyAt = exports.deleteAt = exports.updateAt = exports.insertAt = exports.findLastIndex = exports.findLastMap = exports.findLast = exports.findFirstMap = exports.findFirst = exports.findIndex = exports.dropLeftWhile = exports.dropRight = exports.dropLeft = exports.spanLeft = exports.takeLeftWhile = exports.takeRight = exports.takeLeft = exports.init = exports.tail = exports.last = exports.head = exports.lookup = exports.isOutOfBound = exports.size = exports.scanRight = exports.scanLeft = exports.chainWithIndex = exports.foldRight = exports.matchRight = exports.matchRightW = exports.foldLeft = exports.matchLeft = exports.matchLeftW = exports.match = exports.matchW = exports.fromEither = exports.fromOption = exports.fromPredicate = exports.replicate = exports.makeBy = exports.appendW = exports.append = exports.prependW = exports.prepend = exports.isNonEmpty = exports.isEmpty = void 0;
 exports.sequence = exports.traverse = exports.reduceRightWithIndex = exports.reduceRight = exports.reduceWithIndex = exports.foldMap = exports.reduce = exports.foldMapWithIndex = exports.duplicate = exports.extend = exports.filterWithIndex = exports.partitionMapWithIndex = exports.partitionMap = exports.partitionWithIndex = exports.partition = exports.compact = exports.filterMap = exports.filterMapWithIndex = exports.filter = exports.separate = exports.mapWithIndex = exports.map = exports.flatten = exports.chain = exports.ap = exports.alt = exports.altW = exports.zero = exports.of = exports._chainRecBreadthFirst = exports._chainRecDepthFirst = exports.difference = exports.intersection = exports.union = exports.concat = exports.concatW = exports.comprehension = exports.fromOptionK = exports.chunksOf = exports.splitAt = exports.chop = exports.sortBy = exports.uniq = exports.elem = exports.rotate = exports.intersperse = exports.prependAll = exports.unzip = exports.zip = exports.zipWith = void 0;
 exports.toArray = exports.unsafeDeleteAt = exports.unsafeUpdateAt = exports.unsafeInsertAt = exports.fromEitherK = exports.FromEither = exports.filterE = exports.Witherable = exports.ChainRecBreadthFirst = exports.chainRecBreadthFirst = exports.ChainRecDepthFirst = exports.chainRecDepthFirst = exports.TraversableWithIndex = exports.Traversable = exports.FoldableWithIndex = exports.Foldable = exports.FilterableWithIndex = exports.Filterable = exports.Compactable = exports.Extend = exports.Alternative = exports.guard = exports.Zero = exports.Alt = exports.Unfoldable = exports.chainFirst = exports.Monad = exports.Chain = exports.Applicative = exports.apSecond = exports.apFirst = exports.Apply = exports.FunctorWithIndex = exports.Pointed = exports.flap = exports.Functor = exports.getDifferenceMagma = exports.getIntersectionSemigroup = exports.getUnionMonoid = exports.getUnionSemigroup = exports.getOrd = exports.getEq = exports.getMonoid = exports.getSemigroup = exports.getShow = exports.URI = exports.unfold = exports.wilt = exports.wither = exports.traverseWithIndex = void 0;
-exports.readonlyArray = exports.prependToAll = exports.snoc = exports.cons = exports.range = exports.apS = exports.bind = exports.bindTo = exports.Do = exports.intercalate = exports.exists = exports.some = exports.every = exports.empty = exports.fromArray = void 0;
+exports.readonlyArray = exports.prependToAll = exports.snoc = exports.cons = exports.range = exports.apS = exports.bind = exports.bindTo = exports.Do = exports.exists = exports.some = exports.every = exports.empty = exports.fromArray = void 0;
 var Apply_1 = require("./Apply");
 var Chain_1 = require("./Chain");
 var Eq_1 = require("./Eq");
@@ -2020,9 +2020,21 @@ exports.fromArray = fromArray;
  * @since 2.5.0
  */
 exports.empty = RNEA.empty;
-function every(predicate) {
-    return function (as) { return as.every(predicate); };
-}
+/**
+ * Check if a predicate holds true for every array member.
+ *
+ * @example
+ * import { every } from 'fp-ts/ReadonlyArray'
+ * import { pipe } from 'fp-ts/function'
+ *
+ * const isPositive = (n: number): boolean => n > 0
+ *
+ * assert.deepStrictEqual(pipe([1, 2, 3], every(isPositive)), true)
+ * assert.deepStrictEqual(pipe([1, 2, -3], every(isPositive)), false)
+ *
+ * @since 2.9.0
+ */
+var every = function (predicate) { return function (as) { return as.every(predicate); }; };
 exports.every = every;
 /**
  * Check if a predicate holds true for any array member.
@@ -2048,22 +2060,6 @@ exports.some = some;
  * @since 2.11.0
  */
 exports.exists = exports.some;
-/**
- * Places an element in between members of a `ReadonlyArray`, then folds the results using the provided `Monoid`.
- *
- * @example
- * import * as S from 'fp-ts/string'
- * import { intercalate } from 'fp-ts/Array'
- *
- * assert.deepStrictEqual(intercalate(S.Monoid)('-')(['a', 'b', 'c']), 'a-b-c')
- *
- * @since 2.12.0
- */
-var intercalate = function (M) {
-    var intercalateM = RNEA.intercalate(M);
-    return function (middle) { return exports.match(function () { return M.empty; }, intercalateM(middle)); };
-};
-exports.intercalate = intercalate;
 // -------------------------------------------------------------------------------------
 // do notation
 // -------------------------------------------------------------------------------------
diff --git a/node_modules/fp-ts/lib/ReadonlyNonEmptyArray.d.ts b/node_modules/fp-ts/lib/ReadonlyNonEmptyArray.d.ts
index 31403de..bcf837e 100644
--- a/node_modules/fp-ts/lib/ReadonlyNonEmptyArray.d.ts
+++ b/node_modules/fp-ts/lib/ReadonlyNonEmptyArray.d.ts
@@ -768,18 +768,6 @@ export declare const modifyLast: <A>(f: Endomorphism<A>) => (as: ReadonlyNonEmpt
  * @since 2.11.0
  */
 export declare const updateLast: <A>(a: A) => (as: ReadonlyNonEmptyArray<A>) => ReadonlyNonEmptyArray<A>
-/**
- * Places an element in between members of a `ReadonlyNonEmptyArray`, then folds the results using the provided `Semigroup`.
- *
- * @example
- * import * as S from 'fp-ts/string'
- * import { intercalate } from 'fp-ts/ReadonlyNonEmptyArray'
- *
- * assert.deepStrictEqual(intercalate(S.Semigroup)('-')(['a', 'b', 'c']), 'a-b-c')
- *
- * @since 2.12.0
- */
-export declare const intercalate: <A>(S: Se.Semigroup<A>) => (middle: A) => (as: ReadonlyNonEmptyArray<A>) => A
 /**
  * This is just `sort` followed by `group`.
  *
diff --git a/node_modules/fp-ts/lib/ReadonlyNonEmptyArray.js b/node_modules/fp-ts/lib/ReadonlyNonEmptyArray.js
index 0fa4214..1509e82 100644
--- a/node_modules/fp-ts/lib/ReadonlyNonEmptyArray.js
+++ b/node_modules/fp-ts/lib/ReadonlyNonEmptyArray.js
@@ -25,8 +25,8 @@ var __spreadArray = (this && this.__spreadArray) || function (to, from) {
 };
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.reduceRight = exports.foldMap = exports.reduce = exports.mapWithIndex = exports.map = exports.flatten = exports.duplicate = exports.extend = exports.chain = exports.ap = exports.alt = exports.altW = exports.of = exports.chunksOf = exports.splitAt = exports.chop = exports.chainWithIndex = exports.intersperse = exports.prependAll = exports.unzip = exports.zip = exports.zipWith = exports.modifyAt = exports.updateAt = exports.sort = exports.groupBy = exports.group = exports.reverse = exports.concat = exports.concatW = exports.fromArray = exports.unappend = exports.unprepend = exports.range = exports.replicate = exports.makeBy = exports.fromReadonlyArray = exports.rotate = exports.union = exports.sortBy = exports.uniq = exports.unsafeUpdateAt = exports.unsafeInsertAt = exports.append = exports.appendW = exports.prepend = exports.prependW = exports.isOutOfBound = exports.isNonEmpty = exports.empty = void 0;
-exports.filterWithIndex = exports.filter = exports.groupSort = exports.intercalate = exports.updateLast = exports.modifyLast = exports.updateHead = exports.modifyHead = exports.matchRight = exports.matchLeft = exports.concatAll = exports.max = exports.min = exports.init = exports.last = exports.tail = exports.head = exports.apS = exports.bind = exports.bindTo = exports.Do = exports.Comonad = exports.Alt = exports.TraversableWithIndex = exports.Traversable = exports.FoldableWithIndex = exports.Foldable = exports.Monad = exports.chainFirst = exports.Chain = exports.Applicative = exports.apSecond = exports.apFirst = exports.Apply = exports.FunctorWithIndex = exports.Pointed = exports.flap = exports.Functor = exports.getUnionSemigroup = exports.getEq = exports.getSemigroup = exports.getShow = exports.URI = exports.extract = exports.traverseWithIndex = exports.sequence = exports.traverse = exports.reduceRightWithIndex = exports.foldMapWithIndex = exports.reduceWithIndex = void 0;
-exports.readonlyNonEmptyArray = exports.fold = exports.prependToAll = exports.insertAt = exports.snoc = exports.cons = exports.unsnoc = exports.uncons = void 0;
+exports.uncons = exports.filterWithIndex = exports.filter = exports.groupSort = exports.updateLast = exports.modifyLast = exports.updateHead = exports.modifyHead = exports.matchRight = exports.matchLeft = exports.concatAll = exports.max = exports.min = exports.init = exports.last = exports.tail = exports.head = exports.apS = exports.bind = exports.bindTo = exports.Do = exports.Comonad = exports.Alt = exports.TraversableWithIndex = exports.Traversable = exports.FoldableWithIndex = exports.Foldable = exports.Monad = exports.chainFirst = exports.Chain = exports.Applicative = exports.apSecond = exports.apFirst = exports.Apply = exports.FunctorWithIndex = exports.Pointed = exports.flap = exports.Functor = exports.getUnionSemigroup = exports.getEq = exports.getSemigroup = exports.getShow = exports.URI = exports.extract = exports.traverseWithIndex = exports.sequence = exports.traverse = exports.reduceRightWithIndex = exports.foldMapWithIndex = exports.reduceWithIndex = void 0;
+exports.readonlyNonEmptyArray = exports.fold = exports.prependToAll = exports.insertAt = exports.snoc = exports.cons = exports.unsnoc = void 0;
 var Apply_1 = require("./Apply");
 var Chain_1 = require("./Chain");
 var Eq_1 = require("./Eq");
@@ -1113,22 +1113,6 @@ exports.modifyLast = modifyLast;
  */
 var updateLast = function (a) { return exports.modifyLast(function () { return a; }); };
 exports.updateLast = updateLast;
-/**
- * Places an element in between members of a `ReadonlyNonEmptyArray`, then folds the results using the provided `Semigroup`.
- *
- * @example
- * import * as S from 'fp-ts/string'
- * import { intercalate } from 'fp-ts/ReadonlyNonEmptyArray'
- *
- * assert.deepStrictEqual(intercalate(S.Semigroup)('-')(['a', 'b', 'c']), 'a-b-c')
- *
- * @since 2.12.0
- */
-var intercalate = function (S) {
-    var concatAllS = exports.concatAll(S);
-    return function (middle) { return function_1.flow(exports.intersperse(middle), concatAllS); };
-};
-exports.intercalate = intercalate;
 function groupSort(O) {
     var sortO = exports.sort(O);
     var groupO = group(O);
diff --git a/node_modules/fp-ts/lib/ReadonlyRecord.d.ts b/node_modules/fp-ts/lib/ReadonlyRecord.d.ts
index 5efd0c4..92abdb6 100644
--- a/node_modules/fp-ts/lib/ReadonlyRecord.d.ts
+++ b/node_modules/fp-ts/lib/ReadonlyRecord.d.ts
@@ -23,14 +23,13 @@ import { Option } from './Option'
 import { Ord } from './Ord'
 import { Predicate } from './Predicate'
 import { Refinement } from './Refinement'
-import * as Se from './Semigroup'
+import { Semigroup } from './Semigroup'
 import { Separated } from './Separated'
 import { Show } from './Show'
 import { Traversable1 } from './Traversable'
 import { TraversableWithIndex1 } from './TraversableWithIndex'
 import { Unfoldable, Unfoldable1 } from './Unfoldable'
 import { PipeableWilt1, PipeableWither1, Witherable1 } from './Witherable'
-import Semigroup = Se.Semigroup
 /**
  * @category model
  * @since 2.5.0
@@ -218,7 +217,7 @@ export declare const updateAt: <A>(
   a: A
 ) => <K extends string>(r: Readonly<Record<K, A>>) => Option<Readonly<Record<K, A>>>
 /**
- * Applies a mapping function to one specific key/value pair in a `ReadonlyRecord`.
+ * Applies a mapping function to one spcific key/value pair in a `ReadonlyRecord`.
  *
  * @returns If the specified key exists it returns an `Option` containing a new `Record`
  * with the entry updated, otherwise it returns `None`
@@ -727,28 +726,6 @@ export declare function fromFoldableMap<F, B>(
   M: Magma<B>,
   F: FoldableHKT<F>
 ): <A>(fa: HKT<F, A>, f: (a: A) => readonly [string, B]) => ReadonlyRecord<string, B>
-/**
- * Alias of [`toReadonlyArray`](#toReadonlyArray).
- *
- * @since 2.12.0
- *
- * @example
- * import { toEntries } from 'fp-ts/Record'
- *
- * assert.deepStrictEqual(toEntries({ a: 1, b: 2 }), [['a', 1], ['b', 2]])
- */
-export declare const toEntries: <K extends string, A>(r: Readonly<Record<K, A>>) => readonly (readonly [K, A])[]
-/**
- * Converts an `Array` of `[key, value]` tuples into a `Record`.
- *
- * @since 2.12.0
- *
- * @example
- * import { fromEntries } from 'fp-ts/Record'
- *
- * assert.deepStrictEqual(fromEntries([['a', 1], ['b', 2], ['a', 3]]), { b: 2, a: 3 })
- */
-export declare const fromEntries: <A>(fa: readonly (readonly [string, A])[]) => Record<string, A>
 /**
  * Test if every value in a `ReadonlyRecord` satisfies the predicate.
  *
@@ -760,10 +737,7 @@ export declare const fromEntries: <A>(fa: readonly (readonly [string, A])[]) =>
  *
  * @since 2.5.0
  */
-export declare function every<A, B extends A>(
-  refinement: Refinement<A, B>
-): Refinement<ReadonlyRecord<string, A>, ReadonlyRecord<string, B>>
-export declare function every<A>(predicate: Predicate<A>): Predicate<ReadonlyRecord<string, A>>
+export declare function every<A>(predicate: Predicate<A>): (r: ReadonlyRecord<string, A>) => boolean
 /**
  * Test if at least one value in a `ReadonlyRecord` satisfies the predicate.
  *
@@ -1250,7 +1224,7 @@ export declare const getWitherable: (O: Ord<string>) => Witherable1<URI>
  * @category instances
  * @since 2.11.0
  */
-export declare const getUnionSemigroup: <A>(S: Se.Semigroup<A>) => Se.Semigroup<Readonly<Record<string, A>>>
+export declare const getUnionSemigroup: <A>(S: Semigroup<A>) => Semigroup<Readonly<Record<string, A>>>
 /**
  * Same as `getMonoid`.
  * Returns a `Monoid` instance for `ReadonlyRecord`s given a `Semigroup`
@@ -1268,7 +1242,7 @@ export declare const getUnionSemigroup: <A>(S: Se.Semigroup<A>) => Se.Semigroup<
  * @category instances
  * @since 2.11.0
  */
-export declare const getUnionMonoid: <A>(S: Se.Semigroup<A>) => Monoid<Readonly<Record<string, A>>>
+export declare const getUnionMonoid: <A>(S: Semigroup<A>) => Monoid<Readonly<Record<string, A>>>
 /**
  * Given a `Semigroup` in the base type, it produces a `Semigroup`
  * in the `ReadonlyRecord` of the base type.
@@ -1286,7 +1260,7 @@ export declare const getUnionMonoid: <A>(S: Se.Semigroup<A>) => Monoid<Readonly<
  * @category instances
  * @since 2.11.0
  */
-export declare const getIntersectionSemigroup: <A>(S: Se.Semigroup<A>) => Se.Semigroup<Readonly<Record<string, A>>>
+export declare const getIntersectionSemigroup: <A>(S: Semigroup<A>) => Semigroup<Readonly<Record<string, A>>>
 /**
  * Produces a `Magma` with a `concat` function that combines
  * two `ReadonlyRecord`s by making the `difference`.
diff --git a/node_modules/fp-ts/lib/ReadonlyRecord.js b/node_modules/fp-ts/lib/ReadonlyRecord.js
index 7b746f6..395b722 100644
--- a/node_modules/fp-ts/lib/ReadonlyRecord.js
+++ b/node_modules/fp-ts/lib/ReadonlyRecord.js
@@ -19,14 +19,12 @@ var __importStar = (this && this.__importStar) || function (mod) {
     return result;
 };
 Object.defineProperty(exports, "__esModule", { value: true });
-exports._partition = exports._filterMap = exports._filter = exports._reduceRight = exports._foldMap = exports._reduce = exports._mapWithIndex = exports._map = exports.difference = exports.intersection = exports.union = exports.elem = exports.some = exports.every = exports.fromEntries = exports.toEntries = exports.fromFoldableMap = exports.fromFoldable = exports.filterWithIndex = exports.filterMapWithIndex = exports.partitionWithIndex = exports.partitionMapWithIndex = exports.wilt = exports.wither = exports.sequence = exports.traverse = exports.traverseWithIndex = exports.singleton = exports.reduceRightWithIndex = exports.foldMapWithIndex = exports.reduceWithIndex = exports.map = exports.mapWithIndex = exports.empty = exports.lookup = exports.isSubrecord = exports.pop = exports.modifyAt = exports.updateAt = exports.deleteAt = exports.has = exports.upsertAt = exports.toUnfoldable = exports.toReadonlyArray = exports.collect = exports.keys = exports.isEmpty = exports.size = exports.toRecord = exports.fromRecord = void 0;
-exports.readonlyRecord = exports.hasOwnProperty = exports.insertAt = exports.Witherable = exports.TraversableWithIndex = exports.Traversable = exports.FoldableWithIndex = exports.Foldable = exports.getDifferenceMagma = exports.getIntersectionSemigroup = exports.getUnionMonoid = exports.getUnionSemigroup = exports.getWitherable = exports.getTraversableWithIndex = exports.getTraversable = exports.FilterableWithIndex = exports.Filterable = exports.Compactable = exports.getFoldableWithIndex = exports.getFoldable = exports.FunctorWithIndex = exports.flap = exports.Functor = exports.getMonoid = exports.getEq = exports.getShow = exports.URI = exports.separate = exports.compact = exports.reduceRight = exports.foldMap = exports.reduce = exports.partitionMap = exports.partition = exports.filterMap = exports.filter = exports._sequence = exports._traverse = exports._filterWithIndex = exports._filterMapWithIndex = exports._partitionWithIndex = exports._partitionMapWithIndex = exports._reduceRightWithIndex = exports._foldMapWithIndex = exports._reduceWithIndex = exports._partitionMap = void 0;
-var RA = __importStar(require("./ReadonlyArray"));
+exports._reduceWithIndex = exports._partitionMap = exports._partition = exports._filterMap = exports._filter = exports._reduceRight = exports._foldMap = exports._reduce = exports._mapWithIndex = exports._map = exports.difference = exports.intersection = exports.union = exports.elem = exports.some = exports.every = exports.fromFoldableMap = exports.fromFoldable = exports.filterWithIndex = exports.filterMapWithIndex = exports.partitionWithIndex = exports.partitionMapWithIndex = exports.wilt = exports.wither = exports.sequence = exports.traverse = exports.traverseWithIndex = exports.singleton = exports.reduceRightWithIndex = exports.foldMapWithIndex = exports.reduceWithIndex = exports.map = exports.mapWithIndex = exports.empty = exports.lookup = exports.isSubrecord = exports.pop = exports.modifyAt = exports.updateAt = exports.deleteAt = exports.has = exports.upsertAt = exports.toUnfoldable = exports.toReadonlyArray = exports.collect = exports.keys = exports.isEmpty = exports.size = exports.toRecord = exports.fromRecord = void 0;
+exports.readonlyRecord = exports.hasOwnProperty = exports.insertAt = exports.Witherable = exports.TraversableWithIndex = exports.Traversable = exports.FoldableWithIndex = exports.Foldable = exports.getDifferenceMagma = exports.getIntersectionSemigroup = exports.getUnionMonoid = exports.getUnionSemigroup = exports.getWitherable = exports.getTraversableWithIndex = exports.getTraversable = exports.FilterableWithIndex = exports.Filterable = exports.Compactable = exports.getFoldableWithIndex = exports.getFoldable = exports.FunctorWithIndex = exports.flap = exports.Functor = exports.getMonoid = exports.getEq = exports.getShow = exports.URI = exports.separate = exports.compact = exports.reduceRight = exports.foldMap = exports.reduce = exports.partitionMap = exports.partition = exports.filterMap = exports.filter = exports._sequence = exports._traverse = exports._filterWithIndex = exports._filterMapWithIndex = exports._partitionWithIndex = exports._partitionMapWithIndex = exports._reduceRightWithIndex = exports._foldMapWithIndex = void 0;
 var Eq_1 = require("./Eq");
 var function_1 = require("./function");
 var Functor_1 = require("./Functor");
 var _ = __importStar(require("./internal"));
-var Se = __importStar(require("./Semigroup"));
 var Separated_1 = require("./Separated");
 var S = __importStar(require("./string"));
 var Witherable_1 = require("./Witherable");
@@ -221,7 +219,7 @@ var updateAt = function (k, a) { return function (r) {
 }; };
 exports.updateAt = updateAt;
 /**
- * Applies a mapping function to one specific key/value pair in a `ReadonlyRecord`.
+ * Applies a mapping function to one spcific key/value pair in a `ReadonlyRecord`.
  *
  * @returns If the specified key exists it returns an `Option` containing a new `Record`
  * with the entry updated, otherwise it returns `None`
@@ -495,30 +493,16 @@ function fromFoldableMap(M, F) {
 }
 exports.fromFoldableMap = fromFoldableMap;
 /**
- * Alias of [`toReadonlyArray`](#toReadonlyArray).
- *
- * @since 2.12.0
+ * Test if every value in a `ReadonlyRecord` satisfies the predicate.
  *
  * @example
- * import { toEntries } from 'fp-ts/Record'
- *
- * assert.deepStrictEqual(toEntries({ a: 1, b: 2 }), [['a', 1], ['b', 2]])
- */
-exports.toEntries = exports.toReadonlyArray;
-/**
- * Converts an `Array` of `[key, value]` tuples into a `Record`.
+ * import { every } from "fp-ts/ReadonlyRecord"
  *
- * @since 2.12.0
+ * assert.deepStrictEqual(every((n: number) => n >= 0)({ a: 1, b: 2 }), true);
+ * assert.deepStrictEqual(every((n: number) => n >= 0)({ a: 1, b: -1 }), false);
  *
- * @example
- * import { fromEntries } from 'fp-ts/Record'
- *
- * assert.deepStrictEqual(fromEntries([['a', 1], ['b', 2], ['a', 3]]), { b: 2, a: 3 })
+ * @since 2.5.0
  */
-var fromEntries = function (fa) {
-    return fromFoldable(Se.last(), RA.Foldable)(fa);
-};
-exports.fromEntries = fromEntries;
 function every(predicate) {
     return function (r) {
         for (var k in r) {
@@ -798,8 +782,7 @@ var _traverseWithIndex = function (O) { return function (F) {
         var fr = F.of({});
         var _loop_1 = function (key) {
             fr = F.ap(F.map(fr, function (r) { return function (b) {
-                r[key] = b;
-                return r;
+                return Object.assign({}, r, { [key]: b })
             }; }), f(key, ta[key]));
         };
         for (var _i = 0, ks_1 = ks; _i < ks_1.length; _i++) {
diff --git a/node_modules/fp-ts/lib/ReadonlySet.d.ts b/node_modules/fp-ts/lib/ReadonlySet.d.ts
index 36a3255..c47c186 100644
--- a/node_modules/fp-ts/lib/ReadonlySet.d.ts
+++ b/node_modules/fp-ts/lib/ReadonlySet.d.ts
@@ -192,8 +192,7 @@ export declare const some: <A>(predicate: Predicate<A>) => (set: ReadonlySet<A>)
 /**
  * @since 2.5.0
  */
-export declare function every<A, B extends A>(refinement: Refinement<A, B>): Refinement<ReadonlySet<A>, ReadonlySet<B>>
-export declare function every<A>(predicate: Predicate<A>): Predicate<ReadonlySet<A>>
+export declare const every: <A>(predicate: Predicate<A>) => (set: ReadonlySet<A>) => boolean
 /**
  * `true` if and only if every element in the first set is an element of the second set
  *
diff --git a/node_modules/fp-ts/lib/ReadonlySet.js b/node_modules/fp-ts/lib/ReadonlySet.js
index 7a9eb3c..eaee370 100644
--- a/node_modules/fp-ts/lib/ReadonlySet.js
+++ b/node_modules/fp-ts/lib/ReadonlySet.js
@@ -370,9 +370,10 @@ var some = function (predicate) { return function (set) {
     return found;
 }; };
 exports.some = some;
-function every(predicate) {
-    return Predicate_1.not(exports.some(Predicate_1.not(predicate)));
-}
+/**
+ * @since 2.5.0
+ */
+var every = function (predicate) { return Predicate_1.not(exports.some(Predicate_1.not(predicate))); };
 exports.every = every;
 function isSubset(E) {
     var elemE = elem(E);
@@ -381,7 +382,7 @@ function isSubset(E) {
             var isSubsetE_1 = isSubset(E);
             return function (that) { return isSubsetE_1(that, me); };
         }
-        return every(function (a) { return elemE(a, that); })(me);
+        return exports.every(function (a) { return elemE(a, that); })(me);
     };
 }
 exports.isSubset = isSubset;
diff --git a/node_modules/fp-ts/lib/Record.d.ts b/node_modules/fp-ts/lib/Record.d.ts
index 711e770..3805b23 100644
--- a/node_modules/fp-ts/lib/Record.d.ts
+++ b/node_modules/fp-ts/lib/Record.d.ts
@@ -21,14 +21,13 @@ import { Option } from './Option'
 import { Ord } from './Ord'
 import { Predicate } from './Predicate'
 import { Refinement } from './Refinement'
-import * as Se from './Semigroup'
+import { Semigroup } from './Semigroup'
 import { Separated } from './Separated'
 import { Show } from './Show'
 import { Traversable1 } from './Traversable'
 import { TraversableWithIndex1 } from './TraversableWithIndex'
 import { Unfoldable, Unfoldable1 } from './Unfoldable'
 import { PipeableWilt1, PipeableWither1, Witherable1 } from './Witherable'
-import Semigroup = Se.Semigroup
 /**
  * Calculate the number of key/value pairs in a `Record`.
  *
@@ -624,28 +623,6 @@ export declare function fromFoldable<F, A>(
   M: Magma<A>,
   F: FoldableHKT<F>
 ): (fka: HKT<F, [string, A]>) => Record<string, A>
-/**
- * Alias of [`toArray`](#toArray).
- *
- * @since 2.12.0
- *
- * @example
- * import { toEntries } from 'fp-ts/Record'
- *
- * assert.deepStrictEqual(toEntries({ a: 1, b: 2 }), [['a', 1], ['b', 2]])
- */
-export declare const toEntries: <K extends string, A>(r: Record<K, A>) => [K, A][]
-/**
- * Converts an `Array` of `[key, value]` tuples into a `Record`.
- *
- * @since 2.12.0
- *
- * @example
- * import { fromEntries } from 'fp-ts/Record'
- *
- * assert.deepStrictEqual(fromEntries([['a', 1], ['b', 2], ['a', 3]]), { b: 2, a: 3 })
- */
-export declare const fromEntries: <A>(fa: [string, A][]) => Record<string, A>
 /**
  * Create a `Record` from a foldable collection using the specified functions to
  *
@@ -708,10 +685,7 @@ export declare function fromFoldableMap<F, B>(
  *
  * @since 2.0.0
  */
-export declare const every: {
-  <A, B extends A>(refinement: Refinement<A, B>): Refinement<Record<string, A>, Record<string, B>>
-  <A>(predicate: Predicate<A>): Predicate<Record<string, A>>
-}
+export declare const every: <A>(predicate: Predicate<A>) => (r: Record<string, A>) => boolean
 /**
  * Test if at least one value in a `Record` satisfies the predicate.
  *
@@ -1186,7 +1160,7 @@ export declare const getWitherable: (O: Ord<string>) => Witherable1<URI>
  * @category instances
  * @since 2.11.0
  */
-export declare const getUnionSemigroup: <A>(S: Se.Semigroup<A>) => Se.Semigroup<Record<string, A>>
+export declare const getUnionSemigroup: <A>(S: Semigroup<A>) => Semigroup<Record<string, A>>
 /**
  * Same as `getMonoid`.
  * Returns a `Monoid` instance for `Record`s given a `Semigroup`
@@ -1204,7 +1178,7 @@ export declare const getUnionSemigroup: <A>(S: Se.Semigroup<A>) => Se.Semigroup<
  * @category instances
  * @since 2.11.0
  */
-export declare const getUnionMonoid: <A>(S: Se.Semigroup<A>) => Monoid<Record<string, A>>
+export declare const getUnionMonoid: <A>(S: Semigroup<A>) => Monoid<Record<string, A>>
 /**
  * Given a `Semigroup` in the base type, it produces a `Semigroup`
  * in the `Record` of the base type.
@@ -1222,7 +1196,7 @@ export declare const getUnionMonoid: <A>(S: Se.Semigroup<A>) => Monoid<Record<st
  * @category instances
  * @since 2.11.0
  */
-export declare const getIntersectionSemigroup: <A>(S: Se.Semigroup<A>) => Se.Semigroup<Record<string, A>>
+export declare const getIntersectionSemigroup: <A>(S: Semigroup<A>) => Semigroup<Record<string, A>>
 /**
  * Produces a `Magma` with a `concat` function that combines
  * two `Record`s by making the `difference`.
diff --git a/node_modules/fp-ts/lib/Record.js b/node_modules/fp-ts/lib/Record.js
index 3e65e46..da813a3 100644
--- a/node_modules/fp-ts/lib/Record.js
+++ b/node_modules/fp-ts/lib/Record.js
@@ -30,14 +30,12 @@ var __importStar = (this && this.__importStar) || function (mod) {
     return result;
 };
 Object.defineProperty(exports, "__esModule", { value: true });
-exports.getShow = exports.URI = exports.separate = exports.compact = exports.reduceRight = exports.foldMap = exports.reduce = exports.partitionMap = exports.partition = exports.filterMap = exports.filter = exports.difference = exports.intersection = exports.union = exports.elem = exports.some = exports.every = exports.fromFoldableMap = exports.fromEntries = exports.toEntries = exports.fromFoldable = exports.filterWithIndex = exports.filterMapWithIndex = exports.partitionWithIndex = exports.partitionMapWithIndex = exports.wilt = exports.wither = exports.sequence = exports.traverse = exports.traverseWithIndex = exports.singleton = exports.reduceRightWithIndex = exports.foldMapWithIndex = exports.reduceWithIndex = exports.map = exports.mapWithIndex = exports.lookup = exports.isSubrecord = exports.pop = exports.modifyAt = exports.updateAt = exports.deleteAt = exports.has = exports.upsertAt = exports.toUnfoldable = exports.toArray = exports.collect = exports.keys = exports.isEmpty = exports.size = void 0;
-exports.record = exports.hasOwnProperty = exports.insertAt = exports.empty = exports.Witherable = exports.TraversableWithIndex = exports.Traversable = exports.FoldableWithIndex = exports.Foldable = exports.getDifferenceMagma = exports.getIntersectionSemigroup = exports.getUnionMonoid = exports.getUnionSemigroup = exports.getWitherable = exports.getTraversableWithIndex = exports.getTraversable = exports.FilterableWithIndex = exports.Filterable = exports.Compactable = exports.getFoldableWithIndex = exports.getFoldable = exports.FunctorWithIndex = exports.flap = exports.Functor = exports.getMonoid = exports.getEq = void 0;
-var A = __importStar(require("./Array"));
+exports.getMonoid = exports.getEq = exports.getShow = exports.URI = exports.separate = exports.compact = exports.reduceRight = exports.foldMap = exports.reduce = exports.partitionMap = exports.partition = exports.filterMap = exports.filter = exports.difference = exports.intersection = exports.union = exports.elem = exports.some = exports.every = exports.fromFoldableMap = exports.fromFoldable = exports.filterWithIndex = exports.filterMapWithIndex = exports.partitionWithIndex = exports.partitionMapWithIndex = exports.wilt = exports.wither = exports.sequence = exports.traverse = exports.traverseWithIndex = exports.singleton = exports.reduceRightWithIndex = exports.foldMapWithIndex = exports.reduceWithIndex = exports.map = exports.mapWithIndex = exports.lookup = exports.isSubrecord = exports.pop = exports.modifyAt = exports.updateAt = exports.deleteAt = exports.has = exports.upsertAt = exports.toUnfoldable = exports.toArray = exports.collect = exports.keys = exports.isEmpty = exports.size = void 0;
+exports.record = exports.hasOwnProperty = exports.insertAt = exports.empty = exports.Witherable = exports.TraversableWithIndex = exports.Traversable = exports.FoldableWithIndex = exports.Foldable = exports.getDifferenceMagma = exports.getIntersectionSemigroup = exports.getUnionMonoid = exports.getUnionSemigroup = exports.getWitherable = exports.getTraversableWithIndex = exports.getTraversable = exports.FilterableWithIndex = exports.Filterable = exports.Compactable = exports.getFoldableWithIndex = exports.getFoldable = exports.FunctorWithIndex = exports.flap = exports.Functor = void 0;
 var function_1 = require("./function");
 var Functor_1 = require("./Functor");
 var _ = __importStar(require("./internal"));
 var RR = __importStar(require("./ReadonlyRecord"));
-var Se = __importStar(require("./Semigroup"));
 var S = __importStar(require("./string"));
 var Witherable_1 = require("./Witherable");
 // -------------------------------------------------------------------------------------
@@ -396,29 +394,6 @@ function fromFoldable(M, F) {
     return RR.fromFoldable(M, F);
 }
 exports.fromFoldable = fromFoldable;
-/**
- * Alias of [`toArray`](#toArray).
- *
- * @since 2.12.0
- *
- * @example
- * import { toEntries } from 'fp-ts/Record'
- *
- * assert.deepStrictEqual(toEntries({ a: 1, b: 2 }), [['a', 1], ['b', 2]])
- */
-exports.toEntries = exports.toArray;
-/**
- * Converts an `Array` of `[key, value]` tuples into a `Record`.
- *
- * @since 2.12.0
- *
- * @example
- * import { fromEntries } from 'fp-ts/Record'
- *
- * assert.deepStrictEqual(fromEntries([['a', 1], ['b', 2], ['a', 3]]), { b: 2, a: 3 })
- */
-var fromEntries = function (fa) { return fromFoldable(Se.last(), A.Foldable)(fa); };
-exports.fromEntries = fromEntries;
 function fromFoldableMap(M, F) {
     return RR.fromFoldableMap(M, F);
 }
diff --git a/node_modules/fp-ts/lib/Set.d.ts b/node_modules/fp-ts/lib/Set.d.ts
index 638c1f1..54df70f 100644
--- a/node_modules/fp-ts/lib/Set.d.ts
+++ b/node_modules/fp-ts/lib/Set.d.ts
@@ -208,10 +208,7 @@ export declare const some: <A>(predicate: Predicate<A>) => (set: Set<A>) => bool
 /**
  * @since 2.0.0
  */
-export declare const every: {
-  <A, B extends A>(refinement: Refinement<A, B>): Refinement<Set<A>, Set<B>>
-  <A>(predicate: Predicate<A>): Predicate<Set<A>>
-}
+export declare const every: <A>(predicate: Predicate<A>) => (set: Set<A>) => boolean
 /**
  * @since 2.10.0
  */
diff --git a/node_modules/fp-ts/lib/StateReaderTaskEither.d.ts b/node_modules/fp-ts/lib/StateReaderTaskEither.d.ts
index 62f279b..7822f50 100644
--- a/node_modules/fp-ts/lib/StateReaderTaskEither.d.ts
+++ b/node_modules/fp-ts/lib/StateReaderTaskEither.d.ts
@@ -397,15 +397,6 @@ export declare const Apply: Apply4<URI>
 export declare const apFirst: <S, R, E, B>(
   second: StateReaderTaskEither<S, R, E, B>
 ) => <A>(first: StateReaderTaskEither<S, R, E, A>) => StateReaderTaskEither<S, R, E, A>
-/**
- * Less strict version of [`apFirst`](#apfirst).
- *
- * @category combinators
- * @since 2.12.0
- */
-export declare const apFirstW: <S, R2, E2, A, B>(
-  second: StateReaderTaskEither<S, R2, E2, B>
-) => <R1, E1>(first: StateReaderTaskEither<S, R1, E1, A>) => StateReaderTaskEither<S, R1 & R2, E1 | E2, A>
 /**
  * Combine two effectful actions, keeping only the result of the second.
  *
@@ -417,15 +408,6 @@ export declare const apFirstW: <S, R2, E2, A, B>(
 export declare const apSecond: <S, R, E, B>(
   second: StateReaderTaskEither<S, R, E, B>
 ) => <A>(first: StateReaderTaskEither<S, R, E, A>) => StateReaderTaskEither<S, R, E, B>
-/**
- * Less strict version of [`apSecond`](#apsecond).
- *
- * @category combinators
- * @since 2.12.0
- */
-export declare const apSecondW: <S, R2, E2, A, B>(
-  second: StateReaderTaskEither<S, R2, E2, B>
-) => <R1, E1>(first: StateReaderTaskEither<S, R1, E1, A>) => StateReaderTaskEither<S, R1 & R2, E1 | E2, B>
 /**
  * @category instances
  * @since 2.7.0
@@ -638,22 +620,6 @@ export declare const chainEitherK: <E, A, B>(
 export declare const chainEitherKW: <E2, A, B>(
   f: (a: A) => Either<E2, B>
 ) => <S, R, E1>(ma: StateReaderTaskEither<S, R, E1, A>) => StateReaderTaskEither<S, R, E1 | E2, B>
-/**
- * @category combinators
- * @since 2.12.0
- */
-export declare const chainFirstEitherK: <A, E, B>(
-  f: (a: A) => E.Either<E, B>
-) => <S, R>(ma: StateReaderTaskEither<S, R, E, A>) => StateReaderTaskEither<S, R, E, A>
-/**
- * Less strict version of [`chainFirstEitherK`](#chainfirsteitherk).
- *
- * @category combinators
- * @since 2.12.0
- */
-export declare const chainFirstEitherKW: <A, E2, B>(
-  f: (a: A) => Either<E2, B>
-) => <S, R, E1>(ma: StateReaderTaskEither<S, R, E1, A>) => StateReaderTaskEither<S, R, E1 | E2, A>
 /**
  * @category constructors
  * @since 2.4.4
diff --git a/node_modules/fp-ts/lib/StateReaderTaskEither.js b/node_modules/fp-ts/lib/StateReaderTaskEither.js
index 321698e..fd54bf9 100644
--- a/node_modules/fp-ts/lib/StateReaderTaskEither.js
+++ b/node_modules/fp-ts/lib/StateReaderTaskEither.js
@@ -20,8 +20,8 @@ var __importStar = (this && this.__importStar) || function (mod) {
 };
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.apFirst = exports.Apply = exports.Pointed = exports.flap = exports.Functor = exports.URI = exports.throwError = exports.alt = exports.altW = exports.flatten = exports.flattenW = exports.chainW = exports.chain = exports.of = exports.apW = exports.ap = exports.mapLeft = exports.bimap = exports.map = exports.chainReaderTaskEitherK = exports.chainReaderTaskEitherKW = exports.fromReaderTaskEitherK = exports.chainTaskEitherK = exports.chainTaskEitherKW = exports.fromTaskEitherK = exports.chainIOEitherK = exports.chainIOEitherKW = exports.fromIOEitherK = exports.asksStateReaderTaskEither = exports.asksStateReaderTaskEitherW = exports.local = exports.fromReaderTaskEither = exports.fromReaderEither = exports.fromIOEither = exports.fromTaskEither = exports.fromState = exports.fromTask = exports.fromIO = exports.fromReader = exports.fromEither = exports.leftState = exports.rightState = exports.leftIO = exports.rightIO = exports.leftReader = exports.rightReader = exports.leftTask = exports.rightTask = exports.right = exports.left = void 0;
-exports.execute = exports.evaluate = exports.chainFirstTaskK = exports.chainTaskK = exports.fromTaskK = exports.FromTask = exports.chainFirstIOK = exports.chainIOK = exports.fromIOK = exports.FromIO = exports.fromEitherK = exports.filterOrElseW = exports.filterOrElse = exports.fromPredicate = exports.chainFirstEitherKW = exports.chainFirstEitherK = exports.chainEitherKW = exports.chainEitherK = exports.chainOptionK = exports.fromOptionK = exports.fromOption = exports.FromEither = exports.chainFirstReaderKW = exports.chainFirstReaderK = exports.chainReaderKW = exports.chainReaderK = exports.fromReaderK = exports.asks = exports.ask = exports.FromReader = exports.Alt = exports.Bifunctor = exports.chainFirstW = exports.chainFirst = exports.MonadThrow = exports.MonadTask = exports.MonadIO = exports.Monad = exports.chainStateK = exports.fromStateK = exports.gets = exports.modify = exports.put = exports.get = exports.FromState = exports.Chain = exports.Applicative = exports.apSecondW = exports.apSecond = exports.apFirstW = void 0;
-exports.run = exports.execState = exports.evalState = exports.stateReaderTaskEitherSeq = exports.stateReaderTaskEither = exports.sequenceArray = exports.traverseArray = exports.traverseArrayWithIndex = exports.traverseReadonlyArrayWithIndex = exports.traverseReadonlyNonEmptyArrayWithIndex = exports.apSW = exports.apS = exports.bindW = exports.bind = exports.bindTo = void 0;
+exports.apS = exports.bindW = exports.bind = exports.bindTo = exports.execute = exports.evaluate = exports.chainFirstTaskK = exports.chainTaskK = exports.fromTaskK = exports.FromTask = exports.chainFirstIOK = exports.chainIOK = exports.fromIOK = exports.FromIO = exports.fromEitherK = exports.filterOrElseW = exports.filterOrElse = exports.fromPredicate = exports.chainEitherKW = exports.chainEitherK = exports.chainOptionK = exports.fromOptionK = exports.fromOption = exports.FromEither = exports.chainFirstReaderKW = exports.chainFirstReaderK = exports.chainReaderKW = exports.chainReaderK = exports.fromReaderK = exports.asks = exports.ask = exports.FromReader = exports.Alt = exports.Bifunctor = exports.chainFirstW = exports.chainFirst = exports.MonadThrow = exports.MonadTask = exports.MonadIO = exports.Monad = exports.chainStateK = exports.fromStateK = exports.gets = exports.modify = exports.put = exports.get = exports.FromState = exports.Chain = exports.Applicative = exports.apSecond = void 0;
+exports.run = exports.execState = exports.evalState = exports.stateReaderTaskEitherSeq = exports.stateReaderTaskEither = exports.sequenceArray = exports.traverseArray = exports.traverseArrayWithIndex = exports.traverseReadonlyArrayWithIndex = exports.traverseReadonlyNonEmptyArrayWithIndex = exports.apSW = void 0;
 var Apply_1 = require("./Apply");
 var Chain_1 = require("./Chain");
 var E = __importStar(require("./Either"));
@@ -457,13 +457,6 @@ exports.Apply = {
 exports.apFirst = 
 /*#__PURE__*/
 Apply_1.apFirst(exports.Apply);
-/**
- * Less strict version of [`apFirst`](#apfirst).
- *
- * @category combinators
- * @since 2.12.0
- */
-exports.apFirstW = exports.apFirst;
 /**
  * Combine two effectful actions, keeping only the result of the second.
  *
@@ -475,13 +468,6 @@ exports.apFirstW = exports.apFirst;
 exports.apSecond = 
 /*#__PURE__*/
 Apply_1.apSecond(exports.Apply);
-/**
- * Less strict version of [`apSecond`](#apsecond).
- *
- * @category combinators
- * @since 2.12.0
- */
-exports.apSecondW = exports.apSecond;
 /**
  * @category instances
  * @since 2.7.0
@@ -751,20 +737,6 @@ FromEither_1.chainEitherK(exports.FromEither, exports.Chain);
  * @since 2.6.1
  */
 exports.chainEitherKW = exports.chainEitherK;
-/**
- * @category combinators
- * @since 2.12.0
- */
-exports.chainFirstEitherK = 
-/*#__PURE__*/
-FromEither_1.chainFirstEitherK(exports.FromEither, exports.Chain);
-/**
- * Less strict version of [`chainFirstEitherK`](#chainfirsteitherk).
- *
- * @category combinators
- * @since 2.12.0
- */
-exports.chainFirstEitherKW = exports.chainFirstEitherK;
 /**
  * @category constructors
  * @since 2.4.4
diff --git a/node_modules/fp-ts/lib/TaskEither.d.ts b/node_modules/fp-ts/lib/TaskEither.d.ts
index 0b4c7e8..59e822c 100644
--- a/node_modules/fp-ts/lib/TaskEither.d.ts
+++ b/node_modules/fp-ts/lib/TaskEither.d.ts
@@ -166,6 +166,8 @@ export declare const getOrElseW: <E, B>(onLeft: (e: E) => Task<B>) => <A>(ma: Ta
 /**
  * Transforms a `Promise` that may reject to a `Promise` that never rejects and returns an `Either` instead.
  *
+ * Note: `f` should never `throw` errors, they are not caught.
+ *
  * See also [`tryCatchK`](#trycatchk).
  *
  * @example
@@ -198,27 +200,6 @@ export declare const tryCatchK: <E, A extends readonly unknown[], B>(
  * @since 2.10.0
  */
 export declare const toUnion: <E, A>(fa: TaskEither<E, A>) => Task<E | A>
-/**
- * @category interop
- * @since 2.12.0
- */
-export declare const fromNullable: <E>(e: E) => <A>(a: A) => TaskEither<E, NonNullable<A>>
-/**
- * @category interop
- * @since 2.12.0
- */
-export declare const fromNullableK: <E>(
-  e: E
-) => <A extends ReadonlyArray<unknown>, B>(
-  f: (...a: A) => B | null | undefined
-) => (...a: A) => TaskEither<E, NonNullable<B>>
-/**
- * @category interop
- * @since 2.12.0
- */
-export declare const chainNullableK: <E>(
-  e: E
-) => <A, B>(f: (a: A) => B | null | undefined) => (ma: TaskEither<E, A>) => TaskEither<E, NonNullable<B>>
 /**
  * Returns `ma` if is a `Right` or the value returned by `onLeft` otherwise.
  *
@@ -266,18 +247,6 @@ export declare const orElseFirst: <E, B>(
 export declare const orElseFirstW: <E1, E2, B>(
   onLeft: (e: E1) => TaskEither<E2, B>
 ) => <A>(ma: TaskEither<E1, A>) => TaskEither<E1 | E2, A>
-/**
- * @category combinators
- * @since 2.12.0
- */
-export declare const orElseFirstIOK: <E, B>(onLeft: (e: E) => IO<B>) => <A>(ma: TaskEither<E, A>) => TaskEither<E, A>
-/**
- * @category combinators
- * @since 2.12.0
- */
-export declare const orElseFirstTaskK: <E, B>(
-  onLeft: (e: E) => Task<B>
-) => <A>(ma: TaskEither<E, A>) => TaskEither<E, A>
 /**
  * @category combinators
  * @since 2.11.0
@@ -521,15 +490,6 @@ export declare const ApplyPar: Apply2<URI>
  * @since 2.0.0
  */
 export declare const apFirst: <E, B>(second: TaskEither<E, B>) => <A>(first: TaskEither<E, A>) => TaskEither<E, A>
-/**
- * Less strict version of [`apFirst`](#apfirst).
- *
- * @category combinators
- * @since 2.12.0
- */
-export declare const apFirstW: <E2, A, B>(
-  second: TaskEither<E2, B>
-) => <E1>(first: TaskEither<E1, A>) => TaskEither<E1 | E2, A>
 /**
  * Combine two effectful actions, keeping only the result of the second.
  *
@@ -539,15 +499,6 @@ export declare const apFirstW: <E2, A, B>(
  * @since 2.0.0
  */
 export declare const apSecond: <E, B>(second: TaskEither<E, B>) => <A>(first: TaskEither<E, A>) => TaskEither<E, B>
-/**
- * Less strict version of [`apSecond`](#apsecond).
- *
- * @category combinators
- * @since 2.12.0
- */
-export declare const apSecondW: <E2, A, B>(
-  second: TaskEither<E2, B>
-) => <E1>(first: TaskEither<E1, A>) => TaskEither<E1 | E2, B>
 /**
  * @category instances
  * @since 2.7.0
@@ -657,22 +608,6 @@ export declare const chainEitherK: <E, A, B>(f: (a: A) => E.Either<E, B>) => (ma
 export declare const chainEitherKW: <E2, A, B>(
   f: (a: A) => Either<E2, B>
 ) => <E1>(ma: TaskEither<E1, A>) => TaskEither<E1 | E2, B>
-/**
- * @category combinators
- * @since 2.12.0
- */
-export declare const chainFirstEitherK: <A, E, B>(
-  f: (a: A) => E.Either<E, B>
-) => (ma: TaskEither<E, A>) => TaskEither<E, A>
-/**
- * Less strict version of [`chainFirstEitherK`](#chainfirsteitherk).
- *
- * @category combinators
- * @since 2.12.0
- */
-export declare const chainFirstEitherKW: <A, E2, B>(
-  f: (a: A) => E.Either<E2, B>
-) => <E1>(ma: TaskEither<E1, A>) => TaskEither<E1 | E2, A>
 /**
  * @category constructors
  * @since 2.0.0
@@ -813,16 +748,6 @@ export declare const bracket: <E, A, B>(
   use: (a: A) => TaskEither<E, B>,
   release: (a: A, e: E.Either<E, B>) => TaskEither<E, void>
 ) => TaskEither<E, B>
-/**
- * Less strict version of [`bracket`](#bracket).
- *
- * @since 2.12.0
- */
-export declare const bracketW: <E1, A, E2, B, E3>(
-  acquire: TaskEither<E1, A>,
-  use: (a: A) => TaskEither<E2, B>,
-  release: (a: A, e: E.Either<E2, B>) => TaskEither<E3, void>
-) => TaskEither<E1 | E2 | E3, B>
 /**
  * @since 2.9.0
  */
diff --git a/node_modules/fp-ts/lib/TaskEither.js b/node_modules/fp-ts/lib/TaskEither.js
index c98955f..0b8b050 100644
--- a/node_modules/fp-ts/lib/TaskEither.js
+++ b/node_modules/fp-ts/lib/TaskEither.js
@@ -18,46 +18,10 @@ var __importStar = (this && this.__importStar) || function (mod) {
     __setModuleDefault(result, mod);
     return result;
 };
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
-var __generator = (this && this.__generator) || function (thisArg, body) {
-    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
-    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
-    function verb(n) { return function (v) { return step([n, v]); }; }
-    function step(op) {
-        if (f) throw new TypeError("Generator is already executing.");
-        while (_) try {
-            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
-            if (y = 0, t) op = [op[0] & 2, t.value];
-            switch (op[0]) {
-                case 0: case 1: t = op; break;
-                case 4: _.label++; return { value: op[1], done: false };
-                case 5: _.label++; y = op[1]; op = [0]; continue;
-                case 7: op = _.ops.pop(); _.trys.pop(); continue;
-                default:
-                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
-                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
-                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
-                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
-                    if (t[2]) _.ops.pop();
-                    _.trys.pop(); continue;
-            }
-            op = body.call(thisArg, _);
-        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
-        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
-    }
-};
 Object.defineProperty(exports, "__esModule", { value: true });
-exports.of = exports.altW = exports.alt = exports.flatten = exports.flattenW = exports.chainW = exports.chain = exports.apW = exports.ap = exports.mapLeft = exports.bimap = exports.map = exports.chainIOEitherK = exports.chainIOEitherKW = exports.fromIOEitherK = exports.chainTaskOptionK = exports.fromTaskOptionK = exports.swap = exports.orLeft = exports.orElseFirstTaskK = exports.orElseFirstIOK = exports.orElseFirstW = exports.orElseFirst = exports.orElseW = exports.orElse = exports.chainNullableK = exports.fromNullableK = exports.fromNullable = exports.toUnion = exports.tryCatchK = exports.tryCatch = exports.getOrElseW = exports.getOrElse = exports.foldW = exports.matchEW = exports.fold = exports.matchE = exports.matchW = exports.match = exports.fromTaskOption = exports.fromIOEither = exports.fromEither = exports.fromTask = exports.fromIO = exports.leftIO = exports.rightIO = exports.leftTask = exports.rightTask = exports.right = exports.left = void 0;
-exports.Do = exports.bracketW = exports.bracket = exports.taskify = exports.chainFirstTaskK = exports.chainTaskK = exports.fromTaskK = exports.FromTask = exports.chainFirstIOK = exports.chainIOK = exports.fromIOK = exports.FromIO = exports.fromEitherK = exports.filterOrElseW = exports.filterOrElse = exports.fromPredicate = exports.chainFirstEitherKW = exports.chainFirstEitherK = exports.chainEitherKW = exports.chainEitherK = exports.chainOptionK = exports.fromOptionK = exports.fromOption = exports.FromEither = exports.Alt = exports.Bifunctor = exports.chainFirstW = exports.chainFirst = exports.MonadThrow = exports.MonadTask = exports.MonadIO = exports.Monad = exports.Chain = exports.ApplicativeSeq = exports.ApplySeq = exports.ApplicativePar = exports.apSecondW = exports.apSecond = exports.apFirstW = exports.apFirst = exports.ApplyPar = exports.Pointed = exports.flap = exports.Functor = exports.getFilterable = exports.getCompactable = exports.getAltTaskValidation = exports.getApplicativeTaskValidation = exports.URI = exports.throwError = void 0;
-exports.getTaskValidation = exports.getSemigroup = exports.getApplyMonoid = exports.getApplySemigroup = exports.taskEitherSeq = exports.taskEither = exports.sequenceSeqArray = exports.traverseSeqArray = exports.traverseSeqArrayWithIndex = exports.sequenceArray = exports.traverseArray = exports.traverseArrayWithIndex = exports.traverseReadonlyArrayWithIndexSeq = exports.traverseReadonlyNonEmptyArrayWithIndexSeq = exports.traverseReadonlyArrayWithIndex = exports.traverseReadonlyNonEmptyArrayWithIndex = exports.ApT = exports.apSW = exports.apS = exports.bindW = exports.bind = exports.bindTo = void 0;
+exports.getCompactable = exports.getAltTaskValidation = exports.getApplicativeTaskValidation = exports.URI = exports.throwError = exports.of = exports.altW = exports.alt = exports.flatten = exports.flattenW = exports.chainW = exports.chain = exports.apW = exports.ap = exports.mapLeft = exports.bimap = exports.map = exports.chainIOEitherK = exports.chainIOEitherKW = exports.fromIOEitherK = exports.chainTaskOptionK = exports.fromTaskOptionK = exports.swap = exports.orLeft = exports.orElseFirstW = exports.orElseFirst = exports.orElseW = exports.orElse = exports.toUnion = exports.tryCatchK = exports.tryCatch = exports.getOrElseW = exports.getOrElse = exports.foldW = exports.matchEW = exports.fold = exports.matchE = exports.matchW = exports.match = exports.fromTaskOption = exports.fromIOEither = exports.fromEither = exports.fromTask = exports.fromIO = exports.leftIO = exports.rightIO = exports.leftTask = exports.rightTask = exports.right = exports.left = void 0;
+exports.traverseReadonlyArrayWithIndexSeq = exports.traverseReadonlyNonEmptyArrayWithIndexSeq = exports.traverseReadonlyArrayWithIndex = exports.traverseReadonlyNonEmptyArrayWithIndex = exports.ApT = exports.apSW = exports.apS = exports.bindW = exports.bind = exports.bindTo = exports.Do = exports.bracket = exports.taskify = exports.chainFirstTaskK = exports.chainTaskK = exports.fromTaskK = exports.FromTask = exports.chainFirstIOK = exports.chainIOK = exports.fromIOK = exports.FromIO = exports.fromEitherK = exports.filterOrElseW = exports.filterOrElse = exports.fromPredicate = exports.chainEitherKW = exports.chainEitherK = exports.chainOptionK = exports.fromOptionK = exports.fromOption = exports.FromEither = exports.Alt = exports.Bifunctor = exports.chainFirstW = exports.chainFirst = exports.MonadThrow = exports.MonadTask = exports.MonadIO = exports.Monad = exports.Chain = exports.ApplicativeSeq = exports.ApplySeq = exports.ApplicativePar = exports.apSecond = exports.apFirst = exports.ApplyPar = exports.Pointed = exports.flap = exports.Functor = exports.getFilterable = void 0;
+exports.getTaskValidation = exports.getSemigroup = exports.getApplyMonoid = exports.getApplySemigroup = exports.taskEitherSeq = exports.taskEither = exports.sequenceSeqArray = exports.traverseSeqArray = exports.traverseSeqArrayWithIndex = exports.sequenceArray = exports.traverseArray = exports.traverseArrayWithIndex = void 0;
 var Applicative_1 = require("./Applicative");
 var Apply_1 = require("./Apply");
 var Chain_1 = require("./Chain");
@@ -213,6 +177,8 @@ exports.getOrElseW = exports.getOrElse;
 /**
  * Transforms a `Promise` that may reject to a `Promise` that never rejects and returns an `Either` instead.
  *
+ * Note: `f` should never `throw` errors, they are not caught.
+ *
  * See also [`tryCatchK`](#trycatchk).
  *
  * @example
@@ -229,21 +195,9 @@ exports.getOrElseW = exports.getOrElse;
  * @category interop
  * @since 2.0.0
  */
-var tryCatch = function (f, onRejected) { return function () { return __awaiter(void 0, void 0, void 0, function () {
-    var reason_1;
-    return __generator(this, function (_a) {
-        switch (_a.label) {
-            case 0:
-                _a.trys.push([0, 2, , 3]);
-                return [4 /*yield*/, f().then(_.right)];
-            case 1: return [2 /*return*/, _a.sent()];
-            case 2:
-                reason_1 = _a.sent();
-                return [2 /*return*/, _.left(onRejected(reason_1))];
-            case 3: return [2 /*return*/];
-        }
-    });
-}); }; };
+var tryCatch = function (f, onRejected) { return function () {
+    return f().then(_.right, function (reason) { return _.left(onRejected(reason)); });
+}; };
 exports.tryCatch = tryCatch;
 /**
  * Converts a function returning a `Promise` to one returning a `TaskEither`.
@@ -266,27 +220,6 @@ exports.tryCatchK = tryCatchK;
 exports.toUnion = 
 /*#__PURE__*/
 ET.toUnion(T.Functor);
-/**
- * @category interop
- * @since 2.12.0
- */
-exports.fromNullable = 
-/*#__PURE__*/
-ET.fromNullable(T.Pointed);
-/**
- * @category interop
- * @since 2.12.0
- */
-exports.fromNullableK = 
-/*#__PURE__*/
-ET.fromNullableK(T.Pointed);
-/**
- * @category interop
- * @since 2.12.0
- */
-exports.chainNullableK = 
-/*#__PURE__*/
-ET.chainNullableK(T.Monad);
 // -------------------------------------------------------------------------------------
 // combinators
 // -------------------------------------------------------------------------------------
@@ -333,18 +266,6 @@ ET.orElseFirst(T.Monad);
  * @since 2.11.0
  */
 exports.orElseFirstW = exports.orElseFirst;
-/**
- * @category combinators
- * @since 2.12.0
- */
-var orElseFirstIOK = function (onLeft) { return exports.orElseFirst(exports.fromIOK(onLeft)); };
-exports.orElseFirstIOK = orElseFirstIOK;
-/**
- * @category combinators
- * @since 2.12.0
- */
-var orElseFirstTaskK = function (onLeft) { return exports.orElseFirst(exports.fromTaskK(onLeft)); };
-exports.orElseFirstTaskK = orElseFirstTaskK;
 /**
  * @category combinators
  * @since 2.11.0
@@ -672,13 +593,6 @@ exports.ApplyPar = {
 exports.apFirst = 
 /*#__PURE__*/
 Apply_1.apFirst(exports.ApplyPar);
-/**
- * Less strict version of [`apFirst`](#apfirst).
- *
- * @category combinators
- * @since 2.12.0
- */
-exports.apFirstW = exports.apFirst;
 /**
  * Combine two effectful actions, keeping only the result of the second.
  *
@@ -690,13 +604,6 @@ exports.apFirstW = exports.apFirst;
 exports.apSecond = 
 /*#__PURE__*/
 Apply_1.apSecond(exports.ApplyPar);
-/**
- * Less strict version of [`apSecond`](#apsecond).
- *
- * @category combinators
- * @since 2.12.0
- */
-exports.apSecondW = exports.apSecond;
 /**
  * @category instances
  * @since 2.7.0
@@ -866,20 +773,6 @@ FromEither_1.chainEitherK(exports.FromEither, exports.Chain);
  * @since 2.6.1
  */
 exports.chainEitherKW = exports.chainEitherK;
-/**
- * @category combinators
- * @since 2.12.0
- */
-exports.chainFirstEitherK = 
-/*#__PURE__*/
-FromEither_1.chainFirstEitherK(exports.FromEither, exports.Chain);
-/**
- * Less strict version of [`chainFirstEitherK`](#chainfirsteitherk).
- *
- * @category combinators
- * @since 2.12.0
- */
-exports.chainFirstEitherKW = exports.chainFirstEitherK;
 /**
  * @category constructors
  * @since 2.0.0
@@ -987,21 +880,14 @@ exports.taskify = taskify;
  *
  * @since 2.0.0
  */
-var bracket = function (acquire, use, release) { return exports.bracketW(acquire, use, release); };
-exports.bracket = bracket;
-/**
- * Less strict version of [`bracket`](#bracket).
- *
- * @since 2.12.0
- */
-var bracketW = function (acquire, use, release) {
-    return function_1.pipe(acquire, exports.chainW(function (a) {
+var bracket = function (acquire, use, release) {
+    return function_1.pipe(acquire, exports.chain(function (a) {
         return function_1.pipe(use(a), T.chain(function (e) {
-            return function_1.pipe(release(a, e), exports.chainW(function () { return T.of(e); }));
+            return function_1.pipe(release(a, e), exports.chain(function () { return T.of(e); }));
         }));
     }));
 };
-exports.bracketW = bracketW;
+exports.bracket = bracket;
 // -------------------------------------------------------------------------------------
 // do notation
 // -------------------------------------------------------------------------------------
diff --git a/node_modules/fp-ts/lib/TaskOption.d.ts b/node_modules/fp-ts/lib/TaskOption.d.ts
index 43bb981..8e1a51c 100644
--- a/node_modules/fp-ts/lib/TaskOption.d.ts
+++ b/node_modules/fp-ts/lib/TaskOption.d.ts
@@ -140,6 +140,8 @@ export declare const fromNullable: <A>(a: A) => TaskOption<NonNullable<A>>
 /**
  * Transforms a `Promise` that may reject to a `Promise` that never rejects and returns an `Option` instead.
  *
+ * Note: `f` should never `throw` errors, they are not caught.
+ *
  * See also [`tryCatchK`](#trycatchk).
  *
  * @category interop
@@ -430,23 +432,6 @@ export declare const chainFirstIOK: <A, B>(f: (a: A) => import('./IO').IO<B>) =>
  * @since 2.11.0
  */
 export declare const FromEither: FromEither1<URI>
-/**
- * @category combinators
- * @since 2.12.0
- */
-export declare const fromEitherK: <E, A extends readonly unknown[], B>(
-  f: (...a: A) => Either<E, B>
-) => (...a: A) => TaskOption<B>
-/**
- * @category combinators
- * @since 2.12.0
- */
-export declare const chainEitherK: <E, A, B>(f: (a: A) => Either<E, B>) => (ma: TaskOption<A>) => TaskOption<B>
-/**
- * @category combinators
- * @since 2.12.0
- */
-export declare const chainFirstEitherK: <E, A, B>(f: (a: A) => Either<E, B>) => (ma: TaskOption<A>) => TaskOption<A>
 /**
  * @category instances
  * @since 2.10.0
diff --git a/node_modules/fp-ts/lib/TaskOption.js b/node_modules/fp-ts/lib/TaskOption.js
index 800dadb..c84cf02 100644
--- a/node_modules/fp-ts/lib/TaskOption.js
+++ b/node_modules/fp-ts/lib/TaskOption.js
@@ -18,50 +18,13 @@ var __importStar = (this && this.__importStar) || function (mod) {
     __setModuleDefault(result, mod);
     return result;
 };
-var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
-    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
-    return new (P || (P = Promise))(function (resolve, reject) {
-        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
-        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
-        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
-        step((generator = generator.apply(thisArg, _arguments || [])).next());
-    });
-};
-var __generator = (this && this.__generator) || function (thisArg, body) {
-    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
-    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
-    function verb(n) { return function (v) { return step([n, v]); }; }
-    function step(op) {
-        if (f) throw new TypeError("Generator is already executing.");
-        while (_) try {
-            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
-            if (y = 0, t) op = [op[0] & 2, t.value];
-            switch (op[0]) {
-                case 0: case 1: t = op; break;
-                case 4: _.label++; return { value: op[1], done: false };
-                case 5: _.label++; y = op[1]; op = [0]; continue;
-                case 7: op = _.ops.pop(); _.trys.pop(); continue;
-                default:
-                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
-                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
-                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
-                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
-                    if (t[2]) _.ops.pop();
-                    _.trys.pop(); continue;
-            }
-            op = body.call(thisArg, _);
-        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
-        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
-    }
-};
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.Zero = exports.Alt = exports.chainFirst = exports.Chain = exports.ApplicativeSeq = exports.ApplySeq = exports.ApplicativePar = exports.apSecond = exports.apFirst = exports.ApplyPar = exports.Pointed = exports.flap = exports.Functor = exports.partitionMap = exports.partition = exports.filterMap = exports.filter = exports.separate = exports.compact = exports.none = exports.zero = exports.altW = exports.alt = exports.flatten = exports.chain = exports.of = exports.ap = exports.map = exports.chainOptionK = exports.fromOptionK = exports.chainNullableK = exports.fromNullableK = exports.tryCatchK = exports.tryCatch = exports.fromNullable = exports.getOrElseW = exports.getOrElse = exports.foldW = exports.matchEW = exports.fold = exports.matchE = exports.matchW = exports.match = exports.fromTaskEither = exports.fromTask = exports.fromIO = exports.fromEither = exports.fromOption = exports.fromPredicate = exports.some = void 0;
-exports.sequenceSeqArray = exports.traverseSeqArray = exports.traverseSeqArrayWithIndex = exports.sequenceArray = exports.traverseArray = exports.traverseArrayWithIndex = exports.traverseReadonlyArrayWithIndexSeq = exports.traverseReadonlyNonEmptyArrayWithIndexSeq = exports.traverseReadonlyArrayWithIndex = exports.traverseReadonlyNonEmptyArrayWithIndex = exports.ApT = exports.apS = exports.bind = exports.bindTo = exports.Do = exports.chainFirstTaskK = exports.chainTaskK = exports.fromTaskK = exports.FromTask = exports.chainFirstEitherK = exports.chainEitherK = exports.fromEitherK = exports.FromEither = exports.chainFirstIOK = exports.chainIOK = exports.fromIOK = exports.FromIO = exports.Filterable = exports.Compactable = exports.MonadTask = exports.MonadIO = exports.Monad = exports.Alternative = exports.guard = void 0;
+exports.sequenceSeqArray = exports.traverseSeqArray = exports.traverseSeqArrayWithIndex = exports.sequenceArray = exports.traverseArray = exports.traverseArrayWithIndex = exports.traverseReadonlyArrayWithIndexSeq = exports.traverseReadonlyNonEmptyArrayWithIndexSeq = exports.traverseReadonlyArrayWithIndex = exports.traverseReadonlyNonEmptyArrayWithIndex = exports.ApT = exports.apS = exports.bind = exports.bindTo = exports.Do = exports.chainFirstTaskK = exports.chainTaskK = exports.fromTaskK = exports.FromTask = exports.FromEither = exports.chainFirstIOK = exports.chainIOK = exports.fromIOK = exports.FromIO = exports.Filterable = exports.Compactable = exports.MonadTask = exports.MonadIO = exports.Monad = exports.Alternative = exports.guard = void 0;
 var Apply_1 = require("./Apply");
 var Chain_1 = require("./Chain");
 var Compactable_1 = require("./Compactable");
 var Filterable_1 = require("./Filterable");
-var FromEither_1 = require("./FromEither");
 var FromIO_1 = require("./FromIO");
 var FromTask_1 = require("./FromTask");
 var function_1 = require("./function");
@@ -195,26 +158,16 @@ OT.fromNullable(T.Pointed);
 /**
  * Transforms a `Promise` that may reject to a `Promise` that never rejects and returns an `Option` instead.
  *
+ * Note: `f` should never `throw` errors, they are not caught.
+ *
  * See also [`tryCatchK`](#trycatchk).
  *
  * @category interop
  * @since 2.10.0
  */
-var tryCatch = function (f) { return function () { return __awaiter(void 0, void 0, void 0, function () {
-    var reason_1;
-    return __generator(this, function (_a) {
-        switch (_a.label) {
-            case 0:
-                _a.trys.push([0, 2, , 3]);
-                return [4 /*yield*/, f().then(_.some)];
-            case 1: return [2 /*return*/, _a.sent()];
-            case 2:
-                reason_1 = _a.sent();
-                return [2 /*return*/, _.none];
-            case 3: return [2 /*return*/];
-        }
-    });
-}); }; };
+var tryCatch = function (f) { return function () {
+    return f().then(function (a) { return O.some(a); }, function () { return O.none; });
+}; };
 exports.tryCatch = tryCatch;
 /**
  * Converts a function returning a `Promise` to one returning a `TaskOption`.
@@ -640,27 +593,6 @@ exports.FromEither = {
     URI: URI,
     fromEither: exports.fromEither
 };
-/**
- * @category combinators
- * @since 2.12.0
- */
-exports.fromEitherK = 
-/*#__PURE__*/
-FromEither_1.fromEitherK(exports.FromEither);
-/**
- * @category combinators
- * @since 2.12.0
- */
-exports.chainEitherK = 
-/*#__PURE__*/
-FromEither_1.chainEitherK(exports.FromEither, exports.Chain);
-/**
- * @category combinators
- * @since 2.12.0
- */
-exports.chainFirstEitherK = 
-/*#__PURE__*/
-FromEither_1.chainFirstEitherK(exports.FromEither, exports.Chain);
 /**
  * @category instances
  * @since 2.10.0
@@ -813,3 +745,7 @@ exports.traverseSeqArray = traverseSeqArray;
 exports.sequenceSeqArray = 
 /*#__PURE__*/
 exports.traverseSeqArray(function_1.identity);
+// -------------------------------------------------------------------------------------
+// deprecated
+// -------------------------------------------------------------------------------------
+// tslint:disable: deprecation
diff --git a/node_modules/fp-ts/lib/index.d.ts b/node_modules/fp-ts/lib/index.d.ts
index f461cec..06a33df 100644
--- a/node_modules/fp-ts/lib/index.d.ts
+++ b/node_modules/fp-ts/lib/index.d.ts
@@ -51,7 +51,6 @@ import * as identity from './Identity'
 import * as invariant from './Invariant'
 import * as io from './IO'
 import * as ioEither from './IOEither'
-import * as ioOption from './IOOption'
 import * as ioRef from './IORef'
 import * as joinSemilattice from './JoinSemilattice'
 import * as json from './Json'
@@ -318,10 +317,6 @@ export {
    * @since 2.0.0
    */
   ioEither,
-  /**
-   * @since 2.12.0
-   */
-  ioOption,
   /**
    * @since 2.0.0
    */
diff --git a/node_modules/fp-ts/lib/index.js b/node_modules/fp-ts/lib/index.js
index ac6c083..e085f0e 100644
--- a/node_modules/fp-ts/lib/index.js
+++ b/node_modules/fp-ts/lib/index.js
@@ -22,9 +22,9 @@ var __importStar = (this && this.__importStar) || function (mod) {
     return result;
 };
 Object.defineProperty(exports, "__esModule", { value: true });
-exports.ioOption = exports.ioEither = exports.io = exports.invariant = exports.identity = exports.hkt = exports.heytingAlgebra = exports.group = exports.functorWithIndex = exports.functor = exports.function = exports.fromThese = exports.fromTask = exports.fromState = exports.fromReader = exports.fromIO = exports.fromEither = exports.foldableWithIndex = exports.foldable = exports.filterableWithIndex = exports.filterable = exports.field = exports.extend = exports.endomorphism = exports.eitherT = exports.either = exports.distributiveLattice = exports.date = exports.contravariant = exports.const = exports.console = exports.compactable = exports.comonad = exports.choice = exports.chainRec = exports.chain = exports.category = exports.boundedMeetSemilattice = exports.boundedLattice = exports.boundedJoinSemilattice = exports.boundedDistributiveLattice = exports.bounded = exports.booleanAlgebra = exports.boolean = exports.bifunctor = exports.array = exports.apply = exports.applicative = exports.alternative = exports.alt = void 0;
-exports.string = exports.store = exports.stateT = exports.stateReaderTaskEither = exports.state = exports.show = exports.eq = exports.set = exports.separated = exports.semiring = exports.semigroupoid = exports.semigroup = exports.ring = exports.refinement = exports.record = exports.readerTask = exports.readonlyTuple = exports.readonlySet = exports.readonlyRecord = exports.readonlyNonEmptyArray = exports.readonlyMap = exports.readonlyArray = exports.readerTaskEither = exports.readerT = exports.readerEither = exports.reader = exports.random = exports.profunctor = exports.predicate = exports.pointed = exports.pipeable = exports.ordering = exports.ord = exports.optionT = exports.option = exports.number = exports.nonEmptyArray = exports.naturalTransformation = exports.monoid = exports.monadThrow = exports.monadTask = exports.monadIO = exports.monad = exports.meetSemilattice = exports.map = exports.magma = exports.lattice = exports.json = exports.joinSemilattice = exports.ioRef = void 0;
-exports.zero = exports.writerT = exports.writer = exports.witherable = exports.void = exports.validationT = exports.unfoldable = exports.tuple = exports.tree = exports.traversableWithIndex = exports.traversable = exports.traced = exports.theseT = exports.these = exports.taskThese = exports.taskOption = exports.taskEither = exports.task = exports.struct = exports.strong = void 0;
+exports.ioRef = exports.ioEither = exports.io = exports.invariant = exports.identity = exports.hkt = exports.heytingAlgebra = exports.group = exports.functorWithIndex = exports.functor = exports.function = exports.fromThese = exports.fromTask = exports.fromState = exports.fromReader = exports.fromIO = exports.fromEither = exports.foldableWithIndex = exports.foldable = exports.filterableWithIndex = exports.filterable = exports.field = exports.extend = exports.endomorphism = exports.eitherT = exports.either = exports.distributiveLattice = exports.date = exports.contravariant = exports.const = exports.console = exports.compactable = exports.comonad = exports.choice = exports.chainRec = exports.chain = exports.category = exports.boundedMeetSemilattice = exports.boundedLattice = exports.boundedJoinSemilattice = exports.boundedDistributiveLattice = exports.bounded = exports.booleanAlgebra = exports.boolean = exports.bifunctor = exports.array = exports.apply = exports.applicative = exports.alternative = exports.alt = void 0;
+exports.strong = exports.string = exports.store = exports.stateT = exports.stateReaderTaskEither = exports.state = exports.show = exports.eq = exports.set = exports.separated = exports.semiring = exports.semigroupoid = exports.semigroup = exports.ring = exports.refinement = exports.record = exports.readerTask = exports.readonlyTuple = exports.readonlySet = exports.readonlyRecord = exports.readonlyNonEmptyArray = exports.readonlyMap = exports.readonlyArray = exports.readerTaskEither = exports.readerT = exports.readerEither = exports.reader = exports.random = exports.profunctor = exports.predicate = exports.pointed = exports.pipeable = exports.ordering = exports.ord = exports.optionT = exports.option = exports.number = exports.nonEmptyArray = exports.naturalTransformation = exports.monoid = exports.monadThrow = exports.monadTask = exports.monadIO = exports.monad = exports.meetSemilattice = exports.map = exports.magma = exports.lattice = exports.json = exports.joinSemilattice = void 0;
+exports.zero = exports.writerT = exports.writer = exports.witherable = exports.void = exports.validationT = exports.unfoldable = exports.tuple = exports.tree = exports.traversableWithIndex = exports.traversable = exports.traced = exports.theseT = exports.these = exports.taskThese = exports.taskOption = exports.taskEither = exports.task = exports.struct = void 0;
 var alt = __importStar(require("./Alt"));
 exports.alt = alt;
 var alternative = __importStar(require("./Alternative"));
@@ -125,8 +125,6 @@ var io = __importStar(require("./IO"));
 exports.io = io;
 var ioEither = __importStar(require("./IOEither"));
 exports.ioEither = ioEither;
-var ioOption = __importStar(require("./IOOption"));
-exports.ioOption = ioOption;
 var ioRef = __importStar(require("./IORef"));
 exports.ioRef = ioRef;
 var joinSemilattice = __importStar(require("./JoinSemilattice"));
diff --git a/node_modules/fp-ts/lib/pipeable.d.ts b/node_modules/fp-ts/lib/pipeable.d.ts
index ae4994c..fe85699 100644
--- a/node_modules/fp-ts/lib/pipeable.d.ts
+++ b/node_modules/fp-ts/lib/pipeable.d.ts
@@ -1417,7 +1417,7 @@ export declare function pipeable<F, I>(
   (I extends Semigroupoid<F> ? PipeableSemigroupoid<F> : {}) &
   (I extends MonadThrow<F> ? PipeableMonadThrow<F> : {})
 /**
- * Use [`pipe`](https://gcanti.github.io/fp-ts/modules/function.ts.html#pipe) from `function` module instead.
+ * Use [`pipe`](https://gcanti.github.io/fp-ts/modules/function.ts.html#flow) from `function` module instead.
  *
  * @since 2.0.0
  * @deprecated
diff --git a/node_modules/fp-ts/lib/pipeable.js b/node_modules/fp-ts/lib/pipeable.js
index 5a81b72..128d45c 100644
--- a/node_modules/fp-ts/lib/pipeable.js
+++ b/node_modules/fp-ts/lib/pipeable.js
@@ -154,7 +154,7 @@ function pipeable(I) {
 }
 exports.pipeable = pipeable;
 /**
- * Use [`pipe`](https://gcanti.github.io/fp-ts/modules/function.ts.html#pipe) from `function` module instead.
+ * Use [`pipe`](https://gcanti.github.io/fp-ts/modules/function.ts.html#flow) from `function` module instead.
  *
  * @since 2.0.0
  * @deprecated
diff --git a/node_modules/fp-ts/lib/string.d.ts b/node_modules/fp-ts/lib/string.d.ts
index 9732fa8..f1d9762 100644
--- a/node_modules/fp-ts/lib/string.d.ts
+++ b/node_modules/fp-ts/lib/string.d.ts
@@ -31,12 +31,6 @@ export declare const Eq: E.Eq<string>
  * @since 2.10.0
  */
 export declare const Semigroup: S.Semigroup<string>
-/**
- * An empty `string`.
- *
- * @since 2.10.0
- */
-export declare const empty: string
 /**
  * `string` monoid under concatenation.
  *
@@ -162,6 +156,12 @@ export declare const trimRight: (s: string) => string
  * @since 2.11.0
  */
 export declare const slice: (start: number, end: number) => (s: string) => string
+/**
+ * An empty `string`.
+ *
+ * @since 2.10.0
+ */
+export declare const empty: string
 /**
  * Test whether a `string` is empty.
  *
diff --git a/node_modules/fp-ts/lib/string.js b/node_modules/fp-ts/lib/string.js
index 8b59c89..7d1134a 100644
--- a/node_modules/fp-ts/lib/string.js
+++ b/node_modules/fp-ts/lib/string.js
@@ -1,6 +1,6 @@
 "use strict";
 Object.defineProperty(exports, "__esModule", { value: true });
-exports.endsWith = exports.startsWith = exports.includes = exports.split = exports.size = exports.isEmpty = exports.slice = exports.trimRight = exports.trimLeft = exports.trim = exports.replace = exports.toLowerCase = exports.toUpperCase = exports.isString = exports.Show = exports.Ord = exports.Monoid = exports.empty = exports.Semigroup = exports.Eq = void 0;
+exports.endsWith = exports.startsWith = exports.includes = exports.split = exports.size = exports.isEmpty = exports.empty = exports.slice = exports.trimRight = exports.trimLeft = exports.trim = exports.replace = exports.toLowerCase = exports.toUpperCase = exports.isString = exports.Show = exports.Ord = exports.Monoid = exports.Semigroup = exports.Eq = void 0;
 var ReadonlyNonEmptyArray_1 = require("./ReadonlyNonEmptyArray");
 // -------------------------------------------------------------------------------------
 // instances
@@ -32,12 +32,6 @@ exports.Eq = {
 exports.Semigroup = {
     concat: function (first, second) { return first + second; }
 };
-/**
- * An empty `string`.
- *
- * @since 2.10.0
- */
-exports.empty = '';
 /**
  * `string` monoid under concatenation.
  *
@@ -54,7 +48,7 @@ exports.empty = '';
  */
 exports.Monoid = {
     concat: exports.Semigroup.concat,
-    empty: exports.empty
+    empty: ''
 };
 /**
  * @example
@@ -190,6 +184,12 @@ exports.slice = slice;
 // -------------------------------------------------------------------------------------
 // utils
 // -------------------------------------------------------------------------------------
+/**
+ * An empty `string`.
+ *
+ * @since 2.10.0
+ */
+exports.empty = '';
 /**
  * Test whether a `string` is empty.
  *
